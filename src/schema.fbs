// Flatbuffers schema for serialized models.
//
// See https://google.github.io/flatbuffers/flatbuffers_guide_writing_schema.html.

file_identifier "MODL";
file_extension "model";

// Type for an operator node
enum OperatorType: byte {
  Add,
  AveragePool,
  BatchNormalization,
  Cast,
  Clip,
  Concat,
  ConstantOfShape,
  Conv,
  ConvTranspose,
  Div,
  Equal,
  Erf,
  Expand,
  Gather,
  Gemm,
  GlobalAveragePool,
  Identity,
  LeakyRelu,
  Less,
  MatMul,
  MaxPool,
  Mul,
  Pad,
  Pow,
  Range,
  ReduceMean,
  Relu,
  Reshape,
  Shape,
  Sigmoid,
  Slice,
  Split,
  Sqrt,
  Squeeze,
  Softmax,
  Sub,
  Transpose,
  Unsqueeze,
  Where
}

enum PadMode: byte {
  Same,
  Fixed
}

enum DataType: byte {
  Int32,
  Float
}

// Operator-specific configuration
union OperatorAttrs {
  AveragePoolAttrs,
  BatchNormalizationAttrs,
  CastAttrs,
  ClipAttrs,
  ConcatAttrs,
  ConstantOfShapeAttrs,
  ConvAttrs,
  ConvTransposeAttrs,
  GatherAttrs,
  GemmAttrs,
  LeakyReluAttrs,
  MaxPoolAttrs,
  PadAttrs,
  ReduceMeanAttrs,
  SplitAttrs,
  SqueezeAttrs,
  SoftmaxAttrs,
  TransposeAttrs,
  UnsqueezeAttrs
}

table AveragePoolAttrs {
  kernel_size:uint;
  pad_mode:PadMode;

  // Padding for spatial axes as [top, left, bottom, right]
  pads:[uint];

  stride:uint;
}

table BatchNormalizationAttrs {
  epsilon:float;
}

table CastAttrs {
  to:DataType;
}

table ClipAttrs {
  min:float;
  max:float;
}

table ConcatAttrs {
  dim:uint;
}

union Scalar {
  IntScalar,
  FloatScalar
}

table IntScalar {
  value:int32;
}

table FloatScalar {
  value:float32;
}

table ConstantOfShapeAttrs {
  value:Scalar (required);
}

table ConvAttrs {
  pad_mode:PadMode;

  // Padding for spatial axes as [top, left, bottom, right]
  pads:[uint];

  groups:uint;
  stride:uint;
}

table ConvTransposeAttrs {
  stride:uint;
}

table GatherAttrs {
  axis:uint;
}

table GemmAttrs {
  alpha:float;
  beta:float;
  transpose_a:bool;
  transpose_b:bool;
}

table LeakyReluAttrs {
  alpha:float;
}

table MaxPoolAttrs {
  kernel_size:uint;
  pad_mode:PadMode;

  // Padding for spatial axes as [top, left, bottom, right]
  pads:[uint];

  stride:uint;
}

table PadAttrs {}

table ReduceMeanAttrs {
  axes:[int];
  keep_dims:bool;
}

table SoftmaxAttrs {
  axis:uint;
}

table SplitAttrs {
  axis:int;
  split:[uint];
}

table SqueezeAttrs {
  axes:[uint];
}

table TransposeAttrs {
  perm:[uint];
}

table UnsqueezeAttrs {
  axes:[uint] (required);
}

// Node in the dataflow graph
union NodeKind {
  OperatorNode,
  ConstantNode,
  ValueNode
}

// Graph node that computes an output tensor given one or more inputs and
// operator configuration.
table OperatorNode {
  type:OperatorType;
  attrs:OperatorAttrs;

  // Indexes of input nodes
  inputs:[uint];

  // Indexes of output nodes
  outputs:[uint];
}

union ConstantData {
  FloatData,
  IntData,
}

table FloatData {
  data: [float32] (required);
}

table IntData {
  data: [int32] (required);
}

// Graph node for a constant tensor value, whose data is part of the model.
table ConstantNode {
  shape:[uint] (required);
  data:ConstantData (required);
}

// Graph node for a dynamic tensor value, such as a model input or operator
// output.
table ValueNode {}

table Node {
  // Identifier for external referencing and debugging
  name:string;
  data:NodeKind;
}

// Dataflow graph for the model
table Graph {
  // Nodes are sorted in topological order. This means that if a node references
  // other nodes (eg. an operator node referencing inputs), the referents must
  // come earlier in the list.
  nodes:[Node];

  // IDs of input nodes
  inputs:[uint];

  // IDs of output nodes
  outputs:[uint];
}

table Model {
  schema_version:int;
  graph:Graph (required);
}

root_type Model;
