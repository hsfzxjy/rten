// Flatbuffers schema for serialized models.
//
// See https://google.github.io/flatbuffers/flatbuffers_guide_writing_schema.html.

file_identifier "MODL";
file_extension "model";

// Type for an operator node
enum OperatorType: byte {
  Add,
  ArgMin,
  ArgMax,
  AveragePool,
  BatchNormalization,
  Cast,
  Clip,
  Concat,
  ConstantOfShape,
  Conv,
  ConvTranspose,
  Cos,
  CumSum,
  Div,
  Equal,
  Erf,
  Expand,
  Flatten,
  Gather,
  Gemm,
  GlobalAveragePool,
  Greater,
  GRU,
  Identity,
  LeakyRelu,
  Less,
  LessOrEqual,
  Log,
  LogSoftmax,
  LSTM,
  MatMul,
  MaxPool,
  Mod,
  Mul,
  Pad,
  Pow,
  Range,
  ReduceMean,
  ReduceL2,
  Relu,
  Reshape,
  Resize,
  Shape,
  Sigmoid,
  Sin,
  Slice,
  Split,
  Sqrt,
  Squeeze,
  Softmax,
  Sub,
  Tanh,
  Transpose,
  Unsqueeze,
  Where,

  // New operators. These are appended here to preserve binary compatibility
  // of existing model files.
  ReduceProd,
  ReduceSum,
  ReduceMin,
  ReduceMax,
  NonZero
}

enum RNNDirection: byte {
  Forwards,
  Reverse,
  Bidirectional
}

enum PadMode: byte {
  Same,
  Fixed
}

enum DataType: byte {
  Int32,
  Float
}

// Coordinate transform modes for Resize operator.
enum CoordTransformMode: byte {
  HalfPixel,
  Asymmetric
}

// Rounding modes supported by Resize operator when `ResizeMode` is `Nearest`.
enum NearestMode: byte {
  Floor,
  Ceil,
  RoundPreferFloor,
  RoundPreferCeil,
}

enum ResizeMode: byte {
  Nearest,
  Linear
}

// Operator-specific configuration
union OperatorAttrs {
  ArgMaxAttrs, // Also used for ArgMin
  AveragePoolAttrs,
  BatchNormalizationAttrs,
  CastAttrs,
  ConcatAttrs,
  ConstantOfShapeAttrs,
  ConvAttrs,
  ConvTransposeAttrs,
  FlattenAttrs,
  GatherAttrs,
  GemmAttrs,
  GRUAttrs,
  LeakyReluAttrs,
  LSTMAttrs,
  MaxPoolAttrs,
  ReduceMeanAttrs, // Also used for Reduce* ops
  ReshapeAttrs,
  ResizeAttrs,
  SplitAttrs,
  SoftmaxAttrs, // Also used for LogSoftmax
  TransposeAttrs,

  // New operator attrs. These are appended here to preserve binary compatibility
  // of existing model files.
  ModAttrs,
}

table ArgMaxAttrs {
  axis:int;
  keep_dims:bool;
}

table AveragePoolAttrs {
  kernel_size:[uint] (required);
  pad_mode:PadMode;

  // Padding for spatial axes as [top, left, bottom, right]
  pads:[uint];

  strides:[uint];
}

table BatchNormalizationAttrs {
  epsilon:float;
}

table CastAttrs {
  to:DataType;
}

table ConcatAttrs {
  dim:uint;
}

union Scalar {
  IntScalar,
  FloatScalar
}

table IntScalar {
  value:int32;
}

table FloatScalar {
  value:float32;
}

table ConstantOfShapeAttrs {
  value:Scalar (required);
}

table ConvAttrs {
  pad_mode:PadMode;

  // Padding for spatial axes as [top, left, bottom, right]
  pads:[uint];

  groups:uint;
  strides:[uint];
}

table ConvTransposeAttrs {
  strides:[uint];
}

table FlattenAttrs {
  axis:int;
}

table GatherAttrs {
  axis:uint;
}

table GemmAttrs {
  alpha:float;
  beta:float;
  transpose_a:bool;
  transpose_b:bool;
}

table GRUAttrs {
  direction:RNNDirection;
  hidden_size:uint;
  linear_before_reset:bool;
}

table LeakyReluAttrs {
  alpha:float;
}

table LSTMAttrs {
  direction:RNNDirection;
  hidden_size:uint;
}

table MaxPoolAttrs {
  kernel_size:[uint] (required);
  pad_mode:PadMode;

  // Padding for spatial axes as [top, left, bottom, right]
  pads:[uint];

  strides:[uint];
}

table ModAttrs {
  fmod:bool;
}

table ReduceMeanAttrs {
  axes:[int];
  keep_dims:bool;
}

table ReshapeAttrs {
  allow_zero:bool;
}

table ResizeAttrs {
  mode:ResizeMode;
  coord_mode:CoordTransformMode;
  nearest_mode:NearestMode;
}

table SoftmaxAttrs {
  axis:int;
}

table SplitAttrs {
  axis:int;
}

table TransposeAttrs {
  perm:[uint];
}

// Node in the dataflow graph
union NodeKind {
  OperatorNode,
  ConstantNode,
  ValueNode
}

// Graph node that computes an output tensor given one or more inputs and
// operator configuration.
table OperatorNode {
  type:OperatorType;
  attrs:OperatorAttrs;

  // Indexes of input nodes. Negative values indicate missing optional inputs.
  inputs:[int];

  // Indexes of output nodes. Negative values indicate unused outputs.
  outputs:[int];
}

union ConstantData {
  FloatData,
  IntData,
}

table FloatData {
  data: [float32] (required);
}

table IntData {
  data: [int32] (required);
}

// Graph node for a constant tensor value, whose data is part of the model.
table ConstantNode {
  shape:[uint] (required);
  data:ConstantData (required);
}

// Dimension of a ValueNode's shape. This can be either a fixed value or a
// symbolic name.
//
// This is logically a union, but uses a table due to
// https://github.com/google/flatbuffers/issues/5024.
table Dim {
  value:uint;
  name:string;
}

// Graph node for a dynamic tensor value, such as a model input or operator
// output.
table ValueNode {
  // Expected shape of the tensor at runtime.
  shape:[Dim];
}

table Node {
  // Identifier for external referencing and debugging
  name:string;
  data:NodeKind;
}

// Dataflow graph for the model
table Graph {
  // Nodes are sorted in topological order. This means that if a node references
  // other nodes (eg. an operator node referencing inputs), the referents must
  // come earlier in the list.
  nodes:[Node];

  // IDs of input nodes
  inputs:[uint];

  // IDs of output nodes
  outputs:[uint];
}

table Model {
  schema_version:int;
  graph:Graph (required);
}

root_type Model;
