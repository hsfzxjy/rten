#![allow(clippy::all)]
// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_OPERATOR_TYPE: i8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_OPERATOR_TYPE: i8 = 13;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_OPERATOR_TYPE: [OperatorType; 14] = [
    OperatorType::Add,
    OperatorType::Clip,
    OperatorType::Concat,
    OperatorType::Conv2d,
    OperatorType::ConvTranspose2d,
    OperatorType::GlobalAveragePool,
    OperatorType::MatMul,
    OperatorType::MaxPool2d,
    OperatorType::Pad2d,
    OperatorType::ReLU,
    OperatorType::Reshape,
    OperatorType::Shape,
    OperatorType::Sigmoid,
    OperatorType::Slice,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct OperatorType(pub i8);
#[allow(non_upper_case_globals)]
impl OperatorType {
    pub const Add: Self = Self(0);
    pub const Clip: Self = Self(1);
    pub const Concat: Self = Self(2);
    pub const Conv2d: Self = Self(3);
    pub const ConvTranspose2d: Self = Self(4);
    pub const GlobalAveragePool: Self = Self(5);
    pub const MatMul: Self = Self(6);
    pub const MaxPool2d: Self = Self(7);
    pub const Pad2d: Self = Self(8);
    pub const ReLU: Self = Self(9);
    pub const Reshape: Self = Self(10);
    pub const Shape: Self = Self(11);
    pub const Sigmoid: Self = Self(12);
    pub const Slice: Self = Self(13);

    pub const ENUM_MIN: i8 = 0;
    pub const ENUM_MAX: i8 = 13;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::Add,
        Self::Clip,
        Self::Concat,
        Self::Conv2d,
        Self::ConvTranspose2d,
        Self::GlobalAveragePool,
        Self::MatMul,
        Self::MaxPool2d,
        Self::Pad2d,
        Self::ReLU,
        Self::Reshape,
        Self::Shape,
        Self::Sigmoid,
        Self::Slice,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::Add => Some("Add"),
            Self::Clip => Some("Clip"),
            Self::Concat => Some("Concat"),
            Self::Conv2d => Some("Conv2d"),
            Self::ConvTranspose2d => Some("ConvTranspose2d"),
            Self::GlobalAveragePool => Some("GlobalAveragePool"),
            Self::MatMul => Some("MatMul"),
            Self::MaxPool2d => Some("MaxPool2d"),
            Self::Pad2d => Some("Pad2d"),
            Self::ReLU => Some("ReLU"),
            Self::Reshape => Some("Reshape"),
            Self::Shape => Some("Shape"),
            Self::Sigmoid => Some("Sigmoid"),
            Self::Slice => Some("Slice"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for OperatorType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for OperatorType {
    type Inner = Self;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i8>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for OperatorType {
    type Output = OperatorType;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe {
            flatbuffers::emplace_scalar::<i8>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for OperatorType {
    #[inline]
    fn to_little_endian(self) -> Self {
        let b = i8::to_le(self.0);
        Self(b)
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(self) -> Self {
        let b = i8::from_le(self.0);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for OperatorType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for OperatorType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_PAD_MODE: i8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_PAD_MODE: i8 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_PAD_MODE: [PadMode; 2] = [PadMode::Same, PadMode::Fixed];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct PadMode(pub i8);
#[allow(non_upper_case_globals)]
impl PadMode {
    pub const Same: Self = Self(0);
    pub const Fixed: Self = Self(1);

    pub const ENUM_MIN: i8 = 0;
    pub const ENUM_MAX: i8 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::Same, Self::Fixed];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::Same => Some("Same"),
            Self::Fixed => Some("Fixed"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for PadMode {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for PadMode {
    type Inner = Self;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i8>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for PadMode {
    type Output = PadMode;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe {
            flatbuffers::emplace_scalar::<i8>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for PadMode {
    #[inline]
    fn to_little_endian(self) -> Self {
        let b = i8::to_le(self.0);
        Self(b)
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(self) -> Self {
        let b = i8::from_le(self.0);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for PadMode {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for PadMode {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_OPERATOR_ATTRS: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_OPERATOR_ATTRS: u8 = 7;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_OPERATOR_ATTRS: [OperatorAttrs; 8] = [
    OperatorAttrs::NONE,
    OperatorAttrs::ClipAttrs,
    OperatorAttrs::ConcatAttrs,
    OperatorAttrs::Conv2dAttrs,
    OperatorAttrs::ConvTranspose2dAttrs,
    OperatorAttrs::MaxPool2dAttrs,
    OperatorAttrs::Pad2dAttrs,
    OperatorAttrs::SliceAttrs,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct OperatorAttrs(pub u8);
#[allow(non_upper_case_globals)]
impl OperatorAttrs {
    pub const NONE: Self = Self(0);
    pub const ClipAttrs: Self = Self(1);
    pub const ConcatAttrs: Self = Self(2);
    pub const Conv2dAttrs: Self = Self(3);
    pub const ConvTranspose2dAttrs: Self = Self(4);
    pub const MaxPool2dAttrs: Self = Self(5);
    pub const Pad2dAttrs: Self = Self(6);
    pub const SliceAttrs: Self = Self(7);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 7;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::ClipAttrs,
        Self::ConcatAttrs,
        Self::Conv2dAttrs,
        Self::ConvTranspose2dAttrs,
        Self::MaxPool2dAttrs,
        Self::Pad2dAttrs,
        Self::SliceAttrs,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::ClipAttrs => Some("ClipAttrs"),
            Self::ConcatAttrs => Some("ConcatAttrs"),
            Self::Conv2dAttrs => Some("Conv2dAttrs"),
            Self::ConvTranspose2dAttrs => Some("ConvTranspose2dAttrs"),
            Self::MaxPool2dAttrs => Some("MaxPool2dAttrs"),
            Self::Pad2dAttrs => Some("Pad2dAttrs"),
            Self::SliceAttrs => Some("SliceAttrs"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for OperatorAttrs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for OperatorAttrs {
    type Inner = Self;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for OperatorAttrs {
    type Output = OperatorAttrs;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for OperatorAttrs {
    #[inline]
    fn to_little_endian(self) -> Self {
        let b = u8::to_le(self.0);
        Self(b)
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(self) -> Self {
        let b = u8::from_le(self.0);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for OperatorAttrs {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for OperatorAttrs {}
pub struct OperatorAttrsUnionTableOffset {}

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_NODE_KIND: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_NODE_KIND: u8 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_NODE_KIND: [NodeKind; 4] = [
    NodeKind::NONE,
    NodeKind::OperatorNode,
    NodeKind::ConstantNode,
    NodeKind::ValueNode,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct NodeKind(pub u8);
#[allow(non_upper_case_globals)]
impl NodeKind {
    pub const NONE: Self = Self(0);
    pub const OperatorNode: Self = Self(1);
    pub const ConstantNode: Self = Self(2);
    pub const ValueNode: Self = Self(3);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 3;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::OperatorNode,
        Self::ConstantNode,
        Self::ValueNode,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::OperatorNode => Some("OperatorNode"),
            Self::ConstantNode => Some("ConstantNode"),
            Self::ValueNode => Some("ValueNode"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for NodeKind {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for NodeKind {
    type Inner = Self;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for NodeKind {
    type Output = NodeKind;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for NodeKind {
    #[inline]
    fn to_little_endian(self) -> Self {
        let b = u8::to_le(self.0);
        Self(b)
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(self) -> Self {
        let b = u8::from_le(self.0);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for NodeKind {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for NodeKind {}
pub struct NodeKindUnionTableOffset {}

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_CONSTANT_DATA: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_CONSTANT_DATA: u8 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_CONSTANT_DATA: [ConstantData; 3] = [
    ConstantData::NONE,
    ConstantData::FloatData,
    ConstantData::IntData,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ConstantData(pub u8);
#[allow(non_upper_case_globals)]
impl ConstantData {
    pub const NONE: Self = Self(0);
    pub const FloatData: Self = Self(1);
    pub const IntData: Self = Self(2);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::FloatData, Self::IntData];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::FloatData => Some("FloatData"),
            Self::IntData => Some("IntData"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for ConstantData {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for ConstantData {
    type Inner = Self;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for ConstantData {
    type Output = ConstantData;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for ConstantData {
    #[inline]
    fn to_little_endian(self) -> Self {
        let b = u8::to_le(self.0);
        Self(b)
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(self) -> Self {
        let b = u8::from_le(self.0);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for ConstantData {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for ConstantData {}
pub struct ConstantDataUnionTableOffset {}

pub enum ClipAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ClipAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ClipAttrs<'a> {
    type Inner = ClipAttrs<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> ClipAttrs<'a> {
    pub const VT_MIN: flatbuffers::VOffsetT = 4;
    pub const VT_MAX: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ClipAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ClipAttrsArgs,
    ) -> flatbuffers::WIPOffset<ClipAttrs<'bldr>> {
        let mut builder = ClipAttrsBuilder::new(_fbb);
        builder.add_max(args.max);
        builder.add_min(args.min);
        builder.finish()
    }

    #[inline]
    pub fn min(&self) -> f32 {
        self._tab.get::<f32>(ClipAttrs::VT_MIN, Some(0.0)).unwrap()
    }
    #[inline]
    pub fn max(&self) -> f32 {
        self._tab.get::<f32>(ClipAttrs::VT_MAX, Some(0.0)).unwrap()
    }
}

impl flatbuffers::Verifiable for ClipAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<f32>("min", Self::VT_MIN, false)?
            .visit_field::<f32>("max", Self::VT_MAX, false)?
            .finish();
        Ok(())
    }
}
pub struct ClipAttrsArgs {
    pub min: f32,
    pub max: f32,
}
impl<'a> Default for ClipAttrsArgs {
    #[inline]
    fn default() -> Self {
        ClipAttrsArgs { min: 0.0, max: 0.0 }
    }
}

pub struct ClipAttrsBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ClipAttrsBuilder<'a, 'b> {
    #[inline]
    pub fn add_min(&mut self, min: f32) {
        self.fbb_.push_slot::<f32>(ClipAttrs::VT_MIN, min, 0.0);
    }
    #[inline]
    pub fn add_max(&mut self, max: f32) {
        self.fbb_.push_slot::<f32>(ClipAttrs::VT_MAX, max, 0.0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ClipAttrsBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ClipAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ClipAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ClipAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ClipAttrs");
        ds.field("min", &self.min());
        ds.field("max", &self.max());
        ds.finish()
    }
}
pub enum ConcatAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ConcatAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ConcatAttrs<'a> {
    type Inner = ConcatAttrs<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> ConcatAttrs<'a> {
    pub const VT_DIM: flatbuffers::VOffsetT = 4;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ConcatAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ConcatAttrsArgs,
    ) -> flatbuffers::WIPOffset<ConcatAttrs<'bldr>> {
        let mut builder = ConcatAttrsBuilder::new(_fbb);
        builder.add_dim(args.dim);
        builder.finish()
    }

    #[inline]
    pub fn dim(&self) -> u32 {
        self._tab.get::<u32>(ConcatAttrs::VT_DIM, Some(0)).unwrap()
    }
}

impl flatbuffers::Verifiable for ConcatAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<u32>("dim", Self::VT_DIM, false)?
            .finish();
        Ok(())
    }
}
pub struct ConcatAttrsArgs {
    pub dim: u32,
}
impl<'a> Default for ConcatAttrsArgs {
    #[inline]
    fn default() -> Self {
        ConcatAttrsArgs { dim: 0 }
    }
}

pub struct ConcatAttrsBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ConcatAttrsBuilder<'a, 'b> {
    #[inline]
    pub fn add_dim(&mut self, dim: u32) {
        self.fbb_.push_slot::<u32>(ConcatAttrs::VT_DIM, dim, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ConcatAttrsBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ConcatAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ConcatAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ConcatAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ConcatAttrs");
        ds.field("dim", &self.dim());
        ds.finish()
    }
}
pub enum Conv2dAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Conv2dAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Conv2dAttrs<'a> {
    type Inner = Conv2dAttrs<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> Conv2dAttrs<'a> {
    pub const VT_PAD_MODE: flatbuffers::VOffsetT = 4;
    pub const VT_PAD_HORIZONTAL: flatbuffers::VOffsetT = 6;
    pub const VT_PAD_VERTICAL: flatbuffers::VOffsetT = 8;
    pub const VT_GROUPS: flatbuffers::VOffsetT = 10;
    pub const VT_STRIDE: flatbuffers::VOffsetT = 12;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Conv2dAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args Conv2dAttrsArgs,
    ) -> flatbuffers::WIPOffset<Conv2dAttrs<'bldr>> {
        let mut builder = Conv2dAttrsBuilder::new(_fbb);
        builder.add_stride(args.stride);
        builder.add_groups(args.groups);
        builder.add_pad_vertical(args.pad_vertical);
        builder.add_pad_horizontal(args.pad_horizontal);
        builder.add_pad_mode(args.pad_mode);
        builder.finish()
    }

    #[inline]
    pub fn pad_mode(&self) -> PadMode {
        self._tab
            .get::<PadMode>(Conv2dAttrs::VT_PAD_MODE, Some(PadMode::Same))
            .unwrap()
    }
    #[inline]
    pub fn pad_horizontal(&self) -> u32 {
        self._tab
            .get::<u32>(Conv2dAttrs::VT_PAD_HORIZONTAL, Some(0))
            .unwrap()
    }
    #[inline]
    pub fn pad_vertical(&self) -> u32 {
        self._tab
            .get::<u32>(Conv2dAttrs::VT_PAD_VERTICAL, Some(0))
            .unwrap()
    }
    #[inline]
    pub fn groups(&self) -> u32 {
        self._tab
            .get::<u32>(Conv2dAttrs::VT_GROUPS, Some(0))
            .unwrap()
    }
    #[inline]
    pub fn stride(&self) -> u32 {
        self._tab
            .get::<u32>(Conv2dAttrs::VT_STRIDE, Some(0))
            .unwrap()
    }
}

impl flatbuffers::Verifiable for Conv2dAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<PadMode>("pad_mode", Self::VT_PAD_MODE, false)?
            .visit_field::<u32>("pad_horizontal", Self::VT_PAD_HORIZONTAL, false)?
            .visit_field::<u32>("pad_vertical", Self::VT_PAD_VERTICAL, false)?
            .visit_field::<u32>("groups", Self::VT_GROUPS, false)?
            .visit_field::<u32>("stride", Self::VT_STRIDE, false)?
            .finish();
        Ok(())
    }
}
pub struct Conv2dAttrsArgs {
    pub pad_mode: PadMode,
    pub pad_horizontal: u32,
    pub pad_vertical: u32,
    pub groups: u32,
    pub stride: u32,
}
impl<'a> Default for Conv2dAttrsArgs {
    #[inline]
    fn default() -> Self {
        Conv2dAttrsArgs {
            pad_mode: PadMode::Same,
            pad_horizontal: 0,
            pad_vertical: 0,
            groups: 0,
            stride: 0,
        }
    }
}

pub struct Conv2dAttrsBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> Conv2dAttrsBuilder<'a, 'b> {
    #[inline]
    pub fn add_pad_mode(&mut self, pad_mode: PadMode) {
        self.fbb_
            .push_slot::<PadMode>(Conv2dAttrs::VT_PAD_MODE, pad_mode, PadMode::Same);
    }
    #[inline]
    pub fn add_pad_horizontal(&mut self, pad_horizontal: u32) {
        self.fbb_
            .push_slot::<u32>(Conv2dAttrs::VT_PAD_HORIZONTAL, pad_horizontal, 0);
    }
    #[inline]
    pub fn add_pad_vertical(&mut self, pad_vertical: u32) {
        self.fbb_
            .push_slot::<u32>(Conv2dAttrs::VT_PAD_VERTICAL, pad_vertical, 0);
    }
    #[inline]
    pub fn add_groups(&mut self, groups: u32) {
        self.fbb_
            .push_slot::<u32>(Conv2dAttrs::VT_GROUPS, groups, 0);
    }
    #[inline]
    pub fn add_stride(&mut self, stride: u32) {
        self.fbb_
            .push_slot::<u32>(Conv2dAttrs::VT_STRIDE, stride, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> Conv2dAttrsBuilder<'a, 'b> {
        let start = _fbb.start_table();
        Conv2dAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Conv2dAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for Conv2dAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("Conv2dAttrs");
        ds.field("pad_mode", &self.pad_mode());
        ds.field("pad_horizontal", &self.pad_horizontal());
        ds.field("pad_vertical", &self.pad_vertical());
        ds.field("groups", &self.groups());
        ds.field("stride", &self.stride());
        ds.finish()
    }
}
pub enum ConvTranspose2dAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ConvTranspose2dAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ConvTranspose2dAttrs<'a> {
    type Inner = ConvTranspose2dAttrs<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> ConvTranspose2dAttrs<'a> {
    pub const VT_STRIDE: flatbuffers::VOffsetT = 4;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ConvTranspose2dAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ConvTranspose2dAttrsArgs,
    ) -> flatbuffers::WIPOffset<ConvTranspose2dAttrs<'bldr>> {
        let mut builder = ConvTranspose2dAttrsBuilder::new(_fbb);
        builder.add_stride(args.stride);
        builder.finish()
    }

    #[inline]
    pub fn stride(&self) -> u32 {
        self._tab
            .get::<u32>(ConvTranspose2dAttrs::VT_STRIDE, Some(0))
            .unwrap()
    }
}

impl flatbuffers::Verifiable for ConvTranspose2dAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<u32>("stride", Self::VT_STRIDE, false)?
            .finish();
        Ok(())
    }
}
pub struct ConvTranspose2dAttrsArgs {
    pub stride: u32,
}
impl<'a> Default for ConvTranspose2dAttrsArgs {
    #[inline]
    fn default() -> Self {
        ConvTranspose2dAttrsArgs { stride: 0 }
    }
}

pub struct ConvTranspose2dAttrsBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ConvTranspose2dAttrsBuilder<'a, 'b> {
    #[inline]
    pub fn add_stride(&mut self, stride: u32) {
        self.fbb_
            .push_slot::<u32>(ConvTranspose2dAttrs::VT_STRIDE, stride, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> ConvTranspose2dAttrsBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ConvTranspose2dAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ConvTranspose2dAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ConvTranspose2dAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ConvTranspose2dAttrs");
        ds.field("stride", &self.stride());
        ds.finish()
    }
}
pub enum MaxPool2dAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MaxPool2dAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MaxPool2dAttrs<'a> {
    type Inner = MaxPool2dAttrs<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> MaxPool2dAttrs<'a> {
    pub const VT_KERNEL_SIZE: flatbuffers::VOffsetT = 4;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        MaxPool2dAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args MaxPool2dAttrsArgs,
    ) -> flatbuffers::WIPOffset<MaxPool2dAttrs<'bldr>> {
        let mut builder = MaxPool2dAttrsBuilder::new(_fbb);
        builder.add_kernel_size(args.kernel_size);
        builder.finish()
    }

    #[inline]
    pub fn kernel_size(&self) -> u32 {
        self._tab
            .get::<u32>(MaxPool2dAttrs::VT_KERNEL_SIZE, Some(0))
            .unwrap()
    }
}

impl flatbuffers::Verifiable for MaxPool2dAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<u32>("kernel_size", Self::VT_KERNEL_SIZE, false)?
            .finish();
        Ok(())
    }
}
pub struct MaxPool2dAttrsArgs {
    pub kernel_size: u32,
}
impl<'a> Default for MaxPool2dAttrsArgs {
    #[inline]
    fn default() -> Self {
        MaxPool2dAttrsArgs { kernel_size: 0 }
    }
}

pub struct MaxPool2dAttrsBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MaxPool2dAttrsBuilder<'a, 'b> {
    #[inline]
    pub fn add_kernel_size(&mut self, kernel_size: u32) {
        self.fbb_
            .push_slot::<u32>(MaxPool2dAttrs::VT_KERNEL_SIZE, kernel_size, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MaxPool2dAttrsBuilder<'a, 'b> {
        let start = _fbb.start_table();
        MaxPool2dAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<MaxPool2dAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for MaxPool2dAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("MaxPool2dAttrs");
        ds.field("kernel_size", &self.kernel_size());
        ds.finish()
    }
}
pub enum Pad2dAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Pad2dAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Pad2dAttrs<'a> {
    type Inner = Pad2dAttrs<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> Pad2dAttrs<'a> {
    pub const VT_PAD_LEFT: flatbuffers::VOffsetT = 4;
    pub const VT_PAD_RIGHT: flatbuffers::VOffsetT = 6;
    pub const VT_PAD_TOP: flatbuffers::VOffsetT = 8;
    pub const VT_PAD_BOTTOM: flatbuffers::VOffsetT = 10;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Pad2dAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args Pad2dAttrsArgs,
    ) -> flatbuffers::WIPOffset<Pad2dAttrs<'bldr>> {
        let mut builder = Pad2dAttrsBuilder::new(_fbb);
        builder.add_pad_bottom(args.pad_bottom);
        builder.add_pad_top(args.pad_top);
        builder.add_pad_right(args.pad_right);
        builder.add_pad_left(args.pad_left);
        builder.finish()
    }

    #[inline]
    pub fn pad_left(&self) -> u32 {
        self._tab
            .get::<u32>(Pad2dAttrs::VT_PAD_LEFT, Some(0))
            .unwrap()
    }
    #[inline]
    pub fn pad_right(&self) -> u32 {
        self._tab
            .get::<u32>(Pad2dAttrs::VT_PAD_RIGHT, Some(0))
            .unwrap()
    }
    #[inline]
    pub fn pad_top(&self) -> u32 {
        self._tab
            .get::<u32>(Pad2dAttrs::VT_PAD_TOP, Some(0))
            .unwrap()
    }
    #[inline]
    pub fn pad_bottom(&self) -> u32 {
        self._tab
            .get::<u32>(Pad2dAttrs::VT_PAD_BOTTOM, Some(0))
            .unwrap()
    }
}

impl flatbuffers::Verifiable for Pad2dAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<u32>("pad_left", Self::VT_PAD_LEFT, false)?
            .visit_field::<u32>("pad_right", Self::VT_PAD_RIGHT, false)?
            .visit_field::<u32>("pad_top", Self::VT_PAD_TOP, false)?
            .visit_field::<u32>("pad_bottom", Self::VT_PAD_BOTTOM, false)?
            .finish();
        Ok(())
    }
}
pub struct Pad2dAttrsArgs {
    pub pad_left: u32,
    pub pad_right: u32,
    pub pad_top: u32,
    pub pad_bottom: u32,
}
impl<'a> Default for Pad2dAttrsArgs {
    #[inline]
    fn default() -> Self {
        Pad2dAttrsArgs {
            pad_left: 0,
            pad_right: 0,
            pad_top: 0,
            pad_bottom: 0,
        }
    }
}

pub struct Pad2dAttrsBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> Pad2dAttrsBuilder<'a, 'b> {
    #[inline]
    pub fn add_pad_left(&mut self, pad_left: u32) {
        self.fbb_
            .push_slot::<u32>(Pad2dAttrs::VT_PAD_LEFT, pad_left, 0);
    }
    #[inline]
    pub fn add_pad_right(&mut self, pad_right: u32) {
        self.fbb_
            .push_slot::<u32>(Pad2dAttrs::VT_PAD_RIGHT, pad_right, 0);
    }
    #[inline]
    pub fn add_pad_top(&mut self, pad_top: u32) {
        self.fbb_
            .push_slot::<u32>(Pad2dAttrs::VT_PAD_TOP, pad_top, 0);
    }
    #[inline]
    pub fn add_pad_bottom(&mut self, pad_bottom: u32) {
        self.fbb_
            .push_slot::<u32>(Pad2dAttrs::VT_PAD_BOTTOM, pad_bottom, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> Pad2dAttrsBuilder<'a, 'b> {
        let start = _fbb.start_table();
        Pad2dAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Pad2dAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for Pad2dAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("Pad2dAttrs");
        ds.field("pad_left", &self.pad_left());
        ds.field("pad_right", &self.pad_right());
        ds.field("pad_top", &self.pad_top());
        ds.field("pad_bottom", &self.pad_bottom());
        ds.finish()
    }
}
pub enum SliceAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SliceAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SliceAttrs<'a> {
    type Inner = SliceAttrs<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> SliceAttrs<'a> {
    pub const VT_DIM: flatbuffers::VOffsetT = 4;
    pub const VT_START: flatbuffers::VOffsetT = 6;
    pub const VT_END: flatbuffers::VOffsetT = 8;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SliceAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args SliceAttrsArgs,
    ) -> flatbuffers::WIPOffset<SliceAttrs<'bldr>> {
        let mut builder = SliceAttrsBuilder::new(_fbb);
        builder.add_end(args.end);
        builder.add_start(args.start);
        builder.add_dim(args.dim);
        builder.finish()
    }

    #[inline]
    pub fn dim(&self) -> u32 {
        self._tab.get::<u32>(SliceAttrs::VT_DIM, Some(0)).unwrap()
    }
    #[inline]
    pub fn start(&self) -> u32 {
        self._tab.get::<u32>(SliceAttrs::VT_START, Some(0)).unwrap()
    }
    #[inline]
    pub fn end(&self) -> u32 {
        self._tab.get::<u32>(SliceAttrs::VT_END, Some(0)).unwrap()
    }
}

impl flatbuffers::Verifiable for SliceAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<u32>("dim", Self::VT_DIM, false)?
            .visit_field::<u32>("start", Self::VT_START, false)?
            .visit_field::<u32>("end", Self::VT_END, false)?
            .finish();
        Ok(())
    }
}
pub struct SliceAttrsArgs {
    pub dim: u32,
    pub start: u32,
    pub end: u32,
}
impl<'a> Default for SliceAttrsArgs {
    #[inline]
    fn default() -> Self {
        SliceAttrsArgs {
            dim: 0,
            start: 0,
            end: 0,
        }
    }
}

pub struct SliceAttrsBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SliceAttrsBuilder<'a, 'b> {
    #[inline]
    pub fn add_dim(&mut self, dim: u32) {
        self.fbb_.push_slot::<u32>(SliceAttrs::VT_DIM, dim, 0);
    }
    #[inline]
    pub fn add_start(&mut self, start: u32) {
        self.fbb_.push_slot::<u32>(SliceAttrs::VT_START, start, 0);
    }
    #[inline]
    pub fn add_end(&mut self, end: u32) {
        self.fbb_.push_slot::<u32>(SliceAttrs::VT_END, end, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SliceAttrsBuilder<'a, 'b> {
        let start = _fbb.start_table();
        SliceAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<SliceAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for SliceAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("SliceAttrs");
        ds.field("dim", &self.dim());
        ds.field("start", &self.start());
        ds.field("end", &self.end());
        ds.finish()
    }
}
pub enum OperatorNodeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct OperatorNode<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for OperatorNode<'a> {
    type Inner = OperatorNode<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> OperatorNode<'a> {
    pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
    pub const VT_ATTRS_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_ATTRS: flatbuffers::VOffsetT = 8;
    pub const VT_INPUTS: flatbuffers::VOffsetT = 10;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        OperatorNode { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args OperatorNodeArgs<'args>,
    ) -> flatbuffers::WIPOffset<OperatorNode<'bldr>> {
        let mut builder = OperatorNodeBuilder::new(_fbb);
        if let Some(x) = args.inputs {
            builder.add_inputs(x);
        }
        if let Some(x) = args.attrs {
            builder.add_attrs(x);
        }
        builder.add_attrs_type(args.attrs_type);
        builder.add_type_(args.type_);
        builder.finish()
    }

    #[inline]
    pub fn type_(&self) -> OperatorType {
        self._tab
            .get::<OperatorType>(OperatorNode::VT_TYPE_, Some(OperatorType::Add))
            .unwrap()
    }
    #[inline]
    pub fn attrs_type(&self) -> OperatorAttrs {
        self._tab
            .get::<OperatorAttrs>(OperatorNode::VT_ATTRS_TYPE, Some(OperatorAttrs::NONE))
            .unwrap()
    }
    #[inline]
    pub fn attrs(&self) -> Option<flatbuffers::Table<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                OperatorNode::VT_ATTRS,
                None,
            )
    }
    #[inline]
    pub fn inputs(&self) -> Option<flatbuffers::Vector<'a, u32>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                OperatorNode::VT_INPUTS,
                None,
            )
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_clip_attrs(&self) -> Option<ClipAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::ClipAttrs {
            self.attrs().map(ClipAttrs::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_concat_attrs(&self) -> Option<ConcatAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::ConcatAttrs {
            self.attrs().map(ConcatAttrs::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_conv_2d_attrs(&self) -> Option<Conv2dAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::Conv2dAttrs {
            self.attrs().map(Conv2dAttrs::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_conv_transpose_2d_attrs(&self) -> Option<ConvTranspose2dAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::ConvTranspose2dAttrs {
            self.attrs().map(ConvTranspose2dAttrs::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_max_pool_2d_attrs(&self) -> Option<MaxPool2dAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::MaxPool2dAttrs {
            self.attrs().map(MaxPool2dAttrs::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_pad_2d_attrs(&self) -> Option<Pad2dAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::Pad2dAttrs {
            self.attrs().map(Pad2dAttrs::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_slice_attrs(&self) -> Option<SliceAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::SliceAttrs {
            self.attrs().map(SliceAttrs::init_from_table)
        } else {
            None
        }
    }
}

impl flatbuffers::Verifiable for OperatorNode<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<OperatorType>("type_", Self::VT_TYPE_, false)?
            .visit_union::<OperatorAttrs, _>(
                "attrs_type",
                Self::VT_ATTRS_TYPE,
                "attrs",
                Self::VT_ATTRS,
                false,
                |key, v, pos| match key {
                    OperatorAttrs::ClipAttrs => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<ClipAttrs>>(
                            "OperatorAttrs::ClipAttrs",
                            pos,
                        ),
                    OperatorAttrs::ConcatAttrs => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<ConcatAttrs>>(
                            "OperatorAttrs::ConcatAttrs",
                            pos,
                        ),
                    OperatorAttrs::Conv2dAttrs => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<Conv2dAttrs>>(
                            "OperatorAttrs::Conv2dAttrs",
                            pos,
                        ),
                    OperatorAttrs::ConvTranspose2dAttrs => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<ConvTranspose2dAttrs>>(
                            "OperatorAttrs::ConvTranspose2dAttrs",
                            pos,
                        ),
                    OperatorAttrs::MaxPool2dAttrs => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<MaxPool2dAttrs>>(
                            "OperatorAttrs::MaxPool2dAttrs",
                            pos,
                        ),
                    OperatorAttrs::Pad2dAttrs => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<Pad2dAttrs>>(
                            "OperatorAttrs::Pad2dAttrs",
                            pos,
                        ),
                    OperatorAttrs::SliceAttrs => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<SliceAttrs>>(
                            "OperatorAttrs::SliceAttrs",
                            pos,
                        ),
                    _ => Ok(()),
                },
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "inputs",
                Self::VT_INPUTS,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct OperatorNodeArgs<'a> {
    pub type_: OperatorType,
    pub attrs_type: OperatorAttrs,
    pub attrs: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub inputs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
}
impl<'a> Default for OperatorNodeArgs<'a> {
    #[inline]
    fn default() -> Self {
        OperatorNodeArgs {
            type_: OperatorType::Add,
            attrs_type: OperatorAttrs::NONE,
            attrs: None,
            inputs: None,
        }
    }
}

pub struct OperatorNodeBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> OperatorNodeBuilder<'a, 'b> {
    #[inline]
    pub fn add_type_(&mut self, type_: OperatorType) {
        self.fbb_
            .push_slot::<OperatorType>(OperatorNode::VT_TYPE_, type_, OperatorType::Add);
    }
    #[inline]
    pub fn add_attrs_type(&mut self, attrs_type: OperatorAttrs) {
        self.fbb_.push_slot::<OperatorAttrs>(
            OperatorNode::VT_ATTRS_TYPE,
            attrs_type,
            OperatorAttrs::NONE,
        );
    }
    #[inline]
    pub fn add_attrs(&mut self, attrs: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(OperatorNode::VT_ATTRS, attrs);
    }
    #[inline]
    pub fn add_inputs(&mut self, inputs: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(OperatorNode::VT_INPUTS, inputs);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> OperatorNodeBuilder<'a, 'b> {
        let start = _fbb.start_table();
        OperatorNodeBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<OperatorNode<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for OperatorNode<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("OperatorNode");
        ds.field("type_", &self.type_());
        ds.field("attrs_type", &self.attrs_type());
        match self.attrs_type() {
            OperatorAttrs::ClipAttrs => {
                if let Some(x) = self.attrs_as_clip_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::ConcatAttrs => {
                if let Some(x) = self.attrs_as_concat_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::Conv2dAttrs => {
                if let Some(x) = self.attrs_as_conv_2d_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::ConvTranspose2dAttrs => {
                if let Some(x) = self.attrs_as_conv_transpose_2d_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::MaxPool2dAttrs => {
                if let Some(x) = self.attrs_as_max_pool_2d_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::Pad2dAttrs => {
                if let Some(x) = self.attrs_as_pad_2d_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::SliceAttrs => {
                if let Some(x) = self.attrs_as_slice_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("attrs", &x)
            }
        };
        ds.field("inputs", &self.inputs());
        ds.finish()
    }
}
pub enum FloatDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct FloatData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FloatData<'a> {
    type Inner = FloatData<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> FloatData<'a> {
    pub const VT_DATA: flatbuffers::VOffsetT = 4;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FloatData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FloatDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<FloatData<'bldr>> {
        let mut builder = FloatDataBuilder::new(_fbb);
        if let Some(x) = args.data {
            builder.add_data(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn data(&self) -> flatbuffers::Vector<'a, f32> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(
                FloatData::VT_DATA,
                None,
            )
            .unwrap()
    }
}

impl flatbuffers::Verifiable for FloatData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>(
                "data",
                Self::VT_DATA,
                true,
            )?
            .finish();
        Ok(())
    }
}
pub struct FloatDataArgs<'a> {
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
}
impl<'a> Default for FloatDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        FloatDataArgs {
            data: None, // required field
        }
    }
}

pub struct FloatDataBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FloatDataBuilder<'a, 'b> {
    #[inline]
    pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b, f32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(FloatData::VT_DATA, data);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FloatDataBuilder<'a, 'b> {
        let start = _fbb.start_table();
        FloatDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<FloatData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, FloatData::VT_DATA, "data");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for FloatData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("FloatData");
        ds.field("data", &self.data());
        ds.finish()
    }
}
pub enum IntDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct IntData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IntData<'a> {
    type Inner = IntData<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> IntData<'a> {
    pub const VT_DATA: flatbuffers::VOffsetT = 4;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        IntData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args IntDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<IntData<'bldr>> {
        let mut builder = IntDataBuilder::new(_fbb);
        if let Some(x) = args.data {
            builder.add_data(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn data(&self) -> flatbuffers::Vector<'a, i32> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(
                IntData::VT_DATA,
                None,
            )
            .unwrap()
    }
}

impl flatbuffers::Verifiable for IntData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>(
                "data",
                Self::VT_DATA,
                true,
            )?
            .finish();
        Ok(())
    }
}
pub struct IntDataArgs<'a> {
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
}
impl<'a> Default for IntDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        IntDataArgs {
            data: None, // required field
        }
    }
}

pub struct IntDataBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> IntDataBuilder<'a, 'b> {
    #[inline]
    pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(IntData::VT_DATA, data);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> IntDataBuilder<'a, 'b> {
        let start = _fbb.start_table();
        IntDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<IntData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, IntData::VT_DATA, "data");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for IntData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("IntData");
        ds.field("data", &self.data());
        ds.finish()
    }
}
pub enum ConstantNodeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ConstantNode<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ConstantNode<'a> {
    type Inner = ConstantNode<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> ConstantNode<'a> {
    pub const VT_SHAPE: flatbuffers::VOffsetT = 4;
    pub const VT_DATA_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_DATA: flatbuffers::VOffsetT = 8;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ConstantNode { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ConstantNodeArgs<'args>,
    ) -> flatbuffers::WIPOffset<ConstantNode<'bldr>> {
        let mut builder = ConstantNodeBuilder::new(_fbb);
        if let Some(x) = args.data {
            builder.add_data(x);
        }
        if let Some(x) = args.shape {
            builder.add_shape(x);
        }
        builder.add_data_type(args.data_type);
        builder.finish()
    }

    #[inline]
    pub fn shape(&self) -> flatbuffers::Vector<'a, u32> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                ConstantNode::VT_SHAPE,
                None,
            )
            .unwrap()
    }
    #[inline]
    pub fn data_type(&self) -> ConstantData {
        self._tab
            .get::<ConstantData>(ConstantNode::VT_DATA_TYPE, Some(ConstantData::NONE))
            .unwrap()
    }
    #[inline]
    pub fn data(&self) -> flatbuffers::Table<'a> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                ConstantNode::VT_DATA,
                None,
            )
            .unwrap()
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn data_as_float_data(&self) -> Option<FloatData<'a>> {
        if self.data_type() == ConstantData::FloatData {
            let u = self.data();
            Some(FloatData::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn data_as_int_data(&self) -> Option<IntData<'a>> {
        if self.data_type() == ConstantData::IntData {
            let u = self.data();
            Some(IntData::init_from_table(u))
        } else {
            None
        }
    }
}

impl flatbuffers::Verifiable for ConstantNode<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "shape",
                Self::VT_SHAPE,
                true,
            )?
            .visit_union::<ConstantData, _>(
                "data_type",
                Self::VT_DATA_TYPE,
                "data",
                Self::VT_DATA,
                true,
                |key, v, pos| match key {
                    ConstantData::FloatData => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<FloatData>>(
                            "ConstantData::FloatData",
                            pos,
                        ),
                    ConstantData::IntData => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<IntData>>(
                            "ConstantData::IntData",
                            pos,
                        ),
                    _ => Ok(()),
                },
            )?
            .finish();
        Ok(())
    }
}
pub struct ConstantNodeArgs<'a> {
    pub shape: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub data_type: ConstantData,
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for ConstantNodeArgs<'a> {
    #[inline]
    fn default() -> Self {
        ConstantNodeArgs {
            shape: None, // required field
            data_type: ConstantData::NONE,
            data: None, // required field
        }
    }
}

pub struct ConstantNodeBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ConstantNodeBuilder<'a, 'b> {
    #[inline]
    pub fn add_shape(&mut self, shape: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ConstantNode::VT_SHAPE, shape);
    }
    #[inline]
    pub fn add_data_type(&mut self, data_type: ConstantData) {
        self.fbb_.push_slot::<ConstantData>(
            ConstantNode::VT_DATA_TYPE,
            data_type,
            ConstantData::NONE,
        );
    }
    #[inline]
    pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ConstantNode::VT_DATA, data);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ConstantNodeBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ConstantNodeBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ConstantNode<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, ConstantNode::VT_SHAPE, "shape");
        self.fbb_.required(o, ConstantNode::VT_DATA, "data");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ConstantNode<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ConstantNode");
        ds.field("shape", &self.shape());
        ds.field("data_type", &self.data_type());
        match self.data_type() {
            ConstantData::FloatData => {
                if let Some(x) = self.data_as_float_data() {
                    ds.field("data", &x)
                } else {
                    ds.field(
                        "data",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            ConstantData::IntData => {
                if let Some(x) = self.data_as_int_data() {
                    ds.field("data", &x)
                } else {
                    ds.field(
                        "data",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("data", &x)
            }
        };
        ds.finish()
    }
}
pub enum ValueNodeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ValueNode<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ValueNode<'a> {
    type Inner = ValueNode<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> ValueNode<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ValueNode { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        _args: &'args ValueNodeArgs,
    ) -> flatbuffers::WIPOffset<ValueNode<'bldr>> {
        let mut builder = ValueNodeBuilder::new(_fbb);
        builder.finish()
    }
}

impl flatbuffers::Verifiable for ValueNode<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?.finish();
        Ok(())
    }
}
pub struct ValueNodeArgs {}
impl<'a> Default for ValueNodeArgs {
    #[inline]
    fn default() -> Self {
        ValueNodeArgs {}
    }
}

pub struct ValueNodeBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ValueNodeBuilder<'a, 'b> {
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ValueNodeBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ValueNodeBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ValueNode<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ValueNode<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ValueNode");
        ds.finish()
    }
}
pub enum NodeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Node<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Node<'a> {
    type Inner = Node<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> Node<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_DATA_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_DATA: flatbuffers::VOffsetT = 8;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Node { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args NodeArgs<'args>,
    ) -> flatbuffers::WIPOffset<Node<'bldr>> {
        let mut builder = NodeBuilder::new(_fbb);
        if let Some(x) = args.data {
            builder.add_data(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.add_data_type(args.data_type);
        builder.finish()
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(Node::VT_ID, None)
    }
    #[inline]
    pub fn data_type(&self) -> NodeKind {
        self._tab
            .get::<NodeKind>(Node::VT_DATA_TYPE, Some(NodeKind::NONE))
            .unwrap()
    }
    #[inline]
    pub fn data(&self) -> Option<flatbuffers::Table<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Node::VT_DATA, None)
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn data_as_operator_node(&self) -> Option<OperatorNode<'a>> {
        if self.data_type() == NodeKind::OperatorNode {
            self.data().map(OperatorNode::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn data_as_constant_node(&self) -> Option<ConstantNode<'a>> {
        if self.data_type() == NodeKind::ConstantNode {
            self.data().map(ConstantNode::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn data_as_value_node(&self) -> Option<ValueNode<'a>> {
        if self.data_type() == NodeKind::ValueNode {
            self.data().map(ValueNode::init_from_table)
        } else {
            None
        }
    }
}

impl flatbuffers::Verifiable for Node<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_union::<NodeKind, _>(
                "data_type",
                Self::VT_DATA_TYPE,
                "data",
                Self::VT_DATA,
                false,
                |key, v, pos| match key {
                    NodeKind::OperatorNode => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<OperatorNode>>(
                            "NodeKind::OperatorNode",
                            pos,
                        ),
                    NodeKind::ConstantNode => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<ConstantNode>>(
                            "NodeKind::ConstantNode",
                            pos,
                        ),
                    NodeKind::ValueNode => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<ValueNode>>(
                            "NodeKind::ValueNode",
                            pos,
                        ),
                    _ => Ok(()),
                },
            )?
            .finish();
        Ok(())
    }
}
pub struct NodeArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub data_type: NodeKind,
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for NodeArgs<'a> {
    #[inline]
    fn default() -> Self {
        NodeArgs {
            id: None,
            data_type: NodeKind::NONE,
            data: None,
        }
    }
}

pub struct NodeBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> NodeBuilder<'a, 'b> {
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Node::VT_ID, id);
    }
    #[inline]
    pub fn add_data_type(&mut self, data_type: NodeKind) {
        self.fbb_
            .push_slot::<NodeKind>(Node::VT_DATA_TYPE, data_type, NodeKind::NONE);
    }
    #[inline]
    pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Node::VT_DATA, data);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> NodeBuilder<'a, 'b> {
        let start = _fbb.start_table();
        NodeBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Node<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for Node<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("Node");
        ds.field("id", &self.id());
        ds.field("data_type", &self.data_type());
        match self.data_type() {
            NodeKind::OperatorNode => {
                if let Some(x) = self.data_as_operator_node() {
                    ds.field("data", &x)
                } else {
                    ds.field(
                        "data",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            NodeKind::ConstantNode => {
                if let Some(x) = self.data_as_constant_node() {
                    ds.field("data", &x)
                } else {
                    ds.field(
                        "data",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            NodeKind::ValueNode => {
                if let Some(x) = self.data_as_value_node() {
                    ds.field("data", &x)
                } else {
                    ds.field(
                        "data",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("data", &x)
            }
        };
        ds.finish()
    }
}
pub enum GraphOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Graph<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Graph<'a> {
    type Inner = Graph<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> Graph<'a> {
    pub const VT_NODES: flatbuffers::VOffsetT = 4;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Graph { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GraphArgs<'args>,
    ) -> flatbuffers::WIPOffset<Graph<'bldr>> {
        let mut builder = GraphBuilder::new(_fbb);
        if let Some(x) = args.nodes {
            builder.add_nodes(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn nodes(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Node<'a>>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Node>>,
        >>(Graph::VT_NODES, None)
    }
}

impl flatbuffers::Verifiable for Graph<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Node>>,
            >>("nodes", Self::VT_NODES, false)?
            .finish();
        Ok(())
    }
}
pub struct GraphArgs<'a> {
    pub nodes: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Node<'a>>>>,
    >,
}
impl<'a> Default for GraphArgs<'a> {
    #[inline]
    fn default() -> Self {
        GraphArgs { nodes: None }
    }
}

pub struct GraphBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GraphBuilder<'a, 'b> {
    #[inline]
    pub fn add_nodes(
        &mut self,
        nodes: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Node<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Graph::VT_NODES, nodes);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GraphBuilder<'a, 'b> {
        let start = _fbb.start_table();
        GraphBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Graph<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for Graph<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("Graph");
        ds.field("nodes", &self.nodes());
        ds.finish()
    }
}
pub enum ModelOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Model<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Model<'a> {
    type Inner = Model<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> Model<'a> {
    pub const VT_SCHEMA_VERSION: flatbuffers::VOffsetT = 4;
    pub const VT_GRAPH: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Model { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ModelArgs<'args>,
    ) -> flatbuffers::WIPOffset<Model<'bldr>> {
        let mut builder = ModelBuilder::new(_fbb);
        if let Some(x) = args.graph {
            builder.add_graph(x);
        }
        builder.add_schema_version(args.schema_version);
        builder.finish()
    }

    #[inline]
    pub fn schema_version(&self) -> i32 {
        self._tab
            .get::<i32>(Model::VT_SCHEMA_VERSION, Some(0))
            .unwrap()
    }
    #[inline]
    pub fn graph(&self) -> Graph<'a> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<Graph>>(Model::VT_GRAPH, None)
            .unwrap()
    }
}

impl flatbuffers::Verifiable for Model<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("schema_version", Self::VT_SCHEMA_VERSION, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<Graph>>("graph", Self::VT_GRAPH, true)?
            .finish();
        Ok(())
    }
}
pub struct ModelArgs<'a> {
    pub schema_version: i32,
    pub graph: Option<flatbuffers::WIPOffset<Graph<'a>>>,
}
impl<'a> Default for ModelArgs<'a> {
    #[inline]
    fn default() -> Self {
        ModelArgs {
            schema_version: 0,
            graph: None, // required field
        }
    }
}

pub struct ModelBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ModelBuilder<'a, 'b> {
    #[inline]
    pub fn add_schema_version(&mut self, schema_version: i32) {
        self.fbb_
            .push_slot::<i32>(Model::VT_SCHEMA_VERSION, schema_version, 0);
    }
    #[inline]
    pub fn add_graph(&mut self, graph: flatbuffers::WIPOffset<Graph<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<Graph>>(Model::VT_GRAPH, graph);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ModelBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ModelBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Model<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, Model::VT_GRAPH, "graph");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for Model<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("Model");
        ds.field("schema_version", &self.schema_version());
        ds.field("graph", &self.graph());
        ds.finish()
    }
}
#[inline]
#[deprecated(since = "2.0.0", note = "Deprecated in favor of `root_as...` methods.")]
pub fn get_root_as_model<'a>(buf: &'a [u8]) -> Model<'a> {
    unsafe { flatbuffers::root_unchecked::<Model<'a>>(buf) }
}

#[inline]
#[deprecated(since = "2.0.0", note = "Deprecated in favor of `root_as...` methods.")]
pub fn get_size_prefixed_root_as_model<'a>(buf: &'a [u8]) -> Model<'a> {
    unsafe { flatbuffers::size_prefixed_root_unchecked::<Model<'a>>(buf) }
}

#[inline]
/// Verifies that a buffer of bytes contains a `Model`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_model_unchecked`.
pub fn root_as_model(buf: &[u8]) -> Result<Model, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root::<Model>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Model` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_model_unchecked`.
pub fn size_prefixed_root_as_model(buf: &[u8]) -> Result<Model, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root::<Model>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Model` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_model_unchecked`.
pub fn root_as_model_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<Model<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root_with_opts::<Model<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Model` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_model_unchecked`.
pub fn size_prefixed_root_as_model_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<Model<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root_with_opts::<Model<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Model and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Model`.
pub unsafe fn root_as_model_unchecked(buf: &[u8]) -> Model {
    flatbuffers::root_unchecked::<Model>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Model and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Model`.
pub unsafe fn size_prefixed_root_as_model_unchecked(buf: &[u8]) -> Model {
    flatbuffers::size_prefixed_root_unchecked::<Model>(buf)
}
pub const MODEL_IDENTIFIER: &str = "MODL";

#[inline]
pub fn model_buffer_has_identifier(buf: &[u8]) -> bool {
    flatbuffers::buffer_has_identifier(buf, MODEL_IDENTIFIER, false)
}

#[inline]
pub fn model_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
    flatbuffers::buffer_has_identifier(buf, MODEL_IDENTIFIER, true)
}

pub const MODEL_EXTENSION: &str = "model";

#[inline]
pub fn finish_model_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<Model<'a>>,
) {
    fbb.finish(root, Some(MODEL_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_model_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<Model<'a>>,
) {
    fbb.finish_size_prefixed(root, Some(MODEL_IDENTIFIER));
}
