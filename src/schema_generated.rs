#![allow(clippy::all)]
// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_OPERATOR_TYPE: i8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_OPERATOR_TYPE: i8 = 63;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_OPERATOR_TYPE: [OperatorType; 64] = [
    OperatorType::Add,
    OperatorType::ArgMin,
    OperatorType::ArgMax,
    OperatorType::AveragePool,
    OperatorType::BatchNormalization,
    OperatorType::Cast,
    OperatorType::Clip,
    OperatorType::Concat,
    OperatorType::ConstantOfShape,
    OperatorType::Conv,
    OperatorType::ConvTranspose,
    OperatorType::Cos,
    OperatorType::CumSum,
    OperatorType::Div,
    OperatorType::Equal,
    OperatorType::Erf,
    OperatorType::Expand,
    OperatorType::Flatten,
    OperatorType::Gather,
    OperatorType::Gemm,
    OperatorType::GlobalAveragePool,
    OperatorType::Greater,
    OperatorType::GRU,
    OperatorType::Identity,
    OperatorType::LeakyRelu,
    OperatorType::Less,
    OperatorType::LessOrEqual,
    OperatorType::Log,
    OperatorType::LogSoftmax,
    OperatorType::LSTM,
    OperatorType::MatMul,
    OperatorType::MaxPool,
    OperatorType::Mod,
    OperatorType::Mul,
    OperatorType::Pad,
    OperatorType::Pow,
    OperatorType::Range,
    OperatorType::ReduceMean,
    OperatorType::ReduceL2,
    OperatorType::Relu,
    OperatorType::Reshape,
    OperatorType::Resize,
    OperatorType::Shape,
    OperatorType::Sigmoid,
    OperatorType::Sin,
    OperatorType::Slice,
    OperatorType::Split,
    OperatorType::Sqrt,
    OperatorType::Squeeze,
    OperatorType::Softmax,
    OperatorType::Sub,
    OperatorType::Tanh,
    OperatorType::Transpose,
    OperatorType::Unsqueeze,
    OperatorType::Where,
    OperatorType::ReduceProd,
    OperatorType::ReduceSum,
    OperatorType::ReduceMin,
    OperatorType::ReduceMax,
    OperatorType::NonZero,
    OperatorType::ScatterElements,
    OperatorType::Tile,
    OperatorType::Not,
    OperatorType::Abs,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct OperatorType(pub i8);
#[allow(non_upper_case_globals)]
impl OperatorType {
    pub const Add: Self = Self(0);
    pub const ArgMin: Self = Self(1);
    pub const ArgMax: Self = Self(2);
    pub const AveragePool: Self = Self(3);
    pub const BatchNormalization: Self = Self(4);
    pub const Cast: Self = Self(5);
    pub const Clip: Self = Self(6);
    pub const Concat: Self = Self(7);
    pub const ConstantOfShape: Self = Self(8);
    pub const Conv: Self = Self(9);
    pub const ConvTranspose: Self = Self(10);
    pub const Cos: Self = Self(11);
    pub const CumSum: Self = Self(12);
    pub const Div: Self = Self(13);
    pub const Equal: Self = Self(14);
    pub const Erf: Self = Self(15);
    pub const Expand: Self = Self(16);
    pub const Flatten: Self = Self(17);
    pub const Gather: Self = Self(18);
    pub const Gemm: Self = Self(19);
    pub const GlobalAveragePool: Self = Self(20);
    pub const Greater: Self = Self(21);
    pub const GRU: Self = Self(22);
    pub const Identity: Self = Self(23);
    pub const LeakyRelu: Self = Self(24);
    pub const Less: Self = Self(25);
    pub const LessOrEqual: Self = Self(26);
    pub const Log: Self = Self(27);
    pub const LogSoftmax: Self = Self(28);
    pub const LSTM: Self = Self(29);
    pub const MatMul: Self = Self(30);
    pub const MaxPool: Self = Self(31);
    pub const Mod: Self = Self(32);
    pub const Mul: Self = Self(33);
    pub const Pad: Self = Self(34);
    pub const Pow: Self = Self(35);
    pub const Range: Self = Self(36);
    pub const ReduceMean: Self = Self(37);
    pub const ReduceL2: Self = Self(38);
    pub const Relu: Self = Self(39);
    pub const Reshape: Self = Self(40);
    pub const Resize: Self = Self(41);
    pub const Shape: Self = Self(42);
    pub const Sigmoid: Self = Self(43);
    pub const Sin: Self = Self(44);
    pub const Slice: Self = Self(45);
    pub const Split: Self = Self(46);
    pub const Sqrt: Self = Self(47);
    pub const Squeeze: Self = Self(48);
    pub const Softmax: Self = Self(49);
    pub const Sub: Self = Self(50);
    pub const Tanh: Self = Self(51);
    pub const Transpose: Self = Self(52);
    pub const Unsqueeze: Self = Self(53);
    pub const Where: Self = Self(54);
    pub const ReduceProd: Self = Self(55);
    pub const ReduceSum: Self = Self(56);
    pub const ReduceMin: Self = Self(57);
    pub const ReduceMax: Self = Self(58);
    pub const NonZero: Self = Self(59);
    pub const ScatterElements: Self = Self(60);
    pub const Tile: Self = Self(61);
    pub const Not: Self = Self(62);
    pub const Abs: Self = Self(63);

    pub const ENUM_MIN: i8 = 0;
    pub const ENUM_MAX: i8 = 63;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::Add,
        Self::ArgMin,
        Self::ArgMax,
        Self::AveragePool,
        Self::BatchNormalization,
        Self::Cast,
        Self::Clip,
        Self::Concat,
        Self::ConstantOfShape,
        Self::Conv,
        Self::ConvTranspose,
        Self::Cos,
        Self::CumSum,
        Self::Div,
        Self::Equal,
        Self::Erf,
        Self::Expand,
        Self::Flatten,
        Self::Gather,
        Self::Gemm,
        Self::GlobalAveragePool,
        Self::Greater,
        Self::GRU,
        Self::Identity,
        Self::LeakyRelu,
        Self::Less,
        Self::LessOrEqual,
        Self::Log,
        Self::LogSoftmax,
        Self::LSTM,
        Self::MatMul,
        Self::MaxPool,
        Self::Mod,
        Self::Mul,
        Self::Pad,
        Self::Pow,
        Self::Range,
        Self::ReduceMean,
        Self::ReduceL2,
        Self::Relu,
        Self::Reshape,
        Self::Resize,
        Self::Shape,
        Self::Sigmoid,
        Self::Sin,
        Self::Slice,
        Self::Split,
        Self::Sqrt,
        Self::Squeeze,
        Self::Softmax,
        Self::Sub,
        Self::Tanh,
        Self::Transpose,
        Self::Unsqueeze,
        Self::Where,
        Self::ReduceProd,
        Self::ReduceSum,
        Self::ReduceMin,
        Self::ReduceMax,
        Self::NonZero,
        Self::ScatterElements,
        Self::Tile,
        Self::Not,
        Self::Abs,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::Add => Some("Add"),
            Self::ArgMin => Some("ArgMin"),
            Self::ArgMax => Some("ArgMax"),
            Self::AveragePool => Some("AveragePool"),
            Self::BatchNormalization => Some("BatchNormalization"),
            Self::Cast => Some("Cast"),
            Self::Clip => Some("Clip"),
            Self::Concat => Some("Concat"),
            Self::ConstantOfShape => Some("ConstantOfShape"),
            Self::Conv => Some("Conv"),
            Self::ConvTranspose => Some("ConvTranspose"),
            Self::Cos => Some("Cos"),
            Self::CumSum => Some("CumSum"),
            Self::Div => Some("Div"),
            Self::Equal => Some("Equal"),
            Self::Erf => Some("Erf"),
            Self::Expand => Some("Expand"),
            Self::Flatten => Some("Flatten"),
            Self::Gather => Some("Gather"),
            Self::Gemm => Some("Gemm"),
            Self::GlobalAveragePool => Some("GlobalAveragePool"),
            Self::Greater => Some("Greater"),
            Self::GRU => Some("GRU"),
            Self::Identity => Some("Identity"),
            Self::LeakyRelu => Some("LeakyRelu"),
            Self::Less => Some("Less"),
            Self::LessOrEqual => Some("LessOrEqual"),
            Self::Log => Some("Log"),
            Self::LogSoftmax => Some("LogSoftmax"),
            Self::LSTM => Some("LSTM"),
            Self::MatMul => Some("MatMul"),
            Self::MaxPool => Some("MaxPool"),
            Self::Mod => Some("Mod"),
            Self::Mul => Some("Mul"),
            Self::Pad => Some("Pad"),
            Self::Pow => Some("Pow"),
            Self::Range => Some("Range"),
            Self::ReduceMean => Some("ReduceMean"),
            Self::ReduceL2 => Some("ReduceL2"),
            Self::Relu => Some("Relu"),
            Self::Reshape => Some("Reshape"),
            Self::Resize => Some("Resize"),
            Self::Shape => Some("Shape"),
            Self::Sigmoid => Some("Sigmoid"),
            Self::Sin => Some("Sin"),
            Self::Slice => Some("Slice"),
            Self::Split => Some("Split"),
            Self::Sqrt => Some("Sqrt"),
            Self::Squeeze => Some("Squeeze"),
            Self::Softmax => Some("Softmax"),
            Self::Sub => Some("Sub"),
            Self::Tanh => Some("Tanh"),
            Self::Transpose => Some("Transpose"),
            Self::Unsqueeze => Some("Unsqueeze"),
            Self::Where => Some("Where"),
            Self::ReduceProd => Some("ReduceProd"),
            Self::ReduceSum => Some("ReduceSum"),
            Self::ReduceMin => Some("ReduceMin"),
            Self::ReduceMax => Some("ReduceMax"),
            Self::NonZero => Some("NonZero"),
            Self::ScatterElements => Some("ScatterElements"),
            Self::Tile => Some("Tile"),
            Self::Not => Some("Not"),
            Self::Abs => Some("Abs"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for OperatorType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for OperatorType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for OperatorType {
    type Output = OperatorType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for OperatorType {
    type Scalar = i8;
    #[inline]
    fn to_little_endian(self) -> i8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i8) -> Self {
        let b = i8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for OperatorType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for OperatorType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_RNNDIRECTION: i8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_RNNDIRECTION: i8 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_RNNDIRECTION: [RNNDirection; 3] = [
    RNNDirection::Forwards,
    RNNDirection::Reverse,
    RNNDirection::Bidirectional,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct RNNDirection(pub i8);
#[allow(non_upper_case_globals)]
impl RNNDirection {
    pub const Forwards: Self = Self(0);
    pub const Reverse: Self = Self(1);
    pub const Bidirectional: Self = Self(2);

    pub const ENUM_MIN: i8 = 0;
    pub const ENUM_MAX: i8 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[Self::Forwards, Self::Reverse, Self::Bidirectional];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::Forwards => Some("Forwards"),
            Self::Reverse => Some("Reverse"),
            Self::Bidirectional => Some("Bidirectional"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for RNNDirection {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for RNNDirection {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for RNNDirection {
    type Output = RNNDirection;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for RNNDirection {
    type Scalar = i8;
    #[inline]
    fn to_little_endian(self) -> i8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i8) -> Self {
        let b = i8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for RNNDirection {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for RNNDirection {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_PAD_MODE: i8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_PAD_MODE: i8 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_PAD_MODE: [PadMode; 2] = [PadMode::Same, PadMode::Fixed];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct PadMode(pub i8);
#[allow(non_upper_case_globals)]
impl PadMode {
    pub const Same: Self = Self(0);
    pub const Fixed: Self = Self(1);

    pub const ENUM_MIN: i8 = 0;
    pub const ENUM_MAX: i8 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::Same, Self::Fixed];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::Same => Some("Same"),
            Self::Fixed => Some("Fixed"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for PadMode {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for PadMode {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for PadMode {
    type Output = PadMode;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for PadMode {
    type Scalar = i8;
    #[inline]
    fn to_little_endian(self) -> i8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i8) -> Self {
        let b = i8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for PadMode {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for PadMode {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_DATA_TYPE: i8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_DATA_TYPE: i8 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DATA_TYPE: [DataType; 2] = [DataType::Int32, DataType::Float];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct DataType(pub i8);
#[allow(non_upper_case_globals)]
impl DataType {
    pub const Int32: Self = Self(0);
    pub const Float: Self = Self(1);

    pub const ENUM_MIN: i8 = 0;
    pub const ENUM_MAX: i8 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::Int32, Self::Float];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::Int32 => Some("Int32"),
            Self::Float => Some("Float"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for DataType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for DataType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for DataType {
    type Output = DataType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for DataType {
    type Scalar = i8;
    #[inline]
    fn to_little_endian(self) -> i8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i8) -> Self {
        let b = i8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for DataType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for DataType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_COORD_TRANSFORM_MODE: i8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_COORD_TRANSFORM_MODE: i8 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_COORD_TRANSFORM_MODE: [CoordTransformMode; 2] = [
    CoordTransformMode::HalfPixel,
    CoordTransformMode::Asymmetric,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct CoordTransformMode(pub i8);
#[allow(non_upper_case_globals)]
impl CoordTransformMode {
    pub const HalfPixel: Self = Self(0);
    pub const Asymmetric: Self = Self(1);

    pub const ENUM_MIN: i8 = 0;
    pub const ENUM_MAX: i8 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::HalfPixel, Self::Asymmetric];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::HalfPixel => Some("HalfPixel"),
            Self::Asymmetric => Some("Asymmetric"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for CoordTransformMode {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for CoordTransformMode {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for CoordTransformMode {
    type Output = CoordTransformMode;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for CoordTransformMode {
    type Scalar = i8;
    #[inline]
    fn to_little_endian(self) -> i8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i8) -> Self {
        let b = i8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for CoordTransformMode {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for CoordTransformMode {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_NEAREST_MODE: i8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_NEAREST_MODE: i8 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_NEAREST_MODE: [NearestMode; 4] = [
    NearestMode::Floor,
    NearestMode::Ceil,
    NearestMode::RoundPreferFloor,
    NearestMode::RoundPreferCeil,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct NearestMode(pub i8);
#[allow(non_upper_case_globals)]
impl NearestMode {
    pub const Floor: Self = Self(0);
    pub const Ceil: Self = Self(1);
    pub const RoundPreferFloor: Self = Self(2);
    pub const RoundPreferCeil: Self = Self(3);

    pub const ENUM_MIN: i8 = 0;
    pub const ENUM_MAX: i8 = 3;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::Floor,
        Self::Ceil,
        Self::RoundPreferFloor,
        Self::RoundPreferCeil,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::Floor => Some("Floor"),
            Self::Ceil => Some("Ceil"),
            Self::RoundPreferFloor => Some("RoundPreferFloor"),
            Self::RoundPreferCeil => Some("RoundPreferCeil"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for NearestMode {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for NearestMode {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for NearestMode {
    type Output = NearestMode;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for NearestMode {
    type Scalar = i8;
    #[inline]
    fn to_little_endian(self) -> i8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i8) -> Self {
        let b = i8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for NearestMode {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for NearestMode {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_RESIZE_MODE: i8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_RESIZE_MODE: i8 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_RESIZE_MODE: [ResizeMode; 2] = [ResizeMode::Nearest, ResizeMode::Linear];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ResizeMode(pub i8);
#[allow(non_upper_case_globals)]
impl ResizeMode {
    pub const Nearest: Self = Self(0);
    pub const Linear: Self = Self(1);

    pub const ENUM_MIN: i8 = 0;
    pub const ENUM_MAX: i8 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::Nearest, Self::Linear];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::Nearest => Some("Nearest"),
            Self::Linear => Some("Linear"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for ResizeMode {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for ResizeMode {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for ResizeMode {
    type Output = ResizeMode;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ResizeMode {
    type Scalar = i8;
    #[inline]
    fn to_little_endian(self) -> i8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i8) -> Self {
        let b = i8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for ResizeMode {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for ResizeMode {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_OPERATOR_ATTRS: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_OPERATOR_ATTRS: u8 = 23;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_OPERATOR_ATTRS: [OperatorAttrs; 24] = [
    OperatorAttrs::NONE,
    OperatorAttrs::ArgMaxAttrs,
    OperatorAttrs::AveragePoolAttrs,
    OperatorAttrs::BatchNormalizationAttrs,
    OperatorAttrs::CastAttrs,
    OperatorAttrs::ConcatAttrs,
    OperatorAttrs::ConstantOfShapeAttrs,
    OperatorAttrs::ConvAttrs,
    OperatorAttrs::ConvTransposeAttrs,
    OperatorAttrs::FlattenAttrs,
    OperatorAttrs::GatherAttrs,
    OperatorAttrs::GemmAttrs,
    OperatorAttrs::GRUAttrs,
    OperatorAttrs::LeakyReluAttrs,
    OperatorAttrs::LSTMAttrs,
    OperatorAttrs::MaxPoolAttrs,
    OperatorAttrs::ReduceMeanAttrs,
    OperatorAttrs::ReshapeAttrs,
    OperatorAttrs::ResizeAttrs,
    OperatorAttrs::SplitAttrs,
    OperatorAttrs::SoftmaxAttrs,
    OperatorAttrs::TransposeAttrs,
    OperatorAttrs::ModAttrs,
    OperatorAttrs::ScatterElementsAttrs,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct OperatorAttrs(pub u8);
#[allow(non_upper_case_globals)]
impl OperatorAttrs {
    pub const NONE: Self = Self(0);
    pub const ArgMaxAttrs: Self = Self(1);
    pub const AveragePoolAttrs: Self = Self(2);
    pub const BatchNormalizationAttrs: Self = Self(3);
    pub const CastAttrs: Self = Self(4);
    pub const ConcatAttrs: Self = Self(5);
    pub const ConstantOfShapeAttrs: Self = Self(6);
    pub const ConvAttrs: Self = Self(7);
    pub const ConvTransposeAttrs: Self = Self(8);
    pub const FlattenAttrs: Self = Self(9);
    pub const GatherAttrs: Self = Self(10);
    pub const GemmAttrs: Self = Self(11);
    pub const GRUAttrs: Self = Self(12);
    pub const LeakyReluAttrs: Self = Self(13);
    pub const LSTMAttrs: Self = Self(14);
    pub const MaxPoolAttrs: Self = Self(15);
    pub const ReduceMeanAttrs: Self = Self(16);
    pub const ReshapeAttrs: Self = Self(17);
    pub const ResizeAttrs: Self = Self(18);
    pub const SplitAttrs: Self = Self(19);
    pub const SoftmaxAttrs: Self = Self(20);
    pub const TransposeAttrs: Self = Self(21);
    pub const ModAttrs: Self = Self(22);
    pub const ScatterElementsAttrs: Self = Self(23);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 23;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::ArgMaxAttrs,
        Self::AveragePoolAttrs,
        Self::BatchNormalizationAttrs,
        Self::CastAttrs,
        Self::ConcatAttrs,
        Self::ConstantOfShapeAttrs,
        Self::ConvAttrs,
        Self::ConvTransposeAttrs,
        Self::FlattenAttrs,
        Self::GatherAttrs,
        Self::GemmAttrs,
        Self::GRUAttrs,
        Self::LeakyReluAttrs,
        Self::LSTMAttrs,
        Self::MaxPoolAttrs,
        Self::ReduceMeanAttrs,
        Self::ReshapeAttrs,
        Self::ResizeAttrs,
        Self::SplitAttrs,
        Self::SoftmaxAttrs,
        Self::TransposeAttrs,
        Self::ModAttrs,
        Self::ScatterElementsAttrs,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::ArgMaxAttrs => Some("ArgMaxAttrs"),
            Self::AveragePoolAttrs => Some("AveragePoolAttrs"),
            Self::BatchNormalizationAttrs => Some("BatchNormalizationAttrs"),
            Self::CastAttrs => Some("CastAttrs"),
            Self::ConcatAttrs => Some("ConcatAttrs"),
            Self::ConstantOfShapeAttrs => Some("ConstantOfShapeAttrs"),
            Self::ConvAttrs => Some("ConvAttrs"),
            Self::ConvTransposeAttrs => Some("ConvTransposeAttrs"),
            Self::FlattenAttrs => Some("FlattenAttrs"),
            Self::GatherAttrs => Some("GatherAttrs"),
            Self::GemmAttrs => Some("GemmAttrs"),
            Self::GRUAttrs => Some("GRUAttrs"),
            Self::LeakyReluAttrs => Some("LeakyReluAttrs"),
            Self::LSTMAttrs => Some("LSTMAttrs"),
            Self::MaxPoolAttrs => Some("MaxPoolAttrs"),
            Self::ReduceMeanAttrs => Some("ReduceMeanAttrs"),
            Self::ReshapeAttrs => Some("ReshapeAttrs"),
            Self::ResizeAttrs => Some("ResizeAttrs"),
            Self::SplitAttrs => Some("SplitAttrs"),
            Self::SoftmaxAttrs => Some("SoftmaxAttrs"),
            Self::TransposeAttrs => Some("TransposeAttrs"),
            Self::ModAttrs => Some("ModAttrs"),
            Self::ScatterElementsAttrs => Some("ScatterElementsAttrs"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for OperatorAttrs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for OperatorAttrs {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for OperatorAttrs {
    type Output = OperatorAttrs;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for OperatorAttrs {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for OperatorAttrs {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for OperatorAttrs {}
pub struct OperatorAttrsUnionTableOffset {}

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_SCALAR: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_SCALAR: u8 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SCALAR: [Scalar; 3] = [Scalar::NONE, Scalar::IntScalar, Scalar::FloatScalar];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Scalar(pub u8);
#[allow(non_upper_case_globals)]
impl Scalar {
    pub const NONE: Self = Self(0);
    pub const IntScalar: Self = Self(1);
    pub const FloatScalar: Self = Self(2);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::IntScalar, Self::FloatScalar];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::IntScalar => Some("IntScalar"),
            Self::FloatScalar => Some("FloatScalar"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for Scalar {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for Scalar {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for Scalar {
    type Output = Scalar;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Scalar {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for Scalar {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for Scalar {}
pub struct ScalarUnionTableOffset {}

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_SCATTER_REDUCTION: i8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_SCATTER_REDUCTION: i8 = 4;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SCATTER_REDUCTION: [ScatterReduction; 5] = [
    ScatterReduction::None,
    ScatterReduction::Add,
    ScatterReduction::Mul,
    ScatterReduction::Min,
    ScatterReduction::Max,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ScatterReduction(pub i8);
#[allow(non_upper_case_globals)]
impl ScatterReduction {
    pub const None: Self = Self(0);
    pub const Add: Self = Self(1);
    pub const Mul: Self = Self(2);
    pub const Min: Self = Self(3);
    pub const Max: Self = Self(4);

    pub const ENUM_MIN: i8 = 0;
    pub const ENUM_MAX: i8 = 4;
    pub const ENUM_VALUES: &'static [Self] =
        &[Self::None, Self::Add, Self::Mul, Self::Min, Self::Max];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::None => Some("None"),
            Self::Add => Some("Add"),
            Self::Mul => Some("Mul"),
            Self::Min => Some("Min"),
            Self::Max => Some("Max"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for ScatterReduction {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for ScatterReduction {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for ScatterReduction {
    type Output = ScatterReduction;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ScatterReduction {
    type Scalar = i8;
    #[inline]
    fn to_little_endian(self) -> i8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i8) -> Self {
        let b = i8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for ScatterReduction {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for ScatterReduction {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_NODE_KIND: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_NODE_KIND: u8 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_NODE_KIND: [NodeKind; 4] = [
    NodeKind::NONE,
    NodeKind::OperatorNode,
    NodeKind::ConstantNode,
    NodeKind::ValueNode,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct NodeKind(pub u8);
#[allow(non_upper_case_globals)]
impl NodeKind {
    pub const NONE: Self = Self(0);
    pub const OperatorNode: Self = Self(1);
    pub const ConstantNode: Self = Self(2);
    pub const ValueNode: Self = Self(3);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 3;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::OperatorNode,
        Self::ConstantNode,
        Self::ValueNode,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::OperatorNode => Some("OperatorNode"),
            Self::ConstantNode => Some("ConstantNode"),
            Self::ValueNode => Some("ValueNode"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for NodeKind {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for NodeKind {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for NodeKind {
    type Output = NodeKind;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for NodeKind {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for NodeKind {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for NodeKind {}
pub struct NodeKindUnionTableOffset {}

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_CONSTANT_DATA: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_CONSTANT_DATA: u8 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_CONSTANT_DATA: [ConstantData; 3] = [
    ConstantData::NONE,
    ConstantData::FloatData,
    ConstantData::IntData,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ConstantData(pub u8);
#[allow(non_upper_case_globals)]
impl ConstantData {
    pub const NONE: Self = Self(0);
    pub const FloatData: Self = Self(1);
    pub const IntData: Self = Self(2);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::FloatData, Self::IntData];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::FloatData => Some("FloatData"),
            Self::IntData => Some("IntData"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for ConstantData {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for ConstantData {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for ConstantData {
    type Output = ConstantData;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ConstantData {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for ConstantData {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for ConstantData {}
pub struct ConstantDataUnionTableOffset {}

pub enum ArgMaxAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ArgMaxAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ArgMaxAttrs<'a> {
    type Inner = ArgMaxAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> ArgMaxAttrs<'a> {
    pub const VT_AXIS: flatbuffers::VOffsetT = 4;
    pub const VT_KEEP_DIMS: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ArgMaxAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ArgMaxAttrsArgs,
    ) -> flatbuffers::WIPOffset<ArgMaxAttrs<'bldr>> {
        let mut builder = ArgMaxAttrsBuilder::new(_fbb);
        builder.add_axis(args.axis);
        builder.add_keep_dims(args.keep_dims);
        builder.finish()
    }

    #[inline]
    pub fn axis(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<i32>(ArgMaxAttrs::VT_AXIS, Some(0)).unwrap() }
    }
    #[inline]
    pub fn keep_dims(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(ArgMaxAttrs::VT_KEEP_DIMS, Some(false))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for ArgMaxAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("axis", Self::VT_AXIS, false)?
            .visit_field::<bool>("keep_dims", Self::VT_KEEP_DIMS, false)?
            .finish();
        Ok(())
    }
}
pub struct ArgMaxAttrsArgs {
    pub axis: i32,
    pub keep_dims: bool,
}
impl<'a> Default for ArgMaxAttrsArgs {
    #[inline]
    fn default() -> Self {
        ArgMaxAttrsArgs {
            axis: 0,
            keep_dims: false,
        }
    }
}

pub struct ArgMaxAttrsBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ArgMaxAttrsBuilder<'a, 'b> {
    #[inline]
    pub fn add_axis(&mut self, axis: i32) {
        self.fbb_.push_slot::<i32>(ArgMaxAttrs::VT_AXIS, axis, 0);
    }
    #[inline]
    pub fn add_keep_dims(&mut self, keep_dims: bool) {
        self.fbb_
            .push_slot::<bool>(ArgMaxAttrs::VT_KEEP_DIMS, keep_dims, false);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ArgMaxAttrsBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ArgMaxAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ArgMaxAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ArgMaxAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ArgMaxAttrs");
        ds.field("axis", &self.axis());
        ds.field("keep_dims", &self.keep_dims());
        ds.finish()
    }
}
pub enum AveragePoolAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AveragePoolAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AveragePoolAttrs<'a> {
    type Inner = AveragePoolAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> AveragePoolAttrs<'a> {
    pub const VT_KERNEL_SIZE: flatbuffers::VOffsetT = 4;
    pub const VT_PAD_MODE: flatbuffers::VOffsetT = 6;
    pub const VT_PADS: flatbuffers::VOffsetT = 8;
    pub const VT_STRIDES: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        AveragePoolAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args AveragePoolAttrsArgs<'args>,
    ) -> flatbuffers::WIPOffset<AveragePoolAttrs<'bldr>> {
        let mut builder = AveragePoolAttrsBuilder::new(_fbb);
        if let Some(x) = args.strides {
            builder.add_strides(x);
        }
        if let Some(x) = args.pads {
            builder.add_pads(x);
        }
        if let Some(x) = args.kernel_size {
            builder.add_kernel_size(x);
        }
        builder.add_pad_mode(args.pad_mode);
        builder.finish()
    }

    #[inline]
    pub fn kernel_size(&self) -> flatbuffers::Vector<'a, u32> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    AveragePoolAttrs::VT_KERNEL_SIZE,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn pad_mode(&self) -> PadMode {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<PadMode>(AveragePoolAttrs::VT_PAD_MODE, Some(PadMode::Same))
                .unwrap()
        }
    }
    #[inline]
    pub fn pads(&self) -> Option<flatbuffers::Vector<'a, u32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    AveragePoolAttrs::VT_PADS,
                    None,
                )
        }
    }
    #[inline]
    pub fn strides(&self) -> Option<flatbuffers::Vector<'a, u32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    AveragePoolAttrs::VT_STRIDES,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for AveragePoolAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "kernel_size",
                Self::VT_KERNEL_SIZE,
                true,
            )?
            .visit_field::<PadMode>("pad_mode", Self::VT_PAD_MODE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "pads",
                Self::VT_PADS,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "strides",
                Self::VT_STRIDES,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct AveragePoolAttrsArgs<'a> {
    pub kernel_size: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub pad_mode: PadMode,
    pub pads: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub strides: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
}
impl<'a> Default for AveragePoolAttrsArgs<'a> {
    #[inline]
    fn default() -> Self {
        AveragePoolAttrsArgs {
            kernel_size: None, // required field
            pad_mode: PadMode::Same,
            pads: None,
            strides: None,
        }
    }
}

pub struct AveragePoolAttrsBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AveragePoolAttrsBuilder<'a, 'b> {
    #[inline]
    pub fn add_kernel_size(
        &mut self,
        kernel_size: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            AveragePoolAttrs::VT_KERNEL_SIZE,
            kernel_size,
        );
    }
    #[inline]
    pub fn add_pad_mode(&mut self, pad_mode: PadMode) {
        self.fbb_
            .push_slot::<PadMode>(AveragePoolAttrs::VT_PAD_MODE, pad_mode, PadMode::Same);
    }
    #[inline]
    pub fn add_pads(&mut self, pads: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(AveragePoolAttrs::VT_PADS, pads);
    }
    #[inline]
    pub fn add_strides(&mut self, strides: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(AveragePoolAttrs::VT_STRIDES, strides);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> AveragePoolAttrsBuilder<'a, 'b> {
        let start = _fbb.start_table();
        AveragePoolAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<AveragePoolAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, AveragePoolAttrs::VT_KERNEL_SIZE, "kernel_size");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for AveragePoolAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("AveragePoolAttrs");
        ds.field("kernel_size", &self.kernel_size());
        ds.field("pad_mode", &self.pad_mode());
        ds.field("pads", &self.pads());
        ds.field("strides", &self.strides());
        ds.finish()
    }
}
pub enum BatchNormalizationAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BatchNormalizationAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BatchNormalizationAttrs<'a> {
    type Inner = BatchNormalizationAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> BatchNormalizationAttrs<'a> {
    pub const VT_EPSILON: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        BatchNormalizationAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args BatchNormalizationAttrsArgs,
    ) -> flatbuffers::WIPOffset<BatchNormalizationAttrs<'bldr>> {
        let mut builder = BatchNormalizationAttrsBuilder::new(_fbb);
        builder.add_epsilon(args.epsilon);
        builder.finish()
    }

    #[inline]
    pub fn epsilon(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(BatchNormalizationAttrs::VT_EPSILON, Some(0.0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for BatchNormalizationAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<f32>("epsilon", Self::VT_EPSILON, false)?
            .finish();
        Ok(())
    }
}
pub struct BatchNormalizationAttrsArgs {
    pub epsilon: f32,
}
impl<'a> Default for BatchNormalizationAttrsArgs {
    #[inline]
    fn default() -> Self {
        BatchNormalizationAttrsArgs { epsilon: 0.0 }
    }
}

pub struct BatchNormalizationAttrsBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BatchNormalizationAttrsBuilder<'a, 'b> {
    #[inline]
    pub fn add_epsilon(&mut self, epsilon: f32) {
        self.fbb_
            .push_slot::<f32>(BatchNormalizationAttrs::VT_EPSILON, epsilon, 0.0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> BatchNormalizationAttrsBuilder<'a, 'b> {
        let start = _fbb.start_table();
        BatchNormalizationAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<BatchNormalizationAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for BatchNormalizationAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("BatchNormalizationAttrs");
        ds.field("epsilon", &self.epsilon());
        ds.finish()
    }
}
pub enum CastAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CastAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CastAttrs<'a> {
    type Inner = CastAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> CastAttrs<'a> {
    pub const VT_TO: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        CastAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args CastAttrsArgs,
    ) -> flatbuffers::WIPOffset<CastAttrs<'bldr>> {
        let mut builder = CastAttrsBuilder::new(_fbb);
        builder.add_to(args.to);
        builder.finish()
    }

    #[inline]
    pub fn to(&self) -> DataType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<DataType>(CastAttrs::VT_TO, Some(DataType::Int32))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for CastAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<DataType>("to", Self::VT_TO, false)?
            .finish();
        Ok(())
    }
}
pub struct CastAttrsArgs {
    pub to: DataType,
}
impl<'a> Default for CastAttrsArgs {
    #[inline]
    fn default() -> Self {
        CastAttrsArgs {
            to: DataType::Int32,
        }
    }
}

pub struct CastAttrsBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CastAttrsBuilder<'a, 'b> {
    #[inline]
    pub fn add_to(&mut self, to: DataType) {
        self.fbb_
            .push_slot::<DataType>(CastAttrs::VT_TO, to, DataType::Int32);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CastAttrsBuilder<'a, 'b> {
        let start = _fbb.start_table();
        CastAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<CastAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for CastAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("CastAttrs");
        ds.field("to", &self.to());
        ds.finish()
    }
}
pub enum ConcatAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ConcatAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ConcatAttrs<'a> {
    type Inner = ConcatAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> ConcatAttrs<'a> {
    pub const VT_DIM: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ConcatAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ConcatAttrsArgs,
    ) -> flatbuffers::WIPOffset<ConcatAttrs<'bldr>> {
        let mut builder = ConcatAttrsBuilder::new(_fbb);
        builder.add_dim(args.dim);
        builder.finish()
    }

    #[inline]
    pub fn dim(&self) -> u32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<u32>(ConcatAttrs::VT_DIM, Some(0)).unwrap() }
    }
}

impl flatbuffers::Verifiable for ConcatAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<u32>("dim", Self::VT_DIM, false)?
            .finish();
        Ok(())
    }
}
pub struct ConcatAttrsArgs {
    pub dim: u32,
}
impl<'a> Default for ConcatAttrsArgs {
    #[inline]
    fn default() -> Self {
        ConcatAttrsArgs { dim: 0 }
    }
}

pub struct ConcatAttrsBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ConcatAttrsBuilder<'a, 'b> {
    #[inline]
    pub fn add_dim(&mut self, dim: u32) {
        self.fbb_.push_slot::<u32>(ConcatAttrs::VT_DIM, dim, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ConcatAttrsBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ConcatAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ConcatAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ConcatAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ConcatAttrs");
        ds.field("dim", &self.dim());
        ds.finish()
    }
}
pub enum IntScalarOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct IntScalar<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IntScalar<'a> {
    type Inner = IntScalar<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> IntScalar<'a> {
    pub const VT_VALUE: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        IntScalar { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args IntScalarArgs,
    ) -> flatbuffers::WIPOffset<IntScalar<'bldr>> {
        let mut builder = IntScalarBuilder::new(_fbb);
        builder.add_value(args.value);
        builder.finish()
    }

    #[inline]
    pub fn value(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<i32>(IntScalar::VT_VALUE, Some(0)).unwrap() }
    }
}

impl flatbuffers::Verifiable for IntScalar<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct IntScalarArgs {
    pub value: i32,
}
impl<'a> Default for IntScalarArgs {
    #[inline]
    fn default() -> Self {
        IntScalarArgs { value: 0 }
    }
}

pub struct IntScalarBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> IntScalarBuilder<'a, 'b> {
    #[inline]
    pub fn add_value(&mut self, value: i32) {
        self.fbb_.push_slot::<i32>(IntScalar::VT_VALUE, value, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> IntScalarBuilder<'a, 'b> {
        let start = _fbb.start_table();
        IntScalarBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<IntScalar<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for IntScalar<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("IntScalar");
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum FloatScalarOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct FloatScalar<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FloatScalar<'a> {
    type Inner = FloatScalar<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> FloatScalar<'a> {
    pub const VT_VALUE: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FloatScalar { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FloatScalarArgs,
    ) -> flatbuffers::WIPOffset<FloatScalar<'bldr>> {
        let mut builder = FloatScalarBuilder::new(_fbb);
        builder.add_value(args.value);
        builder.finish()
    }

    #[inline]
    pub fn value(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(FloatScalar::VT_VALUE, Some(0.0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for FloatScalar<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<f32>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct FloatScalarArgs {
    pub value: f32,
}
impl<'a> Default for FloatScalarArgs {
    #[inline]
    fn default() -> Self {
        FloatScalarArgs { value: 0.0 }
    }
}

pub struct FloatScalarBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FloatScalarBuilder<'a, 'b> {
    #[inline]
    pub fn add_value(&mut self, value: f32) {
        self.fbb_
            .push_slot::<f32>(FloatScalar::VT_VALUE, value, 0.0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FloatScalarBuilder<'a, 'b> {
        let start = _fbb.start_table();
        FloatScalarBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<FloatScalar<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for FloatScalar<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("FloatScalar");
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum ConstantOfShapeAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ConstantOfShapeAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ConstantOfShapeAttrs<'a> {
    type Inner = ConstantOfShapeAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> ConstantOfShapeAttrs<'a> {
    pub const VT_VALUE_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ConstantOfShapeAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ConstantOfShapeAttrsArgs,
    ) -> flatbuffers::WIPOffset<ConstantOfShapeAttrs<'bldr>> {
        let mut builder = ConstantOfShapeAttrsBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        builder.add_value_type(args.value_type);
        builder.finish()
    }

    #[inline]
    pub fn value_type(&self) -> Scalar {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<Scalar>(ConstantOfShapeAttrs::VT_VALUE_TYPE, Some(Scalar::NONE))
                .unwrap()
        }
    }
    #[inline]
    pub fn value(&self) -> flatbuffers::Table<'a> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    ConstantOfShapeAttrs::VT_VALUE,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn value_as_int_scalar(&self) -> Option<IntScalar<'a>> {
        if self.value_type() == Scalar::IntScalar {
            let u = self.value();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid union in this slot
            Some(unsafe { IntScalar::init_from_table(u) })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn value_as_float_scalar(&self) -> Option<FloatScalar<'a>> {
        if self.value_type() == Scalar::FloatScalar {
            let u = self.value();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid union in this slot
            Some(unsafe { FloatScalar::init_from_table(u) })
        } else {
            None
        }
    }
}

impl flatbuffers::Verifiable for ConstantOfShapeAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_union::<Scalar, _>(
                "value_type",
                Self::VT_VALUE_TYPE,
                "value",
                Self::VT_VALUE,
                true,
                |key, v, pos| match key {
                    Scalar::IntScalar => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<IntScalar>>(
                            "Scalar::IntScalar",
                            pos,
                        ),
                    Scalar::FloatScalar => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<FloatScalar>>(
                            "Scalar::FloatScalar",
                            pos,
                        ),
                    _ => Ok(()),
                },
            )?
            .finish();
        Ok(())
    }
}
pub struct ConstantOfShapeAttrsArgs {
    pub value_type: Scalar,
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for ConstantOfShapeAttrsArgs {
    #[inline]
    fn default() -> Self {
        ConstantOfShapeAttrsArgs {
            value_type: Scalar::NONE,
            value: None, // required field
        }
    }
}

pub struct ConstantOfShapeAttrsBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ConstantOfShapeAttrsBuilder<'a, 'b> {
    #[inline]
    pub fn add_value_type(&mut self, value_type: Scalar) {
        self.fbb_.push_slot::<Scalar>(
            ConstantOfShapeAttrs::VT_VALUE_TYPE,
            value_type,
            Scalar::NONE,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ConstantOfShapeAttrs::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> ConstantOfShapeAttrsBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ConstantOfShapeAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ConstantOfShapeAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, ConstantOfShapeAttrs::VT_VALUE, "value");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ConstantOfShapeAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ConstantOfShapeAttrs");
        ds.field("value_type", &self.value_type());
        match self.value_type() {
            Scalar::IntScalar => {
                if let Some(x) = self.value_as_int_scalar() {
                    ds.field("value", &x)
                } else {
                    ds.field(
                        "value",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            Scalar::FloatScalar => {
                if let Some(x) = self.value_as_float_scalar() {
                    ds.field("value", &x)
                } else {
                    ds.field(
                        "value",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("value", &x)
            }
        };
        ds.finish()
    }
}
pub enum ConvAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ConvAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ConvAttrs<'a> {
    type Inner = ConvAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> ConvAttrs<'a> {
    pub const VT_PAD_MODE: flatbuffers::VOffsetT = 4;
    pub const VT_PADS: flatbuffers::VOffsetT = 6;
    pub const VT_GROUPS: flatbuffers::VOffsetT = 8;
    pub const VT_STRIDES: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ConvAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ConvAttrsArgs<'args>,
    ) -> flatbuffers::WIPOffset<ConvAttrs<'bldr>> {
        let mut builder = ConvAttrsBuilder::new(_fbb);
        if let Some(x) = args.strides {
            builder.add_strides(x);
        }
        builder.add_groups(args.groups);
        if let Some(x) = args.pads {
            builder.add_pads(x);
        }
        builder.add_pad_mode(args.pad_mode);
        builder.finish()
    }

    #[inline]
    pub fn pad_mode(&self) -> PadMode {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<PadMode>(ConvAttrs::VT_PAD_MODE, Some(PadMode::Same))
                .unwrap()
        }
    }
    #[inline]
    pub fn pads(&self) -> Option<flatbuffers::Vector<'a, u32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    ConvAttrs::VT_PADS,
                    None,
                )
        }
    }
    #[inline]
    pub fn groups(&self) -> u32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<u32>(ConvAttrs::VT_GROUPS, Some(0)).unwrap() }
    }
    #[inline]
    pub fn strides(&self) -> Option<flatbuffers::Vector<'a, u32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    ConvAttrs::VT_STRIDES,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for ConvAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<PadMode>("pad_mode", Self::VT_PAD_MODE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "pads",
                Self::VT_PADS,
                false,
            )?
            .visit_field::<u32>("groups", Self::VT_GROUPS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "strides",
                Self::VT_STRIDES,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct ConvAttrsArgs<'a> {
    pub pad_mode: PadMode,
    pub pads: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub groups: u32,
    pub strides: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
}
impl<'a> Default for ConvAttrsArgs<'a> {
    #[inline]
    fn default() -> Self {
        ConvAttrsArgs {
            pad_mode: PadMode::Same,
            pads: None,
            groups: 0,
            strides: None,
        }
    }
}

pub struct ConvAttrsBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ConvAttrsBuilder<'a, 'b> {
    #[inline]
    pub fn add_pad_mode(&mut self, pad_mode: PadMode) {
        self.fbb_
            .push_slot::<PadMode>(ConvAttrs::VT_PAD_MODE, pad_mode, PadMode::Same);
    }
    #[inline]
    pub fn add_pads(&mut self, pads: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ConvAttrs::VT_PADS, pads);
    }
    #[inline]
    pub fn add_groups(&mut self, groups: u32) {
        self.fbb_.push_slot::<u32>(ConvAttrs::VT_GROUPS, groups, 0);
    }
    #[inline]
    pub fn add_strides(&mut self, strides: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ConvAttrs::VT_STRIDES, strides);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ConvAttrsBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ConvAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ConvAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ConvAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ConvAttrs");
        ds.field("pad_mode", &self.pad_mode());
        ds.field("pads", &self.pads());
        ds.field("groups", &self.groups());
        ds.field("strides", &self.strides());
        ds.finish()
    }
}
pub enum ConvTransposeAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ConvTransposeAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ConvTransposeAttrs<'a> {
    type Inner = ConvTransposeAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> ConvTransposeAttrs<'a> {
    pub const VT_STRIDES: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ConvTransposeAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ConvTransposeAttrsArgs<'args>,
    ) -> flatbuffers::WIPOffset<ConvTransposeAttrs<'bldr>> {
        let mut builder = ConvTransposeAttrsBuilder::new(_fbb);
        if let Some(x) = args.strides {
            builder.add_strides(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn strides(&self) -> Option<flatbuffers::Vector<'a, u32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    ConvTransposeAttrs::VT_STRIDES,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for ConvTransposeAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "strides",
                Self::VT_STRIDES,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct ConvTransposeAttrsArgs<'a> {
    pub strides: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
}
impl<'a> Default for ConvTransposeAttrsArgs<'a> {
    #[inline]
    fn default() -> Self {
        ConvTransposeAttrsArgs { strides: None }
    }
}

pub struct ConvTransposeAttrsBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ConvTransposeAttrsBuilder<'a, 'b> {
    #[inline]
    pub fn add_strides(&mut self, strides: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ConvTransposeAttrs::VT_STRIDES, strides);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> ConvTransposeAttrsBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ConvTransposeAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ConvTransposeAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ConvTransposeAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ConvTransposeAttrs");
        ds.field("strides", &self.strides());
        ds.finish()
    }
}
pub enum FlattenAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct FlattenAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FlattenAttrs<'a> {
    type Inner = FlattenAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> FlattenAttrs<'a> {
    pub const VT_AXIS: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FlattenAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FlattenAttrsArgs,
    ) -> flatbuffers::WIPOffset<FlattenAttrs<'bldr>> {
        let mut builder = FlattenAttrsBuilder::new(_fbb);
        builder.add_axis(args.axis);
        builder.finish()
    }

    #[inline]
    pub fn axis(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(FlattenAttrs::VT_AXIS, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for FlattenAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("axis", Self::VT_AXIS, false)?
            .finish();
        Ok(())
    }
}
pub struct FlattenAttrsArgs {
    pub axis: i32,
}
impl<'a> Default for FlattenAttrsArgs {
    #[inline]
    fn default() -> Self {
        FlattenAttrsArgs { axis: 0 }
    }
}

pub struct FlattenAttrsBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FlattenAttrsBuilder<'a, 'b> {
    #[inline]
    pub fn add_axis(&mut self, axis: i32) {
        self.fbb_.push_slot::<i32>(FlattenAttrs::VT_AXIS, axis, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FlattenAttrsBuilder<'a, 'b> {
        let start = _fbb.start_table();
        FlattenAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<FlattenAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for FlattenAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("FlattenAttrs");
        ds.field("axis", &self.axis());
        ds.finish()
    }
}
pub enum GatherAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GatherAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GatherAttrs<'a> {
    type Inner = GatherAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> GatherAttrs<'a> {
    pub const VT_AXIS: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GatherAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GatherAttrsArgs,
    ) -> flatbuffers::WIPOffset<GatherAttrs<'bldr>> {
        let mut builder = GatherAttrsBuilder::new(_fbb);
        builder.add_axis(args.axis);
        builder.finish()
    }

    #[inline]
    pub fn axis(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<i32>(GatherAttrs::VT_AXIS, Some(0)).unwrap() }
    }
}

impl flatbuffers::Verifiable for GatherAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("axis", Self::VT_AXIS, false)?
            .finish();
        Ok(())
    }
}
pub struct GatherAttrsArgs {
    pub axis: i32,
}
impl<'a> Default for GatherAttrsArgs {
    #[inline]
    fn default() -> Self {
        GatherAttrsArgs { axis: 0 }
    }
}

pub struct GatherAttrsBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GatherAttrsBuilder<'a, 'b> {
    #[inline]
    pub fn add_axis(&mut self, axis: i32) {
        self.fbb_.push_slot::<i32>(GatherAttrs::VT_AXIS, axis, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GatherAttrsBuilder<'a, 'b> {
        let start = _fbb.start_table();
        GatherAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<GatherAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for GatherAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("GatherAttrs");
        ds.field("axis", &self.axis());
        ds.finish()
    }
}
pub enum GemmAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GemmAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GemmAttrs<'a> {
    type Inner = GemmAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> GemmAttrs<'a> {
    pub const VT_ALPHA: flatbuffers::VOffsetT = 4;
    pub const VT_BETA: flatbuffers::VOffsetT = 6;
    pub const VT_TRANSPOSE_A: flatbuffers::VOffsetT = 8;
    pub const VT_TRANSPOSE_B: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GemmAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GemmAttrsArgs,
    ) -> flatbuffers::WIPOffset<GemmAttrs<'bldr>> {
        let mut builder = GemmAttrsBuilder::new(_fbb);
        builder.add_beta(args.beta);
        builder.add_alpha(args.alpha);
        builder.add_transpose_b(args.transpose_b);
        builder.add_transpose_a(args.transpose_a);
        builder.finish()
    }

    #[inline]
    pub fn alpha(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(GemmAttrs::VT_ALPHA, Some(0.0))
                .unwrap()
        }
    }
    #[inline]
    pub fn beta(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<f32>(GemmAttrs::VT_BETA, Some(0.0)).unwrap() }
    }
    #[inline]
    pub fn transpose_a(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(GemmAttrs::VT_TRANSPOSE_A, Some(false))
                .unwrap()
        }
    }
    #[inline]
    pub fn transpose_b(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(GemmAttrs::VT_TRANSPOSE_B, Some(false))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for GemmAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<f32>("alpha", Self::VT_ALPHA, false)?
            .visit_field::<f32>("beta", Self::VT_BETA, false)?
            .visit_field::<bool>("transpose_a", Self::VT_TRANSPOSE_A, false)?
            .visit_field::<bool>("transpose_b", Self::VT_TRANSPOSE_B, false)?
            .finish();
        Ok(())
    }
}
pub struct GemmAttrsArgs {
    pub alpha: f32,
    pub beta: f32,
    pub transpose_a: bool,
    pub transpose_b: bool,
}
impl<'a> Default for GemmAttrsArgs {
    #[inline]
    fn default() -> Self {
        GemmAttrsArgs {
            alpha: 0.0,
            beta: 0.0,
            transpose_a: false,
            transpose_b: false,
        }
    }
}

pub struct GemmAttrsBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GemmAttrsBuilder<'a, 'b> {
    #[inline]
    pub fn add_alpha(&mut self, alpha: f32) {
        self.fbb_.push_slot::<f32>(GemmAttrs::VT_ALPHA, alpha, 0.0);
    }
    #[inline]
    pub fn add_beta(&mut self, beta: f32) {
        self.fbb_.push_slot::<f32>(GemmAttrs::VT_BETA, beta, 0.0);
    }
    #[inline]
    pub fn add_transpose_a(&mut self, transpose_a: bool) {
        self.fbb_
            .push_slot::<bool>(GemmAttrs::VT_TRANSPOSE_A, transpose_a, false);
    }
    #[inline]
    pub fn add_transpose_b(&mut self, transpose_b: bool) {
        self.fbb_
            .push_slot::<bool>(GemmAttrs::VT_TRANSPOSE_B, transpose_b, false);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GemmAttrsBuilder<'a, 'b> {
        let start = _fbb.start_table();
        GemmAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<GemmAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for GemmAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("GemmAttrs");
        ds.field("alpha", &self.alpha());
        ds.field("beta", &self.beta());
        ds.field("transpose_a", &self.transpose_a());
        ds.field("transpose_b", &self.transpose_b());
        ds.finish()
    }
}
pub enum GRUAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GRUAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GRUAttrs<'a> {
    type Inner = GRUAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> GRUAttrs<'a> {
    pub const VT_DIRECTION: flatbuffers::VOffsetT = 4;
    pub const VT_HIDDEN_SIZE: flatbuffers::VOffsetT = 6;
    pub const VT_LINEAR_BEFORE_RESET: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GRUAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GRUAttrsArgs,
    ) -> flatbuffers::WIPOffset<GRUAttrs<'bldr>> {
        let mut builder = GRUAttrsBuilder::new(_fbb);
        builder.add_hidden_size(args.hidden_size);
        builder.add_linear_before_reset(args.linear_before_reset);
        builder.add_direction(args.direction);
        builder.finish()
    }

    #[inline]
    pub fn direction(&self) -> RNNDirection {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<RNNDirection>(GRUAttrs::VT_DIRECTION, Some(RNNDirection::Forwards))
                .unwrap()
        }
    }
    #[inline]
    pub fn hidden_size(&self) -> u32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<u32>(GRUAttrs::VT_HIDDEN_SIZE, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn linear_before_reset(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(GRUAttrs::VT_LINEAR_BEFORE_RESET, Some(false))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for GRUAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<RNNDirection>("direction", Self::VT_DIRECTION, false)?
            .visit_field::<u32>("hidden_size", Self::VT_HIDDEN_SIZE, false)?
            .visit_field::<bool>("linear_before_reset", Self::VT_LINEAR_BEFORE_RESET, false)?
            .finish();
        Ok(())
    }
}
pub struct GRUAttrsArgs {
    pub direction: RNNDirection,
    pub hidden_size: u32,
    pub linear_before_reset: bool,
}
impl<'a> Default for GRUAttrsArgs {
    #[inline]
    fn default() -> Self {
        GRUAttrsArgs {
            direction: RNNDirection::Forwards,
            hidden_size: 0,
            linear_before_reset: false,
        }
    }
}

pub struct GRUAttrsBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GRUAttrsBuilder<'a, 'b> {
    #[inline]
    pub fn add_direction(&mut self, direction: RNNDirection) {
        self.fbb_.push_slot::<RNNDirection>(
            GRUAttrs::VT_DIRECTION,
            direction,
            RNNDirection::Forwards,
        );
    }
    #[inline]
    pub fn add_hidden_size(&mut self, hidden_size: u32) {
        self.fbb_
            .push_slot::<u32>(GRUAttrs::VT_HIDDEN_SIZE, hidden_size, 0);
    }
    #[inline]
    pub fn add_linear_before_reset(&mut self, linear_before_reset: bool) {
        self.fbb_
            .push_slot::<bool>(GRUAttrs::VT_LINEAR_BEFORE_RESET, linear_before_reset, false);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GRUAttrsBuilder<'a, 'b> {
        let start = _fbb.start_table();
        GRUAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<GRUAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for GRUAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("GRUAttrs");
        ds.field("direction", &self.direction());
        ds.field("hidden_size", &self.hidden_size());
        ds.field("linear_before_reset", &self.linear_before_reset());
        ds.finish()
    }
}
pub enum LeakyReluAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LeakyReluAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LeakyReluAttrs<'a> {
    type Inner = LeakyReluAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> LeakyReluAttrs<'a> {
    pub const VT_ALPHA: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        LeakyReluAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args LeakyReluAttrsArgs,
    ) -> flatbuffers::WIPOffset<LeakyReluAttrs<'bldr>> {
        let mut builder = LeakyReluAttrsBuilder::new(_fbb);
        builder.add_alpha(args.alpha);
        builder.finish()
    }

    #[inline]
    pub fn alpha(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<f32>(LeakyReluAttrs::VT_ALPHA, Some(0.0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for LeakyReluAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<f32>("alpha", Self::VT_ALPHA, false)?
            .finish();
        Ok(())
    }
}
pub struct LeakyReluAttrsArgs {
    pub alpha: f32,
}
impl<'a> Default for LeakyReluAttrsArgs {
    #[inline]
    fn default() -> Self {
        LeakyReluAttrsArgs { alpha: 0.0 }
    }
}

pub struct LeakyReluAttrsBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> LeakyReluAttrsBuilder<'a, 'b> {
    #[inline]
    pub fn add_alpha(&mut self, alpha: f32) {
        self.fbb_
            .push_slot::<f32>(LeakyReluAttrs::VT_ALPHA, alpha, 0.0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> LeakyReluAttrsBuilder<'a, 'b> {
        let start = _fbb.start_table();
        LeakyReluAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<LeakyReluAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for LeakyReluAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("LeakyReluAttrs");
        ds.field("alpha", &self.alpha());
        ds.finish()
    }
}
pub enum LSTMAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LSTMAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LSTMAttrs<'a> {
    type Inner = LSTMAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> LSTMAttrs<'a> {
    pub const VT_DIRECTION: flatbuffers::VOffsetT = 4;
    pub const VT_HIDDEN_SIZE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        LSTMAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args LSTMAttrsArgs,
    ) -> flatbuffers::WIPOffset<LSTMAttrs<'bldr>> {
        let mut builder = LSTMAttrsBuilder::new(_fbb);
        builder.add_hidden_size(args.hidden_size);
        builder.add_direction(args.direction);
        builder.finish()
    }

    #[inline]
    pub fn direction(&self) -> RNNDirection {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<RNNDirection>(LSTMAttrs::VT_DIRECTION, Some(RNNDirection::Forwards))
                .unwrap()
        }
    }
    #[inline]
    pub fn hidden_size(&self) -> u32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<u32>(LSTMAttrs::VT_HIDDEN_SIZE, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for LSTMAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<RNNDirection>("direction", Self::VT_DIRECTION, false)?
            .visit_field::<u32>("hidden_size", Self::VT_HIDDEN_SIZE, false)?
            .finish();
        Ok(())
    }
}
pub struct LSTMAttrsArgs {
    pub direction: RNNDirection,
    pub hidden_size: u32,
}
impl<'a> Default for LSTMAttrsArgs {
    #[inline]
    fn default() -> Self {
        LSTMAttrsArgs {
            direction: RNNDirection::Forwards,
            hidden_size: 0,
        }
    }
}

pub struct LSTMAttrsBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> LSTMAttrsBuilder<'a, 'b> {
    #[inline]
    pub fn add_direction(&mut self, direction: RNNDirection) {
        self.fbb_.push_slot::<RNNDirection>(
            LSTMAttrs::VT_DIRECTION,
            direction,
            RNNDirection::Forwards,
        );
    }
    #[inline]
    pub fn add_hidden_size(&mut self, hidden_size: u32) {
        self.fbb_
            .push_slot::<u32>(LSTMAttrs::VT_HIDDEN_SIZE, hidden_size, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> LSTMAttrsBuilder<'a, 'b> {
        let start = _fbb.start_table();
        LSTMAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<LSTMAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for LSTMAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("LSTMAttrs");
        ds.field("direction", &self.direction());
        ds.field("hidden_size", &self.hidden_size());
        ds.finish()
    }
}
pub enum MaxPoolAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MaxPoolAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MaxPoolAttrs<'a> {
    type Inner = MaxPoolAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> MaxPoolAttrs<'a> {
    pub const VT_KERNEL_SIZE: flatbuffers::VOffsetT = 4;
    pub const VT_PAD_MODE: flatbuffers::VOffsetT = 6;
    pub const VT_PADS: flatbuffers::VOffsetT = 8;
    pub const VT_STRIDES: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        MaxPoolAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args MaxPoolAttrsArgs<'args>,
    ) -> flatbuffers::WIPOffset<MaxPoolAttrs<'bldr>> {
        let mut builder = MaxPoolAttrsBuilder::new(_fbb);
        if let Some(x) = args.strides {
            builder.add_strides(x);
        }
        if let Some(x) = args.pads {
            builder.add_pads(x);
        }
        if let Some(x) = args.kernel_size {
            builder.add_kernel_size(x);
        }
        builder.add_pad_mode(args.pad_mode);
        builder.finish()
    }

    #[inline]
    pub fn kernel_size(&self) -> flatbuffers::Vector<'a, u32> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    MaxPoolAttrs::VT_KERNEL_SIZE,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn pad_mode(&self) -> PadMode {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<PadMode>(MaxPoolAttrs::VT_PAD_MODE, Some(PadMode::Same))
                .unwrap()
        }
    }
    #[inline]
    pub fn pads(&self) -> Option<flatbuffers::Vector<'a, u32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    MaxPoolAttrs::VT_PADS,
                    None,
                )
        }
    }
    #[inline]
    pub fn strides(&self) -> Option<flatbuffers::Vector<'a, u32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    MaxPoolAttrs::VT_STRIDES,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for MaxPoolAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "kernel_size",
                Self::VT_KERNEL_SIZE,
                true,
            )?
            .visit_field::<PadMode>("pad_mode", Self::VT_PAD_MODE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "pads",
                Self::VT_PADS,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "strides",
                Self::VT_STRIDES,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct MaxPoolAttrsArgs<'a> {
    pub kernel_size: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub pad_mode: PadMode,
    pub pads: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub strides: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
}
impl<'a> Default for MaxPoolAttrsArgs<'a> {
    #[inline]
    fn default() -> Self {
        MaxPoolAttrsArgs {
            kernel_size: None, // required field
            pad_mode: PadMode::Same,
            pads: None,
            strides: None,
        }
    }
}

pub struct MaxPoolAttrsBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MaxPoolAttrsBuilder<'a, 'b> {
    #[inline]
    pub fn add_kernel_size(
        &mut self,
        kernel_size: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            MaxPoolAttrs::VT_KERNEL_SIZE,
            kernel_size,
        );
    }
    #[inline]
    pub fn add_pad_mode(&mut self, pad_mode: PadMode) {
        self.fbb_
            .push_slot::<PadMode>(MaxPoolAttrs::VT_PAD_MODE, pad_mode, PadMode::Same);
    }
    #[inline]
    pub fn add_pads(&mut self, pads: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(MaxPoolAttrs::VT_PADS, pads);
    }
    #[inline]
    pub fn add_strides(&mut self, strides: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(MaxPoolAttrs::VT_STRIDES, strides);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MaxPoolAttrsBuilder<'a, 'b> {
        let start = _fbb.start_table();
        MaxPoolAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<MaxPoolAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_
            .required(o, MaxPoolAttrs::VT_KERNEL_SIZE, "kernel_size");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for MaxPoolAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("MaxPoolAttrs");
        ds.field("kernel_size", &self.kernel_size());
        ds.field("pad_mode", &self.pad_mode());
        ds.field("pads", &self.pads());
        ds.field("strides", &self.strides());
        ds.finish()
    }
}
pub enum ModAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ModAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ModAttrs<'a> {
    type Inner = ModAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> ModAttrs<'a> {
    pub const VT_FMOD: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ModAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ModAttrsArgs,
    ) -> flatbuffers::WIPOffset<ModAttrs<'bldr>> {
        let mut builder = ModAttrsBuilder::new(_fbb);
        builder.add_fmod(args.fmod);
        builder.finish()
    }

    #[inline]
    pub fn fmod(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(ModAttrs::VT_FMOD, Some(false))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for ModAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<bool>("fmod", Self::VT_FMOD, false)?
            .finish();
        Ok(())
    }
}
pub struct ModAttrsArgs {
    pub fmod: bool,
}
impl<'a> Default for ModAttrsArgs {
    #[inline]
    fn default() -> Self {
        ModAttrsArgs { fmod: false }
    }
}

pub struct ModAttrsBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ModAttrsBuilder<'a, 'b> {
    #[inline]
    pub fn add_fmod(&mut self, fmod: bool) {
        self.fbb_.push_slot::<bool>(ModAttrs::VT_FMOD, fmod, false);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ModAttrsBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ModAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ModAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ModAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ModAttrs");
        ds.field("fmod", &self.fmod());
        ds.finish()
    }
}
pub enum ReduceMeanAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ReduceMeanAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ReduceMeanAttrs<'a> {
    type Inner = ReduceMeanAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> ReduceMeanAttrs<'a> {
    pub const VT_AXES: flatbuffers::VOffsetT = 4;
    pub const VT_KEEP_DIMS: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ReduceMeanAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ReduceMeanAttrsArgs<'args>,
    ) -> flatbuffers::WIPOffset<ReduceMeanAttrs<'bldr>> {
        let mut builder = ReduceMeanAttrsBuilder::new(_fbb);
        if let Some(x) = args.axes {
            builder.add_axes(x);
        }
        builder.add_keep_dims(args.keep_dims);
        builder.finish()
    }

    #[inline]
    pub fn axes(&self) -> Option<flatbuffers::Vector<'a, i32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(
                    ReduceMeanAttrs::VT_AXES,
                    None,
                )
        }
    }
    #[inline]
    pub fn keep_dims(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(ReduceMeanAttrs::VT_KEEP_DIMS, Some(false))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for ReduceMeanAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>(
                "axes",
                Self::VT_AXES,
                false,
            )?
            .visit_field::<bool>("keep_dims", Self::VT_KEEP_DIMS, false)?
            .finish();
        Ok(())
    }
}
pub struct ReduceMeanAttrsArgs<'a> {
    pub axes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub keep_dims: bool,
}
impl<'a> Default for ReduceMeanAttrsArgs<'a> {
    #[inline]
    fn default() -> Self {
        ReduceMeanAttrsArgs {
            axes: None,
            keep_dims: false,
        }
    }
}

pub struct ReduceMeanAttrsBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ReduceMeanAttrsBuilder<'a, 'b> {
    #[inline]
    pub fn add_axes(&mut self, axes: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ReduceMeanAttrs::VT_AXES, axes);
    }
    #[inline]
    pub fn add_keep_dims(&mut self, keep_dims: bool) {
        self.fbb_
            .push_slot::<bool>(ReduceMeanAttrs::VT_KEEP_DIMS, keep_dims, false);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ReduceMeanAttrsBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ReduceMeanAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ReduceMeanAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ReduceMeanAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ReduceMeanAttrs");
        ds.field("axes", &self.axes());
        ds.field("keep_dims", &self.keep_dims());
        ds.finish()
    }
}
pub enum ReshapeAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ReshapeAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ReshapeAttrs<'a> {
    type Inner = ReshapeAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> ReshapeAttrs<'a> {
    pub const VT_ALLOW_ZERO: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ReshapeAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ReshapeAttrsArgs,
    ) -> flatbuffers::WIPOffset<ReshapeAttrs<'bldr>> {
        let mut builder = ReshapeAttrsBuilder::new(_fbb);
        builder.add_allow_zero(args.allow_zero);
        builder.finish()
    }

    #[inline]
    pub fn allow_zero(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<bool>(ReshapeAttrs::VT_ALLOW_ZERO, Some(false))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for ReshapeAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<bool>("allow_zero", Self::VT_ALLOW_ZERO, false)?
            .finish();
        Ok(())
    }
}
pub struct ReshapeAttrsArgs {
    pub allow_zero: bool,
}
impl<'a> Default for ReshapeAttrsArgs {
    #[inline]
    fn default() -> Self {
        ReshapeAttrsArgs { allow_zero: false }
    }
}

pub struct ReshapeAttrsBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ReshapeAttrsBuilder<'a, 'b> {
    #[inline]
    pub fn add_allow_zero(&mut self, allow_zero: bool) {
        self.fbb_
            .push_slot::<bool>(ReshapeAttrs::VT_ALLOW_ZERO, allow_zero, false);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ReshapeAttrsBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ReshapeAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ReshapeAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ReshapeAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ReshapeAttrs");
        ds.field("allow_zero", &self.allow_zero());
        ds.finish()
    }
}
pub enum ResizeAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ResizeAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ResizeAttrs<'a> {
    type Inner = ResizeAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> ResizeAttrs<'a> {
    pub const VT_MODE: flatbuffers::VOffsetT = 4;
    pub const VT_COORD_MODE: flatbuffers::VOffsetT = 6;
    pub const VT_NEAREST_MODE: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ResizeAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ResizeAttrsArgs,
    ) -> flatbuffers::WIPOffset<ResizeAttrs<'bldr>> {
        let mut builder = ResizeAttrsBuilder::new(_fbb);
        builder.add_nearest_mode(args.nearest_mode);
        builder.add_coord_mode(args.coord_mode);
        builder.add_mode(args.mode);
        builder.finish()
    }

    #[inline]
    pub fn mode(&self) -> ResizeMode {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<ResizeMode>(ResizeAttrs::VT_MODE, Some(ResizeMode::Nearest))
                .unwrap()
        }
    }
    #[inline]
    pub fn coord_mode(&self) -> CoordTransformMode {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<CoordTransformMode>(
                    ResizeAttrs::VT_COORD_MODE,
                    Some(CoordTransformMode::HalfPixel),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn nearest_mode(&self) -> NearestMode {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<NearestMode>(ResizeAttrs::VT_NEAREST_MODE, Some(NearestMode::Floor))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for ResizeAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<ResizeMode>("mode", Self::VT_MODE, false)?
            .visit_field::<CoordTransformMode>("coord_mode", Self::VT_COORD_MODE, false)?
            .visit_field::<NearestMode>("nearest_mode", Self::VT_NEAREST_MODE, false)?
            .finish();
        Ok(())
    }
}
pub struct ResizeAttrsArgs {
    pub mode: ResizeMode,
    pub coord_mode: CoordTransformMode,
    pub nearest_mode: NearestMode,
}
impl<'a> Default for ResizeAttrsArgs {
    #[inline]
    fn default() -> Self {
        ResizeAttrsArgs {
            mode: ResizeMode::Nearest,
            coord_mode: CoordTransformMode::HalfPixel,
            nearest_mode: NearestMode::Floor,
        }
    }
}

pub struct ResizeAttrsBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ResizeAttrsBuilder<'a, 'b> {
    #[inline]
    pub fn add_mode(&mut self, mode: ResizeMode) {
        self.fbb_
            .push_slot::<ResizeMode>(ResizeAttrs::VT_MODE, mode, ResizeMode::Nearest);
    }
    #[inline]
    pub fn add_coord_mode(&mut self, coord_mode: CoordTransformMode) {
        self.fbb_.push_slot::<CoordTransformMode>(
            ResizeAttrs::VT_COORD_MODE,
            coord_mode,
            CoordTransformMode::HalfPixel,
        );
    }
    #[inline]
    pub fn add_nearest_mode(&mut self, nearest_mode: NearestMode) {
        self.fbb_.push_slot::<NearestMode>(
            ResizeAttrs::VT_NEAREST_MODE,
            nearest_mode,
            NearestMode::Floor,
        );
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ResizeAttrsBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ResizeAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ResizeAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ResizeAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ResizeAttrs");
        ds.field("mode", &self.mode());
        ds.field("coord_mode", &self.coord_mode());
        ds.field("nearest_mode", &self.nearest_mode());
        ds.finish()
    }
}
pub enum ScatterElementsAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ScatterElementsAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ScatterElementsAttrs<'a> {
    type Inner = ScatterElementsAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> ScatterElementsAttrs<'a> {
    pub const VT_AXIS: flatbuffers::VOffsetT = 4;
    pub const VT_REDUCTION: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ScatterElementsAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ScatterElementsAttrsArgs,
    ) -> flatbuffers::WIPOffset<ScatterElementsAttrs<'bldr>> {
        let mut builder = ScatterElementsAttrsBuilder::new(_fbb);
        builder.add_axis(args.axis);
        builder.add_reduction(args.reduction);
        builder.finish()
    }

    #[inline]
    pub fn axis(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(ScatterElementsAttrs::VT_AXIS, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn reduction(&self) -> ScatterReduction {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<ScatterReduction>(
                    ScatterElementsAttrs::VT_REDUCTION,
                    Some(ScatterReduction::None),
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for ScatterElementsAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("axis", Self::VT_AXIS, false)?
            .visit_field::<ScatterReduction>("reduction", Self::VT_REDUCTION, false)?
            .finish();
        Ok(())
    }
}
pub struct ScatterElementsAttrsArgs {
    pub axis: i32,
    pub reduction: ScatterReduction,
}
impl<'a> Default for ScatterElementsAttrsArgs {
    #[inline]
    fn default() -> Self {
        ScatterElementsAttrsArgs {
            axis: 0,
            reduction: ScatterReduction::None,
        }
    }
}

pub struct ScatterElementsAttrsBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ScatterElementsAttrsBuilder<'a, 'b> {
    #[inline]
    pub fn add_axis(&mut self, axis: i32) {
        self.fbb_
            .push_slot::<i32>(ScatterElementsAttrs::VT_AXIS, axis, 0);
    }
    #[inline]
    pub fn add_reduction(&mut self, reduction: ScatterReduction) {
        self.fbb_.push_slot::<ScatterReduction>(
            ScatterElementsAttrs::VT_REDUCTION,
            reduction,
            ScatterReduction::None,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> ScatterElementsAttrsBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ScatterElementsAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ScatterElementsAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ScatterElementsAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ScatterElementsAttrs");
        ds.field("axis", &self.axis());
        ds.field("reduction", &self.reduction());
        ds.finish()
    }
}
pub enum SoftmaxAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SoftmaxAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SoftmaxAttrs<'a> {
    type Inner = SoftmaxAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> SoftmaxAttrs<'a> {
    pub const VT_AXIS: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SoftmaxAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args SoftmaxAttrsArgs,
    ) -> flatbuffers::WIPOffset<SoftmaxAttrs<'bldr>> {
        let mut builder = SoftmaxAttrsBuilder::new(_fbb);
        builder.add_axis(args.axis);
        builder.finish()
    }

    #[inline]
    pub fn axis(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(SoftmaxAttrs::VT_AXIS, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for SoftmaxAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("axis", Self::VT_AXIS, false)?
            .finish();
        Ok(())
    }
}
pub struct SoftmaxAttrsArgs {
    pub axis: i32,
}
impl<'a> Default for SoftmaxAttrsArgs {
    #[inline]
    fn default() -> Self {
        SoftmaxAttrsArgs { axis: 0 }
    }
}

pub struct SoftmaxAttrsBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SoftmaxAttrsBuilder<'a, 'b> {
    #[inline]
    pub fn add_axis(&mut self, axis: i32) {
        self.fbb_.push_slot::<i32>(SoftmaxAttrs::VT_AXIS, axis, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SoftmaxAttrsBuilder<'a, 'b> {
        let start = _fbb.start_table();
        SoftmaxAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<SoftmaxAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for SoftmaxAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("SoftmaxAttrs");
        ds.field("axis", &self.axis());
        ds.finish()
    }
}
pub enum SplitAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SplitAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SplitAttrs<'a> {
    type Inner = SplitAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> SplitAttrs<'a> {
    pub const VT_AXIS: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SplitAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args SplitAttrsArgs,
    ) -> flatbuffers::WIPOffset<SplitAttrs<'bldr>> {
        let mut builder = SplitAttrsBuilder::new(_fbb);
        builder.add_axis(args.axis);
        builder.finish()
    }

    #[inline]
    pub fn axis(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<i32>(SplitAttrs::VT_AXIS, Some(0)).unwrap() }
    }
}

impl flatbuffers::Verifiable for SplitAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("axis", Self::VT_AXIS, false)?
            .finish();
        Ok(())
    }
}
pub struct SplitAttrsArgs {
    pub axis: i32,
}
impl<'a> Default for SplitAttrsArgs {
    #[inline]
    fn default() -> Self {
        SplitAttrsArgs { axis: 0 }
    }
}

pub struct SplitAttrsBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SplitAttrsBuilder<'a, 'b> {
    #[inline]
    pub fn add_axis(&mut self, axis: i32) {
        self.fbb_.push_slot::<i32>(SplitAttrs::VT_AXIS, axis, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SplitAttrsBuilder<'a, 'b> {
        let start = _fbb.start_table();
        SplitAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<SplitAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for SplitAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("SplitAttrs");
        ds.field("axis", &self.axis());
        ds.finish()
    }
}
pub enum TransposeAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TransposeAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TransposeAttrs<'a> {
    type Inner = TransposeAttrs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> TransposeAttrs<'a> {
    pub const VT_PERM: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        TransposeAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args TransposeAttrsArgs<'args>,
    ) -> flatbuffers::WIPOffset<TransposeAttrs<'bldr>> {
        let mut builder = TransposeAttrsBuilder::new(_fbb);
        if let Some(x) = args.perm {
            builder.add_perm(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn perm(&self) -> Option<flatbuffers::Vector<'a, u32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    TransposeAttrs::VT_PERM,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for TransposeAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "perm",
                Self::VT_PERM,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct TransposeAttrsArgs<'a> {
    pub perm: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
}
impl<'a> Default for TransposeAttrsArgs<'a> {
    #[inline]
    fn default() -> Self {
        TransposeAttrsArgs { perm: None }
    }
}

pub struct TransposeAttrsBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TransposeAttrsBuilder<'a, 'b> {
    #[inline]
    pub fn add_perm(&mut self, perm: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(TransposeAttrs::VT_PERM, perm);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TransposeAttrsBuilder<'a, 'b> {
        let start = _fbb.start_table();
        TransposeAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<TransposeAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for TransposeAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("TransposeAttrs");
        ds.field("perm", &self.perm());
        ds.finish()
    }
}
pub enum OperatorNodeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct OperatorNode<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for OperatorNode<'a> {
    type Inner = OperatorNode<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> OperatorNode<'a> {
    pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
    pub const VT_ATTRS_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_ATTRS: flatbuffers::VOffsetT = 8;
    pub const VT_INPUTS: flatbuffers::VOffsetT = 10;
    pub const VT_OUTPUTS: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        OperatorNode { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args OperatorNodeArgs<'args>,
    ) -> flatbuffers::WIPOffset<OperatorNode<'bldr>> {
        let mut builder = OperatorNodeBuilder::new(_fbb);
        if let Some(x) = args.outputs {
            builder.add_outputs(x);
        }
        if let Some(x) = args.inputs {
            builder.add_inputs(x);
        }
        if let Some(x) = args.attrs {
            builder.add_attrs(x);
        }
        builder.add_attrs_type(args.attrs_type);
        builder.add_type_(args.type_);
        builder.finish()
    }

    #[inline]
    pub fn type_(&self) -> OperatorType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<OperatorType>(OperatorNode::VT_TYPE_, Some(OperatorType::Add))
                .unwrap()
        }
    }
    #[inline]
    pub fn attrs_type(&self) -> OperatorAttrs {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<OperatorAttrs>(OperatorNode::VT_ATTRS_TYPE, Some(OperatorAttrs::NONE))
                .unwrap()
        }
    }
    #[inline]
    pub fn attrs(&self) -> Option<flatbuffers::Table<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    OperatorNode::VT_ATTRS,
                    None,
                )
        }
    }
    #[inline]
    pub fn inputs(&self) -> Option<flatbuffers::Vector<'a, i32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(
                    OperatorNode::VT_INPUTS,
                    None,
                )
        }
    }
    #[inline]
    pub fn outputs(&self) -> Option<flatbuffers::Vector<'a, i32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(
                    OperatorNode::VT_OUTPUTS,
                    None,
                )
        }
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_arg_max_attrs(&self) -> Option<ArgMaxAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::ArgMaxAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { ArgMaxAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_average_pool_attrs(&self) -> Option<AveragePoolAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::AveragePoolAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { AveragePoolAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_batch_normalization_attrs(&self) -> Option<BatchNormalizationAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::BatchNormalizationAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { BatchNormalizationAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_cast_attrs(&self) -> Option<CastAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::CastAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { CastAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_concat_attrs(&self) -> Option<ConcatAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::ConcatAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { ConcatAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_constant_of_shape_attrs(&self) -> Option<ConstantOfShapeAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::ConstantOfShapeAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { ConstantOfShapeAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_conv_attrs(&self) -> Option<ConvAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::ConvAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { ConvAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_conv_transpose_attrs(&self) -> Option<ConvTransposeAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::ConvTransposeAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { ConvTransposeAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_flatten_attrs(&self) -> Option<FlattenAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::FlattenAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { FlattenAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_gather_attrs(&self) -> Option<GatherAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::GatherAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { GatherAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_gemm_attrs(&self) -> Option<GemmAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::GemmAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { GemmAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_gruattrs(&self) -> Option<GRUAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::GRUAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { GRUAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_leaky_relu_attrs(&self) -> Option<LeakyReluAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::LeakyReluAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { LeakyReluAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_lstmattrs(&self) -> Option<LSTMAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::LSTMAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { LSTMAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_max_pool_attrs(&self) -> Option<MaxPoolAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::MaxPoolAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { MaxPoolAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_reduce_mean_attrs(&self) -> Option<ReduceMeanAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::ReduceMeanAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { ReduceMeanAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_reshape_attrs(&self) -> Option<ReshapeAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::ReshapeAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { ReshapeAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_resize_attrs(&self) -> Option<ResizeAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::ResizeAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { ResizeAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_split_attrs(&self) -> Option<SplitAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::SplitAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { SplitAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_softmax_attrs(&self) -> Option<SoftmaxAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::SoftmaxAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { SoftmaxAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_transpose_attrs(&self) -> Option<TransposeAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::TransposeAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { TransposeAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_mod_attrs(&self) -> Option<ModAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::ModAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { ModAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_scatter_elements_attrs(&self) -> Option<ScatterElementsAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::ScatterElementsAttrs {
            self.attrs().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { ScatterElementsAttrs::init_from_table(t) }
            })
        } else {
            None
        }
    }
}

impl flatbuffers::Verifiable for OperatorNode<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<OperatorType>("type_", Self::VT_TYPE_, false)?
     .visit_union::<OperatorAttrs, _>("attrs_type", Self::VT_ATTRS_TYPE, "attrs", Self::VT_ATTRS, false, |key, v, pos| {
        match key {
          OperatorAttrs::ArgMaxAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArgMaxAttrs>>("OperatorAttrs::ArgMaxAttrs", pos),
          OperatorAttrs::AveragePoolAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<AveragePoolAttrs>>("OperatorAttrs::AveragePoolAttrs", pos),
          OperatorAttrs::BatchNormalizationAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BatchNormalizationAttrs>>("OperatorAttrs::BatchNormalizationAttrs", pos),
          OperatorAttrs::CastAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CastAttrs>>("OperatorAttrs::CastAttrs", pos),
          OperatorAttrs::ConcatAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConcatAttrs>>("OperatorAttrs::ConcatAttrs", pos),
          OperatorAttrs::ConstantOfShapeAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConstantOfShapeAttrs>>("OperatorAttrs::ConstantOfShapeAttrs", pos),
          OperatorAttrs::ConvAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConvAttrs>>("OperatorAttrs::ConvAttrs", pos),
          OperatorAttrs::ConvTransposeAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConvTransposeAttrs>>("OperatorAttrs::ConvTransposeAttrs", pos),
          OperatorAttrs::FlattenAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FlattenAttrs>>("OperatorAttrs::FlattenAttrs", pos),
          OperatorAttrs::GatherAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GatherAttrs>>("OperatorAttrs::GatherAttrs", pos),
          OperatorAttrs::GemmAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GemmAttrs>>("OperatorAttrs::GemmAttrs", pos),
          OperatorAttrs::GRUAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GRUAttrs>>("OperatorAttrs::GRUAttrs", pos),
          OperatorAttrs::LeakyReluAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LeakyReluAttrs>>("OperatorAttrs::LeakyReluAttrs", pos),
          OperatorAttrs::LSTMAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LSTMAttrs>>("OperatorAttrs::LSTMAttrs", pos),
          OperatorAttrs::MaxPoolAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MaxPoolAttrs>>("OperatorAttrs::MaxPoolAttrs", pos),
          OperatorAttrs::ReduceMeanAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ReduceMeanAttrs>>("OperatorAttrs::ReduceMeanAttrs", pos),
          OperatorAttrs::ReshapeAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ReshapeAttrs>>("OperatorAttrs::ReshapeAttrs", pos),
          OperatorAttrs::ResizeAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ResizeAttrs>>("OperatorAttrs::ResizeAttrs", pos),
          OperatorAttrs::SplitAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SplitAttrs>>("OperatorAttrs::SplitAttrs", pos),
          OperatorAttrs::SoftmaxAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SoftmaxAttrs>>("OperatorAttrs::SoftmaxAttrs", pos),
          OperatorAttrs::TransposeAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TransposeAttrs>>("OperatorAttrs::TransposeAttrs", pos),
          OperatorAttrs::ModAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ModAttrs>>("OperatorAttrs::ModAttrs", pos),
          OperatorAttrs::ScatterElementsAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ScatterElementsAttrs>>("OperatorAttrs::ScatterElementsAttrs", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("inputs", Self::VT_INPUTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("outputs", Self::VT_OUTPUTS, false)?
     .finish();
        Ok(())
    }
}
pub struct OperatorNodeArgs<'a> {
    pub type_: OperatorType,
    pub attrs_type: OperatorAttrs,
    pub attrs: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub inputs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub outputs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
}
impl<'a> Default for OperatorNodeArgs<'a> {
    #[inline]
    fn default() -> Self {
        OperatorNodeArgs {
            type_: OperatorType::Add,
            attrs_type: OperatorAttrs::NONE,
            attrs: None,
            inputs: None,
            outputs: None,
        }
    }
}

pub struct OperatorNodeBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> OperatorNodeBuilder<'a, 'b> {
    #[inline]
    pub fn add_type_(&mut self, type_: OperatorType) {
        self.fbb_
            .push_slot::<OperatorType>(OperatorNode::VT_TYPE_, type_, OperatorType::Add);
    }
    #[inline]
    pub fn add_attrs_type(&mut self, attrs_type: OperatorAttrs) {
        self.fbb_.push_slot::<OperatorAttrs>(
            OperatorNode::VT_ATTRS_TYPE,
            attrs_type,
            OperatorAttrs::NONE,
        );
    }
    #[inline]
    pub fn add_attrs(&mut self, attrs: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(OperatorNode::VT_ATTRS, attrs);
    }
    #[inline]
    pub fn add_inputs(&mut self, inputs: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(OperatorNode::VT_INPUTS, inputs);
    }
    #[inline]
    pub fn add_outputs(&mut self, outputs: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(OperatorNode::VT_OUTPUTS, outputs);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> OperatorNodeBuilder<'a, 'b> {
        let start = _fbb.start_table();
        OperatorNodeBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<OperatorNode<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for OperatorNode<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("OperatorNode");
        ds.field("type_", &self.type_());
        ds.field("attrs_type", &self.attrs_type());
        match self.attrs_type() {
            OperatorAttrs::ArgMaxAttrs => {
                if let Some(x) = self.attrs_as_arg_max_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::AveragePoolAttrs => {
                if let Some(x) = self.attrs_as_average_pool_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::BatchNormalizationAttrs => {
                if let Some(x) = self.attrs_as_batch_normalization_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::CastAttrs => {
                if let Some(x) = self.attrs_as_cast_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::ConcatAttrs => {
                if let Some(x) = self.attrs_as_concat_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::ConstantOfShapeAttrs => {
                if let Some(x) = self.attrs_as_constant_of_shape_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::ConvAttrs => {
                if let Some(x) = self.attrs_as_conv_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::ConvTransposeAttrs => {
                if let Some(x) = self.attrs_as_conv_transpose_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::FlattenAttrs => {
                if let Some(x) = self.attrs_as_flatten_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::GatherAttrs => {
                if let Some(x) = self.attrs_as_gather_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::GemmAttrs => {
                if let Some(x) = self.attrs_as_gemm_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::GRUAttrs => {
                if let Some(x) = self.attrs_as_gruattrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::LeakyReluAttrs => {
                if let Some(x) = self.attrs_as_leaky_relu_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::LSTMAttrs => {
                if let Some(x) = self.attrs_as_lstmattrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::MaxPoolAttrs => {
                if let Some(x) = self.attrs_as_max_pool_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::ReduceMeanAttrs => {
                if let Some(x) = self.attrs_as_reduce_mean_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::ReshapeAttrs => {
                if let Some(x) = self.attrs_as_reshape_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::ResizeAttrs => {
                if let Some(x) = self.attrs_as_resize_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::SplitAttrs => {
                if let Some(x) = self.attrs_as_split_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::SoftmaxAttrs => {
                if let Some(x) = self.attrs_as_softmax_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::TransposeAttrs => {
                if let Some(x) = self.attrs_as_transpose_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::ModAttrs => {
                if let Some(x) = self.attrs_as_mod_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::ScatterElementsAttrs => {
                if let Some(x) = self.attrs_as_scatter_elements_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("attrs", &x)
            }
        };
        ds.field("inputs", &self.inputs());
        ds.field("outputs", &self.outputs());
        ds.finish()
    }
}
pub enum FloatDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct FloatData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FloatData<'a> {
    type Inner = FloatData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> FloatData<'a> {
    pub const VT_DATA: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FloatData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FloatDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<FloatData<'bldr>> {
        let mut builder = FloatDataBuilder::new(_fbb);
        if let Some(x) = args.data {
            builder.add_data(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn data(&self) -> flatbuffers::Vector<'a, f32> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(
                    FloatData::VT_DATA,
                    None,
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for FloatData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>(
                "data",
                Self::VT_DATA,
                true,
            )?
            .finish();
        Ok(())
    }
}
pub struct FloatDataArgs<'a> {
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
}
impl<'a> Default for FloatDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        FloatDataArgs {
            data: None, // required field
        }
    }
}

pub struct FloatDataBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FloatDataBuilder<'a, 'b> {
    #[inline]
    pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b, f32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(FloatData::VT_DATA, data);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FloatDataBuilder<'a, 'b> {
        let start = _fbb.start_table();
        FloatDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<FloatData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, FloatData::VT_DATA, "data");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for FloatData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("FloatData");
        ds.field("data", &self.data());
        ds.finish()
    }
}
pub enum IntDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct IntData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IntData<'a> {
    type Inner = IntData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> IntData<'a> {
    pub const VT_DATA: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        IntData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args IntDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<IntData<'bldr>> {
        let mut builder = IntDataBuilder::new(_fbb);
        if let Some(x) = args.data {
            builder.add_data(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn data(&self) -> flatbuffers::Vector<'a, i32> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(
                    IntData::VT_DATA,
                    None,
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for IntData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>(
                "data",
                Self::VT_DATA,
                true,
            )?
            .finish();
        Ok(())
    }
}
pub struct IntDataArgs<'a> {
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
}
impl<'a> Default for IntDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        IntDataArgs {
            data: None, // required field
        }
    }
}

pub struct IntDataBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> IntDataBuilder<'a, 'b> {
    #[inline]
    pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(IntData::VT_DATA, data);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> IntDataBuilder<'a, 'b> {
        let start = _fbb.start_table();
        IntDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<IntData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, IntData::VT_DATA, "data");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for IntData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("IntData");
        ds.field("data", &self.data());
        ds.finish()
    }
}
pub enum ConstantNodeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ConstantNode<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ConstantNode<'a> {
    type Inner = ConstantNode<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> ConstantNode<'a> {
    pub const VT_SHAPE: flatbuffers::VOffsetT = 4;
    pub const VT_DATA_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_DATA: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ConstantNode { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ConstantNodeArgs<'args>,
    ) -> flatbuffers::WIPOffset<ConstantNode<'bldr>> {
        let mut builder = ConstantNodeBuilder::new(_fbb);
        if let Some(x) = args.data {
            builder.add_data(x);
        }
        if let Some(x) = args.shape {
            builder.add_shape(x);
        }
        builder.add_data_type(args.data_type);
        builder.finish()
    }

    #[inline]
    pub fn shape(&self) -> flatbuffers::Vector<'a, u32> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    ConstantNode::VT_SHAPE,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn data_type(&self) -> ConstantData {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<ConstantData>(ConstantNode::VT_DATA_TYPE, Some(ConstantData::NONE))
                .unwrap()
        }
    }
    #[inline]
    pub fn data(&self) -> flatbuffers::Table<'a> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    ConstantNode::VT_DATA,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn data_as_float_data(&self) -> Option<FloatData<'a>> {
        if self.data_type() == ConstantData::FloatData {
            let u = self.data();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid union in this slot
            Some(unsafe { FloatData::init_from_table(u) })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn data_as_int_data(&self) -> Option<IntData<'a>> {
        if self.data_type() == ConstantData::IntData {
            let u = self.data();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid union in this slot
            Some(unsafe { IntData::init_from_table(u) })
        } else {
            None
        }
    }
}

impl flatbuffers::Verifiable for ConstantNode<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "shape",
                Self::VT_SHAPE,
                true,
            )?
            .visit_union::<ConstantData, _>(
                "data_type",
                Self::VT_DATA_TYPE,
                "data",
                Self::VT_DATA,
                true,
                |key, v, pos| match key {
                    ConstantData::FloatData => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<FloatData>>(
                            "ConstantData::FloatData",
                            pos,
                        ),
                    ConstantData::IntData => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<IntData>>(
                            "ConstantData::IntData",
                            pos,
                        ),
                    _ => Ok(()),
                },
            )?
            .finish();
        Ok(())
    }
}
pub struct ConstantNodeArgs<'a> {
    pub shape: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub data_type: ConstantData,
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for ConstantNodeArgs<'a> {
    #[inline]
    fn default() -> Self {
        ConstantNodeArgs {
            shape: None, // required field
            data_type: ConstantData::NONE,
            data: None, // required field
        }
    }
}

pub struct ConstantNodeBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ConstantNodeBuilder<'a, 'b> {
    #[inline]
    pub fn add_shape(&mut self, shape: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ConstantNode::VT_SHAPE, shape);
    }
    #[inline]
    pub fn add_data_type(&mut self, data_type: ConstantData) {
        self.fbb_.push_slot::<ConstantData>(
            ConstantNode::VT_DATA_TYPE,
            data_type,
            ConstantData::NONE,
        );
    }
    #[inline]
    pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ConstantNode::VT_DATA, data);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ConstantNodeBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ConstantNodeBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ConstantNode<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, ConstantNode::VT_SHAPE, "shape");
        self.fbb_.required(o, ConstantNode::VT_DATA, "data");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ConstantNode<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ConstantNode");
        ds.field("shape", &self.shape());
        ds.field("data_type", &self.data_type());
        match self.data_type() {
            ConstantData::FloatData => {
                if let Some(x) = self.data_as_float_data() {
                    ds.field("data", &x)
                } else {
                    ds.field(
                        "data",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            ConstantData::IntData => {
                if let Some(x) = self.data_as_int_data() {
                    ds.field("data", &x)
                } else {
                    ds.field(
                        "data",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("data", &x)
            }
        };
        ds.finish()
    }
}
pub enum DimOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Dim<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Dim<'a> {
    type Inner = Dim<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> Dim<'a> {
    pub const VT_VALUE: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Dim { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args DimArgs<'args>,
    ) -> flatbuffers::WIPOffset<Dim<'bldr>> {
        let mut builder = DimBuilder::new(_fbb);
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.add_value(args.value);
        builder.finish()
    }

    #[inline]
    pub fn value(&self) -> u32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<u32>(Dim::VT_VALUE, Some(0)).unwrap() }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Dim::VT_NAME, None)
        }
    }
}

impl flatbuffers::Verifiable for Dim<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<u32>("value", Self::VT_VALUE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .finish();
        Ok(())
    }
}
pub struct DimArgs<'a> {
    pub value: u32,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for DimArgs<'a> {
    #[inline]
    fn default() -> Self {
        DimArgs {
            value: 0,
            name: None,
        }
    }
}

pub struct DimBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DimBuilder<'a, 'b> {
    #[inline]
    pub fn add_value(&mut self, value: u32) {
        self.fbb_.push_slot::<u32>(Dim::VT_VALUE, value, 0);
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Dim::VT_NAME, name);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DimBuilder<'a, 'b> {
        let start = _fbb.start_table();
        DimBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Dim<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for Dim<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("Dim");
        ds.field("value", &self.value());
        ds.field("name", &self.name());
        ds.finish()
    }
}
pub enum ValueNodeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ValueNode<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ValueNode<'a> {
    type Inner = ValueNode<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> ValueNode<'a> {
    pub const VT_SHAPE: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ValueNode { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ValueNodeArgs<'args>,
    ) -> flatbuffers::WIPOffset<ValueNode<'bldr>> {
        let mut builder = ValueNodeBuilder::new(_fbb);
        if let Some(x) = args.shape {
            builder.add_shape(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn shape(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Dim<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Dim>>,
            >>(ValueNode::VT_SHAPE, None)
        }
    }
}

impl flatbuffers::Verifiable for ValueNode<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Dim>>,
            >>("shape", Self::VT_SHAPE, false)?
            .finish();
        Ok(())
    }
}
pub struct ValueNodeArgs<'a> {
    pub shape: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Dim<'a>>>>,
    >,
}
impl<'a> Default for ValueNodeArgs<'a> {
    #[inline]
    fn default() -> Self {
        ValueNodeArgs { shape: None }
    }
}

pub struct ValueNodeBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ValueNodeBuilder<'a, 'b> {
    #[inline]
    pub fn add_shape(
        &mut self,
        shape: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Dim<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ValueNode::VT_SHAPE, shape);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ValueNodeBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ValueNodeBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ValueNode<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ValueNode<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ValueNode");
        ds.field("shape", &self.shape());
        ds.finish()
    }
}
pub enum NodeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Node<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Node<'a> {
    type Inner = Node<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> Node<'a> {
    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_DATA_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_DATA: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Node { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args NodeArgs<'args>,
    ) -> flatbuffers::WIPOffset<Node<'bldr>> {
        let mut builder = NodeBuilder::new(_fbb);
        if let Some(x) = args.data {
            builder.add_data(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.add_data_type(args.data_type);
        builder.finish()
    }

    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Node::VT_NAME, None)
        }
    }
    #[inline]
    pub fn data_type(&self) -> NodeKind {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<NodeKind>(Node::VT_DATA_TYPE, Some(NodeKind::NONE))
                .unwrap()
        }
    }
    #[inline]
    pub fn data(&self) -> Option<flatbuffers::Table<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Node::VT_DATA, None)
        }
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn data_as_operator_node(&self) -> Option<OperatorNode<'a>> {
        if self.data_type() == NodeKind::OperatorNode {
            self.data().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { OperatorNode::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn data_as_constant_node(&self) -> Option<ConstantNode<'a>> {
        if self.data_type() == NodeKind::ConstantNode {
            self.data().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { ConstantNode::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn data_as_value_node(&self) -> Option<ValueNode<'a>> {
        if self.data_type() == NodeKind::ValueNode {
            self.data().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { ValueNode::init_from_table(t) }
            })
        } else {
            None
        }
    }
}

impl flatbuffers::Verifiable for Node<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_union::<NodeKind, _>(
                "data_type",
                Self::VT_DATA_TYPE,
                "data",
                Self::VT_DATA,
                false,
                |key, v, pos| match key {
                    NodeKind::OperatorNode => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<OperatorNode>>(
                            "NodeKind::OperatorNode",
                            pos,
                        ),
                    NodeKind::ConstantNode => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<ConstantNode>>(
                            "NodeKind::ConstantNode",
                            pos,
                        ),
                    NodeKind::ValueNode => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<ValueNode>>(
                            "NodeKind::ValueNode",
                            pos,
                        ),
                    _ => Ok(()),
                },
            )?
            .finish();
        Ok(())
    }
}
pub struct NodeArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub data_type: NodeKind,
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for NodeArgs<'a> {
    #[inline]
    fn default() -> Self {
        NodeArgs {
            name: None,
            data_type: NodeKind::NONE,
            data: None,
        }
    }
}

pub struct NodeBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> NodeBuilder<'a, 'b> {
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Node::VT_NAME, name);
    }
    #[inline]
    pub fn add_data_type(&mut self, data_type: NodeKind) {
        self.fbb_
            .push_slot::<NodeKind>(Node::VT_DATA_TYPE, data_type, NodeKind::NONE);
    }
    #[inline]
    pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Node::VT_DATA, data);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> NodeBuilder<'a, 'b> {
        let start = _fbb.start_table();
        NodeBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Node<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for Node<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("Node");
        ds.field("name", &self.name());
        ds.field("data_type", &self.data_type());
        match self.data_type() {
            NodeKind::OperatorNode => {
                if let Some(x) = self.data_as_operator_node() {
                    ds.field("data", &x)
                } else {
                    ds.field(
                        "data",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            NodeKind::ConstantNode => {
                if let Some(x) = self.data_as_constant_node() {
                    ds.field("data", &x)
                } else {
                    ds.field(
                        "data",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            NodeKind::ValueNode => {
                if let Some(x) = self.data_as_value_node() {
                    ds.field("data", &x)
                } else {
                    ds.field(
                        "data",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("data", &x)
            }
        };
        ds.finish()
    }
}
pub enum GraphOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Graph<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Graph<'a> {
    type Inner = Graph<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> Graph<'a> {
    pub const VT_NODES: flatbuffers::VOffsetT = 4;
    pub const VT_INPUTS: flatbuffers::VOffsetT = 6;
    pub const VT_OUTPUTS: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Graph { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GraphArgs<'args>,
    ) -> flatbuffers::WIPOffset<Graph<'bldr>> {
        let mut builder = GraphBuilder::new(_fbb);
        if let Some(x) = args.outputs {
            builder.add_outputs(x);
        }
        if let Some(x) = args.inputs {
            builder.add_inputs(x);
        }
        if let Some(x) = args.nodes {
            builder.add_nodes(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn nodes(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Node<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Node>>,
            >>(Graph::VT_NODES, None)
        }
    }
    #[inline]
    pub fn inputs(&self) -> Option<flatbuffers::Vector<'a, u32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    Graph::VT_INPUTS,
                    None,
                )
        }
    }
    #[inline]
    pub fn outputs(&self) -> Option<flatbuffers::Vector<'a, u32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    Graph::VT_OUTPUTS,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for Graph<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Node>>,
            >>("nodes", Self::VT_NODES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "inputs",
                Self::VT_INPUTS,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "outputs",
                Self::VT_OUTPUTS,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct GraphArgs<'a> {
    pub nodes: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Node<'a>>>>,
    >,
    pub inputs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub outputs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
}
impl<'a> Default for GraphArgs<'a> {
    #[inline]
    fn default() -> Self {
        GraphArgs {
            nodes: None,
            inputs: None,
            outputs: None,
        }
    }
}

pub struct GraphBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GraphBuilder<'a, 'b> {
    #[inline]
    pub fn add_nodes(
        &mut self,
        nodes: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Node<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Graph::VT_NODES, nodes);
    }
    #[inline]
    pub fn add_inputs(&mut self, inputs: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Graph::VT_INPUTS, inputs);
    }
    #[inline]
    pub fn add_outputs(&mut self, outputs: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Graph::VT_OUTPUTS, outputs);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GraphBuilder<'a, 'b> {
        let start = _fbb.start_table();
        GraphBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Graph<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for Graph<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("Graph");
        ds.field("nodes", &self.nodes());
        ds.field("inputs", &self.inputs());
        ds.field("outputs", &self.outputs());
        ds.finish()
    }
}
pub enum ModelOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Model<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Model<'a> {
    type Inner = Model<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> Model<'a> {
    pub const VT_SCHEMA_VERSION: flatbuffers::VOffsetT = 4;
    pub const VT_GRAPH: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Model { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ModelArgs<'args>,
    ) -> flatbuffers::WIPOffset<Model<'bldr>> {
        let mut builder = ModelBuilder::new(_fbb);
        if let Some(x) = args.graph {
            builder.add_graph(x);
        }
        builder.add_schema_version(args.schema_version);
        builder.finish()
    }

    #[inline]
    pub fn schema_version(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(Model::VT_SCHEMA_VERSION, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn graph(&self) -> Graph<'a> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Graph>>(Model::VT_GRAPH, None)
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for Model<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("schema_version", Self::VT_SCHEMA_VERSION, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<Graph>>("graph", Self::VT_GRAPH, true)?
            .finish();
        Ok(())
    }
}
pub struct ModelArgs<'a> {
    pub schema_version: i32,
    pub graph: Option<flatbuffers::WIPOffset<Graph<'a>>>,
}
impl<'a> Default for ModelArgs<'a> {
    #[inline]
    fn default() -> Self {
        ModelArgs {
            schema_version: 0,
            graph: None, // required field
        }
    }
}

pub struct ModelBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ModelBuilder<'a, 'b> {
    #[inline]
    pub fn add_schema_version(&mut self, schema_version: i32) {
        self.fbb_
            .push_slot::<i32>(Model::VT_SCHEMA_VERSION, schema_version, 0);
    }
    #[inline]
    pub fn add_graph(&mut self, graph: flatbuffers::WIPOffset<Graph<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<Graph>>(Model::VT_GRAPH, graph);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ModelBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ModelBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Model<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, Model::VT_GRAPH, "graph");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for Model<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("Model");
        ds.field("schema_version", &self.schema_version());
        ds.field("graph", &self.graph());
        ds.finish()
    }
}
#[inline]
/// Verifies that a buffer of bytes contains a `Model`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_model_unchecked`.
pub fn root_as_model(buf: &[u8]) -> Result<Model, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root::<Model>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Model` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_model_unchecked`.
pub fn size_prefixed_root_as_model(buf: &[u8]) -> Result<Model, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root::<Model>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Model` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_model_unchecked`.
pub fn root_as_model_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<Model<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root_with_opts::<Model<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Model` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_model_unchecked`.
pub fn size_prefixed_root_as_model_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<Model<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root_with_opts::<Model<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Model and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Model`.
pub unsafe fn root_as_model_unchecked(buf: &[u8]) -> Model {
    flatbuffers::root_unchecked::<Model>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Model and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Model`.
pub unsafe fn size_prefixed_root_as_model_unchecked(buf: &[u8]) -> Model {
    flatbuffers::size_prefixed_root_unchecked::<Model>(buf)
}
pub const MODEL_IDENTIFIER: &str = "MODL";

#[inline]
pub fn model_buffer_has_identifier(buf: &[u8]) -> bool {
    flatbuffers::buffer_has_identifier(buf, MODEL_IDENTIFIER, false)
}

#[inline]
pub fn model_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
    flatbuffers::buffer_has_identifier(buf, MODEL_IDENTIFIER, true)
}

pub const MODEL_EXTENSION: &str = "model";

#[inline]
pub fn finish_model_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<Model<'a>>,
) {
    fbb.finish(root, Some(MODEL_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_model_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<Model<'a>>,
) {
    fbb.finish_size_prefixed(root, Some(MODEL_IDENTIFIER));
}
