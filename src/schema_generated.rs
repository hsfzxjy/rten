#![allow(clippy::all)]
// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_OPERATOR_TYPE: i8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_OPERATOR_TYPE: i8 = 30;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_OPERATOR_TYPE: [OperatorType; 31] = [
    OperatorType::Add,
    OperatorType::AveragePool2d,
    OperatorType::BatchNormalization,
    OperatorType::Cast,
    OperatorType::Clip,
    OperatorType::Concat,
    OperatorType::ConstantOfShape,
    OperatorType::Conv2d,
    OperatorType::ConvTranspose2d,
    OperatorType::Div,
    OperatorType::Gather,
    OperatorType::Gemm,
    OperatorType::GlobalAveragePool,
    OperatorType::Identity,
    OperatorType::LeakyRelu,
    OperatorType::MatMul,
    OperatorType::MaxPool2d,
    OperatorType::Mul,
    OperatorType::Pad,
    OperatorType::Relu,
    OperatorType::Reshape,
    OperatorType::Shape,
    OperatorType::Sigmoid,
    OperatorType::Slice,
    OperatorType::Split,
    OperatorType::Sqrt,
    OperatorType::Squeeze,
    OperatorType::Softmax,
    OperatorType::Sub,
    OperatorType::Transpose,
    OperatorType::Unsqueeze,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct OperatorType(pub i8);
#[allow(non_upper_case_globals)]
impl OperatorType {
    pub const Add: Self = Self(0);
    pub const AveragePool2d: Self = Self(1);
    pub const BatchNormalization: Self = Self(2);
    pub const Cast: Self = Self(3);
    pub const Clip: Self = Self(4);
    pub const Concat: Self = Self(5);
    pub const ConstantOfShape: Self = Self(6);
    pub const Conv2d: Self = Self(7);
    pub const ConvTranspose2d: Self = Self(8);
    pub const Div: Self = Self(9);
    pub const Gather: Self = Self(10);
    pub const Gemm: Self = Self(11);
    pub const GlobalAveragePool: Self = Self(12);
    pub const Identity: Self = Self(13);
    pub const LeakyRelu: Self = Self(14);
    pub const MatMul: Self = Self(15);
    pub const MaxPool2d: Self = Self(16);
    pub const Mul: Self = Self(17);
    pub const Pad: Self = Self(18);
    pub const Relu: Self = Self(19);
    pub const Reshape: Self = Self(20);
    pub const Shape: Self = Self(21);
    pub const Sigmoid: Self = Self(22);
    pub const Slice: Self = Self(23);
    pub const Split: Self = Self(24);
    pub const Sqrt: Self = Self(25);
    pub const Squeeze: Self = Self(26);
    pub const Softmax: Self = Self(27);
    pub const Sub: Self = Self(28);
    pub const Transpose: Self = Self(29);
    pub const Unsqueeze: Self = Self(30);

    pub const ENUM_MIN: i8 = 0;
    pub const ENUM_MAX: i8 = 30;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::Add,
        Self::AveragePool2d,
        Self::BatchNormalization,
        Self::Cast,
        Self::Clip,
        Self::Concat,
        Self::ConstantOfShape,
        Self::Conv2d,
        Self::ConvTranspose2d,
        Self::Div,
        Self::Gather,
        Self::Gemm,
        Self::GlobalAveragePool,
        Self::Identity,
        Self::LeakyRelu,
        Self::MatMul,
        Self::MaxPool2d,
        Self::Mul,
        Self::Pad,
        Self::Relu,
        Self::Reshape,
        Self::Shape,
        Self::Sigmoid,
        Self::Slice,
        Self::Split,
        Self::Sqrt,
        Self::Squeeze,
        Self::Softmax,
        Self::Sub,
        Self::Transpose,
        Self::Unsqueeze,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::Add => Some("Add"),
            Self::AveragePool2d => Some("AveragePool2d"),
            Self::BatchNormalization => Some("BatchNormalization"),
            Self::Cast => Some("Cast"),
            Self::Clip => Some("Clip"),
            Self::Concat => Some("Concat"),
            Self::ConstantOfShape => Some("ConstantOfShape"),
            Self::Conv2d => Some("Conv2d"),
            Self::ConvTranspose2d => Some("ConvTranspose2d"),
            Self::Div => Some("Div"),
            Self::Gather => Some("Gather"),
            Self::Gemm => Some("Gemm"),
            Self::GlobalAveragePool => Some("GlobalAveragePool"),
            Self::Identity => Some("Identity"),
            Self::LeakyRelu => Some("LeakyRelu"),
            Self::MatMul => Some("MatMul"),
            Self::MaxPool2d => Some("MaxPool2d"),
            Self::Mul => Some("Mul"),
            Self::Pad => Some("Pad"),
            Self::Relu => Some("Relu"),
            Self::Reshape => Some("Reshape"),
            Self::Shape => Some("Shape"),
            Self::Sigmoid => Some("Sigmoid"),
            Self::Slice => Some("Slice"),
            Self::Split => Some("Split"),
            Self::Sqrt => Some("Sqrt"),
            Self::Squeeze => Some("Squeeze"),
            Self::Softmax => Some("Softmax"),
            Self::Sub => Some("Sub"),
            Self::Transpose => Some("Transpose"),
            Self::Unsqueeze => Some("Unsqueeze"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for OperatorType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for OperatorType {
    type Inner = Self;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i8>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for OperatorType {
    type Output = OperatorType;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe {
            flatbuffers::emplace_scalar::<i8>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for OperatorType {
    #[inline]
    fn to_little_endian(self) -> Self {
        let b = i8::to_le(self.0);
        Self(b)
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(self) -> Self {
        let b = i8::from_le(self.0);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for OperatorType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for OperatorType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_PAD_MODE: i8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_PAD_MODE: i8 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_PAD_MODE: [PadMode; 2] = [PadMode::Same, PadMode::Fixed];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct PadMode(pub i8);
#[allow(non_upper_case_globals)]
impl PadMode {
    pub const Same: Self = Self(0);
    pub const Fixed: Self = Self(1);

    pub const ENUM_MIN: i8 = 0;
    pub const ENUM_MAX: i8 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::Same, Self::Fixed];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::Same => Some("Same"),
            Self::Fixed => Some("Fixed"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for PadMode {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for PadMode {
    type Inner = Self;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i8>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for PadMode {
    type Output = PadMode;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe {
            flatbuffers::emplace_scalar::<i8>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for PadMode {
    #[inline]
    fn to_little_endian(self) -> Self {
        let b = i8::to_le(self.0);
        Self(b)
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(self) -> Self {
        let b = i8::from_le(self.0);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for PadMode {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for PadMode {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_DATA_TYPE: i8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_DATA_TYPE: i8 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DATA_TYPE: [DataType; 2] = [DataType::Int32, DataType::Float];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct DataType(pub i8);
#[allow(non_upper_case_globals)]
impl DataType {
    pub const Int32: Self = Self(0);
    pub const Float: Self = Self(1);

    pub const ENUM_MIN: i8 = 0;
    pub const ENUM_MAX: i8 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::Int32, Self::Float];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::Int32 => Some("Int32"),
            Self::Float => Some("Float"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for DataType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for DataType {
    type Inner = Self;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i8>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for DataType {
    type Output = DataType;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe {
            flatbuffers::emplace_scalar::<i8>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for DataType {
    #[inline]
    fn to_little_endian(self) -> Self {
        let b = i8::to_le(self.0);
        Self(b)
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(self) -> Self {
        let b = i8::from_le(self.0);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for DataType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for DataType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_OPERATOR_ATTRS: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_OPERATOR_ATTRS: u8 = 18;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_OPERATOR_ATTRS: [OperatorAttrs; 19] = [
    OperatorAttrs::NONE,
    OperatorAttrs::AveragePool2dAttrs,
    OperatorAttrs::BatchNormalizationAttrs,
    OperatorAttrs::CastAttrs,
    OperatorAttrs::ClipAttrs,
    OperatorAttrs::ConcatAttrs,
    OperatorAttrs::ConstantOfShapeAttrs,
    OperatorAttrs::Conv2dAttrs,
    OperatorAttrs::ConvTranspose2dAttrs,
    OperatorAttrs::GatherAttrs,
    OperatorAttrs::GemmAttrs,
    OperatorAttrs::LeakyReluAttrs,
    OperatorAttrs::MaxPool2dAttrs,
    OperatorAttrs::PadAttrs,
    OperatorAttrs::SplitAttrs,
    OperatorAttrs::SqueezeAttrs,
    OperatorAttrs::SoftmaxAttrs,
    OperatorAttrs::TransposeAttrs,
    OperatorAttrs::UnsqueezeAttrs,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct OperatorAttrs(pub u8);
#[allow(non_upper_case_globals)]
impl OperatorAttrs {
    pub const NONE: Self = Self(0);
    pub const AveragePool2dAttrs: Self = Self(1);
    pub const BatchNormalizationAttrs: Self = Self(2);
    pub const CastAttrs: Self = Self(3);
    pub const ClipAttrs: Self = Self(4);
    pub const ConcatAttrs: Self = Self(5);
    pub const ConstantOfShapeAttrs: Self = Self(6);
    pub const Conv2dAttrs: Self = Self(7);
    pub const ConvTranspose2dAttrs: Self = Self(8);
    pub const GatherAttrs: Self = Self(9);
    pub const GemmAttrs: Self = Self(10);
    pub const LeakyReluAttrs: Self = Self(11);
    pub const MaxPool2dAttrs: Self = Self(12);
    pub const PadAttrs: Self = Self(13);
    pub const SplitAttrs: Self = Self(14);
    pub const SqueezeAttrs: Self = Self(15);
    pub const SoftmaxAttrs: Self = Self(16);
    pub const TransposeAttrs: Self = Self(17);
    pub const UnsqueezeAttrs: Self = Self(18);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 18;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::AveragePool2dAttrs,
        Self::BatchNormalizationAttrs,
        Self::CastAttrs,
        Self::ClipAttrs,
        Self::ConcatAttrs,
        Self::ConstantOfShapeAttrs,
        Self::Conv2dAttrs,
        Self::ConvTranspose2dAttrs,
        Self::GatherAttrs,
        Self::GemmAttrs,
        Self::LeakyReluAttrs,
        Self::MaxPool2dAttrs,
        Self::PadAttrs,
        Self::SplitAttrs,
        Self::SqueezeAttrs,
        Self::SoftmaxAttrs,
        Self::TransposeAttrs,
        Self::UnsqueezeAttrs,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::AveragePool2dAttrs => Some("AveragePool2dAttrs"),
            Self::BatchNormalizationAttrs => Some("BatchNormalizationAttrs"),
            Self::CastAttrs => Some("CastAttrs"),
            Self::ClipAttrs => Some("ClipAttrs"),
            Self::ConcatAttrs => Some("ConcatAttrs"),
            Self::ConstantOfShapeAttrs => Some("ConstantOfShapeAttrs"),
            Self::Conv2dAttrs => Some("Conv2dAttrs"),
            Self::ConvTranspose2dAttrs => Some("ConvTranspose2dAttrs"),
            Self::GatherAttrs => Some("GatherAttrs"),
            Self::GemmAttrs => Some("GemmAttrs"),
            Self::LeakyReluAttrs => Some("LeakyReluAttrs"),
            Self::MaxPool2dAttrs => Some("MaxPool2dAttrs"),
            Self::PadAttrs => Some("PadAttrs"),
            Self::SplitAttrs => Some("SplitAttrs"),
            Self::SqueezeAttrs => Some("SqueezeAttrs"),
            Self::SoftmaxAttrs => Some("SoftmaxAttrs"),
            Self::TransposeAttrs => Some("TransposeAttrs"),
            Self::UnsqueezeAttrs => Some("UnsqueezeAttrs"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for OperatorAttrs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for OperatorAttrs {
    type Inner = Self;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for OperatorAttrs {
    type Output = OperatorAttrs;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for OperatorAttrs {
    #[inline]
    fn to_little_endian(self) -> Self {
        let b = u8::to_le(self.0);
        Self(b)
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(self) -> Self {
        let b = u8::from_le(self.0);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for OperatorAttrs {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for OperatorAttrs {}
pub struct OperatorAttrsUnionTableOffset {}

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_NODE_KIND: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_NODE_KIND: u8 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_NODE_KIND: [NodeKind; 4] = [
    NodeKind::NONE,
    NodeKind::OperatorNode,
    NodeKind::ConstantNode,
    NodeKind::ValueNode,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct NodeKind(pub u8);
#[allow(non_upper_case_globals)]
impl NodeKind {
    pub const NONE: Self = Self(0);
    pub const OperatorNode: Self = Self(1);
    pub const ConstantNode: Self = Self(2);
    pub const ValueNode: Self = Self(3);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 3;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::OperatorNode,
        Self::ConstantNode,
        Self::ValueNode,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::OperatorNode => Some("OperatorNode"),
            Self::ConstantNode => Some("ConstantNode"),
            Self::ValueNode => Some("ValueNode"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for NodeKind {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for NodeKind {
    type Inner = Self;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for NodeKind {
    type Output = NodeKind;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for NodeKind {
    #[inline]
    fn to_little_endian(self) -> Self {
        let b = u8::to_le(self.0);
        Self(b)
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(self) -> Self {
        let b = u8::from_le(self.0);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for NodeKind {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for NodeKind {}
pub struct NodeKindUnionTableOffset {}

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_CONSTANT_DATA: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_CONSTANT_DATA: u8 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_CONSTANT_DATA: [ConstantData; 3] = [
    ConstantData::NONE,
    ConstantData::FloatData,
    ConstantData::IntData,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ConstantData(pub u8);
#[allow(non_upper_case_globals)]
impl ConstantData {
    pub const NONE: Self = Self(0);
    pub const FloatData: Self = Self(1);
    pub const IntData: Self = Self(2);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::FloatData, Self::IntData];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::FloatData => Some("FloatData"),
            Self::IntData => Some("IntData"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for ConstantData {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for ConstantData {
    type Inner = Self;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for ConstantData {
    type Output = ConstantData;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for ConstantData {
    #[inline]
    fn to_little_endian(self) -> Self {
        let b = u8::to_le(self.0);
        Self(b)
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(self) -> Self {
        let b = u8::from_le(self.0);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for ConstantData {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for ConstantData {}
pub struct ConstantDataUnionTableOffset {}

pub enum AveragePool2dAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AveragePool2dAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AveragePool2dAttrs<'a> {
    type Inner = AveragePool2dAttrs<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> AveragePool2dAttrs<'a> {
    pub const VT_KERNEL_SIZE: flatbuffers::VOffsetT = 4;
    pub const VT_PAD_MODE: flatbuffers::VOffsetT = 6;
    pub const VT_PADS: flatbuffers::VOffsetT = 8;
    pub const VT_STRIDE: flatbuffers::VOffsetT = 10;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        AveragePool2dAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args AveragePool2dAttrsArgs<'args>,
    ) -> flatbuffers::WIPOffset<AveragePool2dAttrs<'bldr>> {
        let mut builder = AveragePool2dAttrsBuilder::new(_fbb);
        builder.add_stride(args.stride);
        if let Some(x) = args.pads {
            builder.add_pads(x);
        }
        builder.add_kernel_size(args.kernel_size);
        builder.add_pad_mode(args.pad_mode);
        builder.finish()
    }

    #[inline]
    pub fn kernel_size(&self) -> u32 {
        self._tab
            .get::<u32>(AveragePool2dAttrs::VT_KERNEL_SIZE, Some(0))
            .unwrap()
    }
    #[inline]
    pub fn pad_mode(&self) -> PadMode {
        self._tab
            .get::<PadMode>(AveragePool2dAttrs::VT_PAD_MODE, Some(PadMode::Same))
            .unwrap()
    }
    #[inline]
    pub fn pads(&self) -> Option<flatbuffers::Vector<'a, u32>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                AveragePool2dAttrs::VT_PADS,
                None,
            )
    }
    #[inline]
    pub fn stride(&self) -> u32 {
        self._tab
            .get::<u32>(AveragePool2dAttrs::VT_STRIDE, Some(0))
            .unwrap()
    }
}

impl flatbuffers::Verifiable for AveragePool2dAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<u32>("kernel_size", Self::VT_KERNEL_SIZE, false)?
            .visit_field::<PadMode>("pad_mode", Self::VT_PAD_MODE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "pads",
                Self::VT_PADS,
                false,
            )?
            .visit_field::<u32>("stride", Self::VT_STRIDE, false)?
            .finish();
        Ok(())
    }
}
pub struct AveragePool2dAttrsArgs<'a> {
    pub kernel_size: u32,
    pub pad_mode: PadMode,
    pub pads: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub stride: u32,
}
impl<'a> Default for AveragePool2dAttrsArgs<'a> {
    #[inline]
    fn default() -> Self {
        AveragePool2dAttrsArgs {
            kernel_size: 0,
            pad_mode: PadMode::Same,
            pads: None,
            stride: 0,
        }
    }
}

pub struct AveragePool2dAttrsBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AveragePool2dAttrsBuilder<'a, 'b> {
    #[inline]
    pub fn add_kernel_size(&mut self, kernel_size: u32) {
        self.fbb_
            .push_slot::<u32>(AveragePool2dAttrs::VT_KERNEL_SIZE, kernel_size, 0);
    }
    #[inline]
    pub fn add_pad_mode(&mut self, pad_mode: PadMode) {
        self.fbb_
            .push_slot::<PadMode>(AveragePool2dAttrs::VT_PAD_MODE, pad_mode, PadMode::Same);
    }
    #[inline]
    pub fn add_pads(&mut self, pads: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(AveragePool2dAttrs::VT_PADS, pads);
    }
    #[inline]
    pub fn add_stride(&mut self, stride: u32) {
        self.fbb_
            .push_slot::<u32>(AveragePool2dAttrs::VT_STRIDE, stride, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> AveragePool2dAttrsBuilder<'a, 'b> {
        let start = _fbb.start_table();
        AveragePool2dAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<AveragePool2dAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for AveragePool2dAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("AveragePool2dAttrs");
        ds.field("kernel_size", &self.kernel_size());
        ds.field("pad_mode", &self.pad_mode());
        ds.field("pads", &self.pads());
        ds.field("stride", &self.stride());
        ds.finish()
    }
}
pub enum BatchNormalizationAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BatchNormalizationAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BatchNormalizationAttrs<'a> {
    type Inner = BatchNormalizationAttrs<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> BatchNormalizationAttrs<'a> {
    pub const VT_EPSILON: flatbuffers::VOffsetT = 4;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        BatchNormalizationAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args BatchNormalizationAttrsArgs,
    ) -> flatbuffers::WIPOffset<BatchNormalizationAttrs<'bldr>> {
        let mut builder = BatchNormalizationAttrsBuilder::new(_fbb);
        builder.add_epsilon(args.epsilon);
        builder.finish()
    }

    #[inline]
    pub fn epsilon(&self) -> f32 {
        self._tab
            .get::<f32>(BatchNormalizationAttrs::VT_EPSILON, Some(0.0))
            .unwrap()
    }
}

impl flatbuffers::Verifiable for BatchNormalizationAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<f32>("epsilon", Self::VT_EPSILON, false)?
            .finish();
        Ok(())
    }
}
pub struct BatchNormalizationAttrsArgs {
    pub epsilon: f32,
}
impl<'a> Default for BatchNormalizationAttrsArgs {
    #[inline]
    fn default() -> Self {
        BatchNormalizationAttrsArgs { epsilon: 0.0 }
    }
}

pub struct BatchNormalizationAttrsBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BatchNormalizationAttrsBuilder<'a, 'b> {
    #[inline]
    pub fn add_epsilon(&mut self, epsilon: f32) {
        self.fbb_
            .push_slot::<f32>(BatchNormalizationAttrs::VT_EPSILON, epsilon, 0.0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> BatchNormalizationAttrsBuilder<'a, 'b> {
        let start = _fbb.start_table();
        BatchNormalizationAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<BatchNormalizationAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for BatchNormalizationAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("BatchNormalizationAttrs");
        ds.field("epsilon", &self.epsilon());
        ds.finish()
    }
}
pub enum CastAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CastAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CastAttrs<'a> {
    type Inner = CastAttrs<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> CastAttrs<'a> {
    pub const VT_TO: flatbuffers::VOffsetT = 4;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        CastAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args CastAttrsArgs,
    ) -> flatbuffers::WIPOffset<CastAttrs<'bldr>> {
        let mut builder = CastAttrsBuilder::new(_fbb);
        builder.add_to(args.to);
        builder.finish()
    }

    #[inline]
    pub fn to(&self) -> DataType {
        self._tab
            .get::<DataType>(CastAttrs::VT_TO, Some(DataType::Int32))
            .unwrap()
    }
}

impl flatbuffers::Verifiable for CastAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<DataType>("to", Self::VT_TO, false)?
            .finish();
        Ok(())
    }
}
pub struct CastAttrsArgs {
    pub to: DataType,
}
impl<'a> Default for CastAttrsArgs {
    #[inline]
    fn default() -> Self {
        CastAttrsArgs {
            to: DataType::Int32,
        }
    }
}

pub struct CastAttrsBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CastAttrsBuilder<'a, 'b> {
    #[inline]
    pub fn add_to(&mut self, to: DataType) {
        self.fbb_
            .push_slot::<DataType>(CastAttrs::VT_TO, to, DataType::Int32);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CastAttrsBuilder<'a, 'b> {
        let start = _fbb.start_table();
        CastAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<CastAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for CastAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("CastAttrs");
        ds.field("to", &self.to());
        ds.finish()
    }
}
pub enum ClipAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ClipAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ClipAttrs<'a> {
    type Inner = ClipAttrs<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> ClipAttrs<'a> {
    pub const VT_MIN: flatbuffers::VOffsetT = 4;
    pub const VT_MAX: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ClipAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ClipAttrsArgs,
    ) -> flatbuffers::WIPOffset<ClipAttrs<'bldr>> {
        let mut builder = ClipAttrsBuilder::new(_fbb);
        builder.add_max(args.max);
        builder.add_min(args.min);
        builder.finish()
    }

    #[inline]
    pub fn min(&self) -> f32 {
        self._tab.get::<f32>(ClipAttrs::VT_MIN, Some(0.0)).unwrap()
    }
    #[inline]
    pub fn max(&self) -> f32 {
        self._tab.get::<f32>(ClipAttrs::VT_MAX, Some(0.0)).unwrap()
    }
}

impl flatbuffers::Verifiable for ClipAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<f32>("min", Self::VT_MIN, false)?
            .visit_field::<f32>("max", Self::VT_MAX, false)?
            .finish();
        Ok(())
    }
}
pub struct ClipAttrsArgs {
    pub min: f32,
    pub max: f32,
}
impl<'a> Default for ClipAttrsArgs {
    #[inline]
    fn default() -> Self {
        ClipAttrsArgs { min: 0.0, max: 0.0 }
    }
}

pub struct ClipAttrsBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ClipAttrsBuilder<'a, 'b> {
    #[inline]
    pub fn add_min(&mut self, min: f32) {
        self.fbb_.push_slot::<f32>(ClipAttrs::VT_MIN, min, 0.0);
    }
    #[inline]
    pub fn add_max(&mut self, max: f32) {
        self.fbb_.push_slot::<f32>(ClipAttrs::VT_MAX, max, 0.0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ClipAttrsBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ClipAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ClipAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ClipAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ClipAttrs");
        ds.field("min", &self.min());
        ds.field("max", &self.max());
        ds.finish()
    }
}
pub enum ConcatAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ConcatAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ConcatAttrs<'a> {
    type Inner = ConcatAttrs<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> ConcatAttrs<'a> {
    pub const VT_DIM: flatbuffers::VOffsetT = 4;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ConcatAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ConcatAttrsArgs,
    ) -> flatbuffers::WIPOffset<ConcatAttrs<'bldr>> {
        let mut builder = ConcatAttrsBuilder::new(_fbb);
        builder.add_dim(args.dim);
        builder.finish()
    }

    #[inline]
    pub fn dim(&self) -> u32 {
        self._tab.get::<u32>(ConcatAttrs::VT_DIM, Some(0)).unwrap()
    }
}

impl flatbuffers::Verifiable for ConcatAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<u32>("dim", Self::VT_DIM, false)?
            .finish();
        Ok(())
    }
}
pub struct ConcatAttrsArgs {
    pub dim: u32,
}
impl<'a> Default for ConcatAttrsArgs {
    #[inline]
    fn default() -> Self {
        ConcatAttrsArgs { dim: 0 }
    }
}

pub struct ConcatAttrsBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ConcatAttrsBuilder<'a, 'b> {
    #[inline]
    pub fn add_dim(&mut self, dim: u32) {
        self.fbb_.push_slot::<u32>(ConcatAttrs::VT_DIM, dim, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ConcatAttrsBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ConcatAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ConcatAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ConcatAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ConcatAttrs");
        ds.field("dim", &self.dim());
        ds.finish()
    }
}
pub enum ConstantOfShapeAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ConstantOfShapeAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ConstantOfShapeAttrs<'a> {
    type Inner = ConstantOfShapeAttrs<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> ConstantOfShapeAttrs<'a> {
    pub const VT_INT_VALUE: flatbuffers::VOffsetT = 4;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ConstantOfShapeAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ConstantOfShapeAttrsArgs,
    ) -> flatbuffers::WIPOffset<ConstantOfShapeAttrs<'bldr>> {
        let mut builder = ConstantOfShapeAttrsBuilder::new(_fbb);
        builder.add_int_value(args.int_value);
        builder.finish()
    }

    #[inline]
    pub fn int_value(&self) -> i32 {
        self._tab
            .get::<i32>(ConstantOfShapeAttrs::VT_INT_VALUE, Some(0))
            .unwrap()
    }
}

impl flatbuffers::Verifiable for ConstantOfShapeAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("int_value", Self::VT_INT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct ConstantOfShapeAttrsArgs {
    pub int_value: i32,
}
impl<'a> Default for ConstantOfShapeAttrsArgs {
    #[inline]
    fn default() -> Self {
        ConstantOfShapeAttrsArgs { int_value: 0 }
    }
}

pub struct ConstantOfShapeAttrsBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ConstantOfShapeAttrsBuilder<'a, 'b> {
    #[inline]
    pub fn add_int_value(&mut self, int_value: i32) {
        self.fbb_
            .push_slot::<i32>(ConstantOfShapeAttrs::VT_INT_VALUE, int_value, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> ConstantOfShapeAttrsBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ConstantOfShapeAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ConstantOfShapeAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ConstantOfShapeAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ConstantOfShapeAttrs");
        ds.field("int_value", &self.int_value());
        ds.finish()
    }
}
pub enum Conv2dAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Conv2dAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Conv2dAttrs<'a> {
    type Inner = Conv2dAttrs<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> Conv2dAttrs<'a> {
    pub const VT_PAD_MODE: flatbuffers::VOffsetT = 4;
    pub const VT_PADS: flatbuffers::VOffsetT = 6;
    pub const VT_GROUPS: flatbuffers::VOffsetT = 8;
    pub const VT_STRIDE: flatbuffers::VOffsetT = 10;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Conv2dAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args Conv2dAttrsArgs<'args>,
    ) -> flatbuffers::WIPOffset<Conv2dAttrs<'bldr>> {
        let mut builder = Conv2dAttrsBuilder::new(_fbb);
        builder.add_stride(args.stride);
        builder.add_groups(args.groups);
        if let Some(x) = args.pads {
            builder.add_pads(x);
        }
        builder.add_pad_mode(args.pad_mode);
        builder.finish()
    }

    #[inline]
    pub fn pad_mode(&self) -> PadMode {
        self._tab
            .get::<PadMode>(Conv2dAttrs::VT_PAD_MODE, Some(PadMode::Same))
            .unwrap()
    }
    #[inline]
    pub fn pads(&self) -> Option<flatbuffers::Vector<'a, u32>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                Conv2dAttrs::VT_PADS,
                None,
            )
    }
    #[inline]
    pub fn groups(&self) -> u32 {
        self._tab
            .get::<u32>(Conv2dAttrs::VT_GROUPS, Some(0))
            .unwrap()
    }
    #[inline]
    pub fn stride(&self) -> u32 {
        self._tab
            .get::<u32>(Conv2dAttrs::VT_STRIDE, Some(0))
            .unwrap()
    }
}

impl flatbuffers::Verifiable for Conv2dAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<PadMode>("pad_mode", Self::VT_PAD_MODE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "pads",
                Self::VT_PADS,
                false,
            )?
            .visit_field::<u32>("groups", Self::VT_GROUPS, false)?
            .visit_field::<u32>("stride", Self::VT_STRIDE, false)?
            .finish();
        Ok(())
    }
}
pub struct Conv2dAttrsArgs<'a> {
    pub pad_mode: PadMode,
    pub pads: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub groups: u32,
    pub stride: u32,
}
impl<'a> Default for Conv2dAttrsArgs<'a> {
    #[inline]
    fn default() -> Self {
        Conv2dAttrsArgs {
            pad_mode: PadMode::Same,
            pads: None,
            groups: 0,
            stride: 0,
        }
    }
}

pub struct Conv2dAttrsBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> Conv2dAttrsBuilder<'a, 'b> {
    #[inline]
    pub fn add_pad_mode(&mut self, pad_mode: PadMode) {
        self.fbb_
            .push_slot::<PadMode>(Conv2dAttrs::VT_PAD_MODE, pad_mode, PadMode::Same);
    }
    #[inline]
    pub fn add_pads(&mut self, pads: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Conv2dAttrs::VT_PADS, pads);
    }
    #[inline]
    pub fn add_groups(&mut self, groups: u32) {
        self.fbb_
            .push_slot::<u32>(Conv2dAttrs::VT_GROUPS, groups, 0);
    }
    #[inline]
    pub fn add_stride(&mut self, stride: u32) {
        self.fbb_
            .push_slot::<u32>(Conv2dAttrs::VT_STRIDE, stride, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> Conv2dAttrsBuilder<'a, 'b> {
        let start = _fbb.start_table();
        Conv2dAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Conv2dAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for Conv2dAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("Conv2dAttrs");
        ds.field("pad_mode", &self.pad_mode());
        ds.field("pads", &self.pads());
        ds.field("groups", &self.groups());
        ds.field("stride", &self.stride());
        ds.finish()
    }
}
pub enum ConvTranspose2dAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ConvTranspose2dAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ConvTranspose2dAttrs<'a> {
    type Inner = ConvTranspose2dAttrs<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> ConvTranspose2dAttrs<'a> {
    pub const VT_STRIDE: flatbuffers::VOffsetT = 4;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ConvTranspose2dAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ConvTranspose2dAttrsArgs,
    ) -> flatbuffers::WIPOffset<ConvTranspose2dAttrs<'bldr>> {
        let mut builder = ConvTranspose2dAttrsBuilder::new(_fbb);
        builder.add_stride(args.stride);
        builder.finish()
    }

    #[inline]
    pub fn stride(&self) -> u32 {
        self._tab
            .get::<u32>(ConvTranspose2dAttrs::VT_STRIDE, Some(0))
            .unwrap()
    }
}

impl flatbuffers::Verifiable for ConvTranspose2dAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<u32>("stride", Self::VT_STRIDE, false)?
            .finish();
        Ok(())
    }
}
pub struct ConvTranspose2dAttrsArgs {
    pub stride: u32,
}
impl<'a> Default for ConvTranspose2dAttrsArgs {
    #[inline]
    fn default() -> Self {
        ConvTranspose2dAttrsArgs { stride: 0 }
    }
}

pub struct ConvTranspose2dAttrsBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ConvTranspose2dAttrsBuilder<'a, 'b> {
    #[inline]
    pub fn add_stride(&mut self, stride: u32) {
        self.fbb_
            .push_slot::<u32>(ConvTranspose2dAttrs::VT_STRIDE, stride, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> ConvTranspose2dAttrsBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ConvTranspose2dAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ConvTranspose2dAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ConvTranspose2dAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ConvTranspose2dAttrs");
        ds.field("stride", &self.stride());
        ds.finish()
    }
}
pub enum GatherAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GatherAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GatherAttrs<'a> {
    type Inner = GatherAttrs<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> GatherAttrs<'a> {
    pub const VT_AXIS: flatbuffers::VOffsetT = 4;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GatherAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GatherAttrsArgs,
    ) -> flatbuffers::WIPOffset<GatherAttrs<'bldr>> {
        let mut builder = GatherAttrsBuilder::new(_fbb);
        builder.add_axis(args.axis);
        builder.finish()
    }

    #[inline]
    pub fn axis(&self) -> u32 {
        self._tab.get::<u32>(GatherAttrs::VT_AXIS, Some(0)).unwrap()
    }
}

impl flatbuffers::Verifiable for GatherAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<u32>("axis", Self::VT_AXIS, false)?
            .finish();
        Ok(())
    }
}
pub struct GatherAttrsArgs {
    pub axis: u32,
}
impl<'a> Default for GatherAttrsArgs {
    #[inline]
    fn default() -> Self {
        GatherAttrsArgs { axis: 0 }
    }
}

pub struct GatherAttrsBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GatherAttrsBuilder<'a, 'b> {
    #[inline]
    pub fn add_axis(&mut self, axis: u32) {
        self.fbb_.push_slot::<u32>(GatherAttrs::VT_AXIS, axis, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GatherAttrsBuilder<'a, 'b> {
        let start = _fbb.start_table();
        GatherAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<GatherAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for GatherAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("GatherAttrs");
        ds.field("axis", &self.axis());
        ds.finish()
    }
}
pub enum GemmAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GemmAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GemmAttrs<'a> {
    type Inner = GemmAttrs<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> GemmAttrs<'a> {
    pub const VT_ALPHA: flatbuffers::VOffsetT = 4;
    pub const VT_BETA: flatbuffers::VOffsetT = 6;
    pub const VT_TRANSPOSE_A: flatbuffers::VOffsetT = 8;
    pub const VT_TRANSPOSE_B: flatbuffers::VOffsetT = 10;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GemmAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GemmAttrsArgs,
    ) -> flatbuffers::WIPOffset<GemmAttrs<'bldr>> {
        let mut builder = GemmAttrsBuilder::new(_fbb);
        builder.add_beta(args.beta);
        builder.add_alpha(args.alpha);
        builder.add_transpose_b(args.transpose_b);
        builder.add_transpose_a(args.transpose_a);
        builder.finish()
    }

    #[inline]
    pub fn alpha(&self) -> f32 {
        self._tab
            .get::<f32>(GemmAttrs::VT_ALPHA, Some(0.0))
            .unwrap()
    }
    #[inline]
    pub fn beta(&self) -> f32 {
        self._tab.get::<f32>(GemmAttrs::VT_BETA, Some(0.0)).unwrap()
    }
    #[inline]
    pub fn transpose_a(&self) -> bool {
        self._tab
            .get::<bool>(GemmAttrs::VT_TRANSPOSE_A, Some(false))
            .unwrap()
    }
    #[inline]
    pub fn transpose_b(&self) -> bool {
        self._tab
            .get::<bool>(GemmAttrs::VT_TRANSPOSE_B, Some(false))
            .unwrap()
    }
}

impl flatbuffers::Verifiable for GemmAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<f32>("alpha", Self::VT_ALPHA, false)?
            .visit_field::<f32>("beta", Self::VT_BETA, false)?
            .visit_field::<bool>("transpose_a", Self::VT_TRANSPOSE_A, false)?
            .visit_field::<bool>("transpose_b", Self::VT_TRANSPOSE_B, false)?
            .finish();
        Ok(())
    }
}
pub struct GemmAttrsArgs {
    pub alpha: f32,
    pub beta: f32,
    pub transpose_a: bool,
    pub transpose_b: bool,
}
impl<'a> Default for GemmAttrsArgs {
    #[inline]
    fn default() -> Self {
        GemmAttrsArgs {
            alpha: 0.0,
            beta: 0.0,
            transpose_a: false,
            transpose_b: false,
        }
    }
}

pub struct GemmAttrsBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GemmAttrsBuilder<'a, 'b> {
    #[inline]
    pub fn add_alpha(&mut self, alpha: f32) {
        self.fbb_.push_slot::<f32>(GemmAttrs::VT_ALPHA, alpha, 0.0);
    }
    #[inline]
    pub fn add_beta(&mut self, beta: f32) {
        self.fbb_.push_slot::<f32>(GemmAttrs::VT_BETA, beta, 0.0);
    }
    #[inline]
    pub fn add_transpose_a(&mut self, transpose_a: bool) {
        self.fbb_
            .push_slot::<bool>(GemmAttrs::VT_TRANSPOSE_A, transpose_a, false);
    }
    #[inline]
    pub fn add_transpose_b(&mut self, transpose_b: bool) {
        self.fbb_
            .push_slot::<bool>(GemmAttrs::VT_TRANSPOSE_B, transpose_b, false);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GemmAttrsBuilder<'a, 'b> {
        let start = _fbb.start_table();
        GemmAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<GemmAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for GemmAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("GemmAttrs");
        ds.field("alpha", &self.alpha());
        ds.field("beta", &self.beta());
        ds.field("transpose_a", &self.transpose_a());
        ds.field("transpose_b", &self.transpose_b());
        ds.finish()
    }
}
pub enum LeakyReluAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LeakyReluAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LeakyReluAttrs<'a> {
    type Inner = LeakyReluAttrs<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> LeakyReluAttrs<'a> {
    pub const VT_ALPHA: flatbuffers::VOffsetT = 4;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        LeakyReluAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args LeakyReluAttrsArgs,
    ) -> flatbuffers::WIPOffset<LeakyReluAttrs<'bldr>> {
        let mut builder = LeakyReluAttrsBuilder::new(_fbb);
        builder.add_alpha(args.alpha);
        builder.finish()
    }

    #[inline]
    pub fn alpha(&self) -> f32 {
        self._tab
            .get::<f32>(LeakyReluAttrs::VT_ALPHA, Some(0.0))
            .unwrap()
    }
}

impl flatbuffers::Verifiable for LeakyReluAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<f32>("alpha", Self::VT_ALPHA, false)?
            .finish();
        Ok(())
    }
}
pub struct LeakyReluAttrsArgs {
    pub alpha: f32,
}
impl<'a> Default for LeakyReluAttrsArgs {
    #[inline]
    fn default() -> Self {
        LeakyReluAttrsArgs { alpha: 0.0 }
    }
}

pub struct LeakyReluAttrsBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> LeakyReluAttrsBuilder<'a, 'b> {
    #[inline]
    pub fn add_alpha(&mut self, alpha: f32) {
        self.fbb_
            .push_slot::<f32>(LeakyReluAttrs::VT_ALPHA, alpha, 0.0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> LeakyReluAttrsBuilder<'a, 'b> {
        let start = _fbb.start_table();
        LeakyReluAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<LeakyReluAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for LeakyReluAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("LeakyReluAttrs");
        ds.field("alpha", &self.alpha());
        ds.finish()
    }
}
pub enum MaxPool2dAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MaxPool2dAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MaxPool2dAttrs<'a> {
    type Inner = MaxPool2dAttrs<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> MaxPool2dAttrs<'a> {
    pub const VT_KERNEL_SIZE: flatbuffers::VOffsetT = 4;
    pub const VT_PAD_MODE: flatbuffers::VOffsetT = 6;
    pub const VT_PADS: flatbuffers::VOffsetT = 8;
    pub const VT_STRIDE: flatbuffers::VOffsetT = 10;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        MaxPool2dAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args MaxPool2dAttrsArgs<'args>,
    ) -> flatbuffers::WIPOffset<MaxPool2dAttrs<'bldr>> {
        let mut builder = MaxPool2dAttrsBuilder::new(_fbb);
        builder.add_stride(args.stride);
        if let Some(x) = args.pads {
            builder.add_pads(x);
        }
        builder.add_kernel_size(args.kernel_size);
        builder.add_pad_mode(args.pad_mode);
        builder.finish()
    }

    #[inline]
    pub fn kernel_size(&self) -> u32 {
        self._tab
            .get::<u32>(MaxPool2dAttrs::VT_KERNEL_SIZE, Some(0))
            .unwrap()
    }
    #[inline]
    pub fn pad_mode(&self) -> PadMode {
        self._tab
            .get::<PadMode>(MaxPool2dAttrs::VT_PAD_MODE, Some(PadMode::Same))
            .unwrap()
    }
    #[inline]
    pub fn pads(&self) -> Option<flatbuffers::Vector<'a, u32>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                MaxPool2dAttrs::VT_PADS,
                None,
            )
    }
    #[inline]
    pub fn stride(&self) -> u32 {
        self._tab
            .get::<u32>(MaxPool2dAttrs::VT_STRIDE, Some(0))
            .unwrap()
    }
}

impl flatbuffers::Verifiable for MaxPool2dAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<u32>("kernel_size", Self::VT_KERNEL_SIZE, false)?
            .visit_field::<PadMode>("pad_mode", Self::VT_PAD_MODE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "pads",
                Self::VT_PADS,
                false,
            )?
            .visit_field::<u32>("stride", Self::VT_STRIDE, false)?
            .finish();
        Ok(())
    }
}
pub struct MaxPool2dAttrsArgs<'a> {
    pub kernel_size: u32,
    pub pad_mode: PadMode,
    pub pads: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub stride: u32,
}
impl<'a> Default for MaxPool2dAttrsArgs<'a> {
    #[inline]
    fn default() -> Self {
        MaxPool2dAttrsArgs {
            kernel_size: 0,
            pad_mode: PadMode::Same,
            pads: None,
            stride: 0,
        }
    }
}

pub struct MaxPool2dAttrsBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MaxPool2dAttrsBuilder<'a, 'b> {
    #[inline]
    pub fn add_kernel_size(&mut self, kernel_size: u32) {
        self.fbb_
            .push_slot::<u32>(MaxPool2dAttrs::VT_KERNEL_SIZE, kernel_size, 0);
    }
    #[inline]
    pub fn add_pad_mode(&mut self, pad_mode: PadMode) {
        self.fbb_
            .push_slot::<PadMode>(MaxPool2dAttrs::VT_PAD_MODE, pad_mode, PadMode::Same);
    }
    #[inline]
    pub fn add_pads(&mut self, pads: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(MaxPool2dAttrs::VT_PADS, pads);
    }
    #[inline]
    pub fn add_stride(&mut self, stride: u32) {
        self.fbb_
            .push_slot::<u32>(MaxPool2dAttrs::VT_STRIDE, stride, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MaxPool2dAttrsBuilder<'a, 'b> {
        let start = _fbb.start_table();
        MaxPool2dAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<MaxPool2dAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for MaxPool2dAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("MaxPool2dAttrs");
        ds.field("kernel_size", &self.kernel_size());
        ds.field("pad_mode", &self.pad_mode());
        ds.field("pads", &self.pads());
        ds.field("stride", &self.stride());
        ds.finish()
    }
}
pub enum PadAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PadAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PadAttrs<'a> {
    type Inner = PadAttrs<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> PadAttrs<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        PadAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        _args: &'args PadAttrsArgs,
    ) -> flatbuffers::WIPOffset<PadAttrs<'bldr>> {
        let mut builder = PadAttrsBuilder::new(_fbb);
        builder.finish()
    }
}

impl flatbuffers::Verifiable for PadAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?.finish();
        Ok(())
    }
}
pub struct PadAttrsArgs {}
impl<'a> Default for PadAttrsArgs {
    #[inline]
    fn default() -> Self {
        PadAttrsArgs {}
    }
}

pub struct PadAttrsBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PadAttrsBuilder<'a, 'b> {
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PadAttrsBuilder<'a, 'b> {
        let start = _fbb.start_table();
        PadAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<PadAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for PadAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("PadAttrs");
        ds.finish()
    }
}
pub enum SoftmaxAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SoftmaxAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SoftmaxAttrs<'a> {
    type Inner = SoftmaxAttrs<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> SoftmaxAttrs<'a> {
    pub const VT_AXIS: flatbuffers::VOffsetT = 4;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SoftmaxAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args SoftmaxAttrsArgs,
    ) -> flatbuffers::WIPOffset<SoftmaxAttrs<'bldr>> {
        let mut builder = SoftmaxAttrsBuilder::new(_fbb);
        builder.add_axis(args.axis);
        builder.finish()
    }

    #[inline]
    pub fn axis(&self) -> u32 {
        self._tab
            .get::<u32>(SoftmaxAttrs::VT_AXIS, Some(0))
            .unwrap()
    }
}

impl flatbuffers::Verifiable for SoftmaxAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<u32>("axis", Self::VT_AXIS, false)?
            .finish();
        Ok(())
    }
}
pub struct SoftmaxAttrsArgs {
    pub axis: u32,
}
impl<'a> Default for SoftmaxAttrsArgs {
    #[inline]
    fn default() -> Self {
        SoftmaxAttrsArgs { axis: 0 }
    }
}

pub struct SoftmaxAttrsBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SoftmaxAttrsBuilder<'a, 'b> {
    #[inline]
    pub fn add_axis(&mut self, axis: u32) {
        self.fbb_.push_slot::<u32>(SoftmaxAttrs::VT_AXIS, axis, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SoftmaxAttrsBuilder<'a, 'b> {
        let start = _fbb.start_table();
        SoftmaxAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<SoftmaxAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for SoftmaxAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("SoftmaxAttrs");
        ds.field("axis", &self.axis());
        ds.finish()
    }
}
pub enum SplitAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SplitAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SplitAttrs<'a> {
    type Inner = SplitAttrs<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> SplitAttrs<'a> {
    pub const VT_AXIS: flatbuffers::VOffsetT = 4;
    pub const VT_SPLIT: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SplitAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args SplitAttrsArgs<'args>,
    ) -> flatbuffers::WIPOffset<SplitAttrs<'bldr>> {
        let mut builder = SplitAttrsBuilder::new(_fbb);
        if let Some(x) = args.split {
            builder.add_split(x);
        }
        builder.add_axis(args.axis);
        builder.finish()
    }

    #[inline]
    pub fn axis(&self) -> i32 {
        self._tab.get::<i32>(SplitAttrs::VT_AXIS, Some(0)).unwrap()
    }
    #[inline]
    pub fn split(&self) -> Option<flatbuffers::Vector<'a, u32>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                SplitAttrs::VT_SPLIT,
                None,
            )
    }
}

impl flatbuffers::Verifiable for SplitAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("axis", Self::VT_AXIS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "split",
                Self::VT_SPLIT,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct SplitAttrsArgs<'a> {
    pub axis: i32,
    pub split: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
}
impl<'a> Default for SplitAttrsArgs<'a> {
    #[inline]
    fn default() -> Self {
        SplitAttrsArgs {
            axis: 0,
            split: None,
        }
    }
}

pub struct SplitAttrsBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SplitAttrsBuilder<'a, 'b> {
    #[inline]
    pub fn add_axis(&mut self, axis: i32) {
        self.fbb_.push_slot::<i32>(SplitAttrs::VT_AXIS, axis, 0);
    }
    #[inline]
    pub fn add_split(&mut self, split: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(SplitAttrs::VT_SPLIT, split);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SplitAttrsBuilder<'a, 'b> {
        let start = _fbb.start_table();
        SplitAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<SplitAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for SplitAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("SplitAttrs");
        ds.field("axis", &self.axis());
        ds.field("split", &self.split());
        ds.finish()
    }
}
pub enum SqueezeAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SqueezeAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SqueezeAttrs<'a> {
    type Inner = SqueezeAttrs<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> SqueezeAttrs<'a> {
    pub const VT_AXES: flatbuffers::VOffsetT = 4;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SqueezeAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args SqueezeAttrsArgs<'args>,
    ) -> flatbuffers::WIPOffset<SqueezeAttrs<'bldr>> {
        let mut builder = SqueezeAttrsBuilder::new(_fbb);
        if let Some(x) = args.axes {
            builder.add_axes(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn axes(&self) -> Option<flatbuffers::Vector<'a, u32>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                SqueezeAttrs::VT_AXES,
                None,
            )
    }
}

impl flatbuffers::Verifiable for SqueezeAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "axes",
                Self::VT_AXES,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct SqueezeAttrsArgs<'a> {
    pub axes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
}
impl<'a> Default for SqueezeAttrsArgs<'a> {
    #[inline]
    fn default() -> Self {
        SqueezeAttrsArgs { axes: None }
    }
}

pub struct SqueezeAttrsBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SqueezeAttrsBuilder<'a, 'b> {
    #[inline]
    pub fn add_axes(&mut self, axes: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(SqueezeAttrs::VT_AXES, axes);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SqueezeAttrsBuilder<'a, 'b> {
        let start = _fbb.start_table();
        SqueezeAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<SqueezeAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for SqueezeAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("SqueezeAttrs");
        ds.field("axes", &self.axes());
        ds.finish()
    }
}
pub enum TransposeAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TransposeAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TransposeAttrs<'a> {
    type Inner = TransposeAttrs<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> TransposeAttrs<'a> {
    pub const VT_PERM: flatbuffers::VOffsetT = 4;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        TransposeAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args TransposeAttrsArgs<'args>,
    ) -> flatbuffers::WIPOffset<TransposeAttrs<'bldr>> {
        let mut builder = TransposeAttrsBuilder::new(_fbb);
        if let Some(x) = args.perm {
            builder.add_perm(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn perm(&self) -> Option<flatbuffers::Vector<'a, u32>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                TransposeAttrs::VT_PERM,
                None,
            )
    }
}

impl flatbuffers::Verifiable for TransposeAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "perm",
                Self::VT_PERM,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct TransposeAttrsArgs<'a> {
    pub perm: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
}
impl<'a> Default for TransposeAttrsArgs<'a> {
    #[inline]
    fn default() -> Self {
        TransposeAttrsArgs { perm: None }
    }
}

pub struct TransposeAttrsBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TransposeAttrsBuilder<'a, 'b> {
    #[inline]
    pub fn add_perm(&mut self, perm: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(TransposeAttrs::VT_PERM, perm);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TransposeAttrsBuilder<'a, 'b> {
        let start = _fbb.start_table();
        TransposeAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<TransposeAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for TransposeAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("TransposeAttrs");
        ds.field("perm", &self.perm());
        ds.finish()
    }
}
pub enum UnsqueezeAttrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct UnsqueezeAttrs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for UnsqueezeAttrs<'a> {
    type Inner = UnsqueezeAttrs<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> UnsqueezeAttrs<'a> {
    pub const VT_AXES: flatbuffers::VOffsetT = 4;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        UnsqueezeAttrs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args UnsqueezeAttrsArgs<'args>,
    ) -> flatbuffers::WIPOffset<UnsqueezeAttrs<'bldr>> {
        let mut builder = UnsqueezeAttrsBuilder::new(_fbb);
        if let Some(x) = args.axes {
            builder.add_axes(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn axes(&self) -> flatbuffers::Vector<'a, u32> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                UnsqueezeAttrs::VT_AXES,
                None,
            )
            .unwrap()
    }
}

impl flatbuffers::Verifiable for UnsqueezeAttrs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "axes",
                Self::VT_AXES,
                true,
            )?
            .finish();
        Ok(())
    }
}
pub struct UnsqueezeAttrsArgs<'a> {
    pub axes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
}
impl<'a> Default for UnsqueezeAttrsArgs<'a> {
    #[inline]
    fn default() -> Self {
        UnsqueezeAttrsArgs {
            axes: None, // required field
        }
    }
}

pub struct UnsqueezeAttrsBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> UnsqueezeAttrsBuilder<'a, 'b> {
    #[inline]
    pub fn add_axes(&mut self, axes: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(UnsqueezeAttrs::VT_AXES, axes);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> UnsqueezeAttrsBuilder<'a, 'b> {
        let start = _fbb.start_table();
        UnsqueezeAttrsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<UnsqueezeAttrs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, UnsqueezeAttrs::VT_AXES, "axes");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for UnsqueezeAttrs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("UnsqueezeAttrs");
        ds.field("axes", &self.axes());
        ds.finish()
    }
}
pub enum OperatorNodeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct OperatorNode<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for OperatorNode<'a> {
    type Inner = OperatorNode<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> OperatorNode<'a> {
    pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
    pub const VT_ATTRS_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_ATTRS: flatbuffers::VOffsetT = 8;
    pub const VT_INPUTS: flatbuffers::VOffsetT = 10;
    pub const VT_OUTPUTS: flatbuffers::VOffsetT = 12;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        OperatorNode { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args OperatorNodeArgs<'args>,
    ) -> flatbuffers::WIPOffset<OperatorNode<'bldr>> {
        let mut builder = OperatorNodeBuilder::new(_fbb);
        if let Some(x) = args.outputs {
            builder.add_outputs(x);
        }
        if let Some(x) = args.inputs {
            builder.add_inputs(x);
        }
        if let Some(x) = args.attrs {
            builder.add_attrs(x);
        }
        builder.add_attrs_type(args.attrs_type);
        builder.add_type_(args.type_);
        builder.finish()
    }

    #[inline]
    pub fn type_(&self) -> OperatorType {
        self._tab
            .get::<OperatorType>(OperatorNode::VT_TYPE_, Some(OperatorType::Add))
            .unwrap()
    }
    #[inline]
    pub fn attrs_type(&self) -> OperatorAttrs {
        self._tab
            .get::<OperatorAttrs>(OperatorNode::VT_ATTRS_TYPE, Some(OperatorAttrs::NONE))
            .unwrap()
    }
    #[inline]
    pub fn attrs(&self) -> Option<flatbuffers::Table<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                OperatorNode::VT_ATTRS,
                None,
            )
    }
    #[inline]
    pub fn inputs(&self) -> Option<flatbuffers::Vector<'a, u32>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                OperatorNode::VT_INPUTS,
                None,
            )
    }
    #[inline]
    pub fn outputs(&self) -> Option<flatbuffers::Vector<'a, u32>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                OperatorNode::VT_OUTPUTS,
                None,
            )
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_average_pool_2d_attrs(&self) -> Option<AveragePool2dAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::AveragePool2dAttrs {
            self.attrs().map(AveragePool2dAttrs::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_batch_normalization_attrs(&self) -> Option<BatchNormalizationAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::BatchNormalizationAttrs {
            self.attrs().map(BatchNormalizationAttrs::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_cast_attrs(&self) -> Option<CastAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::CastAttrs {
            self.attrs().map(CastAttrs::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_clip_attrs(&self) -> Option<ClipAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::ClipAttrs {
            self.attrs().map(ClipAttrs::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_concat_attrs(&self) -> Option<ConcatAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::ConcatAttrs {
            self.attrs().map(ConcatAttrs::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_constant_of_shape_attrs(&self) -> Option<ConstantOfShapeAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::ConstantOfShapeAttrs {
            self.attrs().map(ConstantOfShapeAttrs::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_conv_2d_attrs(&self) -> Option<Conv2dAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::Conv2dAttrs {
            self.attrs().map(Conv2dAttrs::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_conv_transpose_2d_attrs(&self) -> Option<ConvTranspose2dAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::ConvTranspose2dAttrs {
            self.attrs().map(ConvTranspose2dAttrs::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_gather_attrs(&self) -> Option<GatherAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::GatherAttrs {
            self.attrs().map(GatherAttrs::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_gemm_attrs(&self) -> Option<GemmAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::GemmAttrs {
            self.attrs().map(GemmAttrs::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_leaky_relu_attrs(&self) -> Option<LeakyReluAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::LeakyReluAttrs {
            self.attrs().map(LeakyReluAttrs::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_max_pool_2d_attrs(&self) -> Option<MaxPool2dAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::MaxPool2dAttrs {
            self.attrs().map(MaxPool2dAttrs::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_pad_attrs(&self) -> Option<PadAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::PadAttrs {
            self.attrs().map(PadAttrs::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_split_attrs(&self) -> Option<SplitAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::SplitAttrs {
            self.attrs().map(SplitAttrs::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_squeeze_attrs(&self) -> Option<SqueezeAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::SqueezeAttrs {
            self.attrs().map(SqueezeAttrs::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_softmax_attrs(&self) -> Option<SoftmaxAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::SoftmaxAttrs {
            self.attrs().map(SoftmaxAttrs::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_transpose_attrs(&self) -> Option<TransposeAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::TransposeAttrs {
            self.attrs().map(TransposeAttrs::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn attrs_as_unsqueeze_attrs(&self) -> Option<UnsqueezeAttrs<'a>> {
        if self.attrs_type() == OperatorAttrs::UnsqueezeAttrs {
            self.attrs().map(UnsqueezeAttrs::init_from_table)
        } else {
            None
        }
    }
}

impl flatbuffers::Verifiable for OperatorNode<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<OperatorType>("type_", Self::VT_TYPE_, false)?
     .visit_union::<OperatorAttrs, _>("attrs_type", Self::VT_ATTRS_TYPE, "attrs", Self::VT_ATTRS, false, |key, v, pos| {
        match key {
          OperatorAttrs::AveragePool2dAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<AveragePool2dAttrs>>("OperatorAttrs::AveragePool2dAttrs", pos),
          OperatorAttrs::BatchNormalizationAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BatchNormalizationAttrs>>("OperatorAttrs::BatchNormalizationAttrs", pos),
          OperatorAttrs::CastAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CastAttrs>>("OperatorAttrs::CastAttrs", pos),
          OperatorAttrs::ClipAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ClipAttrs>>("OperatorAttrs::ClipAttrs", pos),
          OperatorAttrs::ConcatAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConcatAttrs>>("OperatorAttrs::ConcatAttrs", pos),
          OperatorAttrs::ConstantOfShapeAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConstantOfShapeAttrs>>("OperatorAttrs::ConstantOfShapeAttrs", pos),
          OperatorAttrs::Conv2dAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Conv2dAttrs>>("OperatorAttrs::Conv2dAttrs", pos),
          OperatorAttrs::ConvTranspose2dAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConvTranspose2dAttrs>>("OperatorAttrs::ConvTranspose2dAttrs", pos),
          OperatorAttrs::GatherAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GatherAttrs>>("OperatorAttrs::GatherAttrs", pos),
          OperatorAttrs::GemmAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GemmAttrs>>("OperatorAttrs::GemmAttrs", pos),
          OperatorAttrs::LeakyReluAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LeakyReluAttrs>>("OperatorAttrs::LeakyReluAttrs", pos),
          OperatorAttrs::MaxPool2dAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MaxPool2dAttrs>>("OperatorAttrs::MaxPool2dAttrs", pos),
          OperatorAttrs::PadAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PadAttrs>>("OperatorAttrs::PadAttrs", pos),
          OperatorAttrs::SplitAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SplitAttrs>>("OperatorAttrs::SplitAttrs", pos),
          OperatorAttrs::SqueezeAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SqueezeAttrs>>("OperatorAttrs::SqueezeAttrs", pos),
          OperatorAttrs::SoftmaxAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SoftmaxAttrs>>("OperatorAttrs::SoftmaxAttrs", pos),
          OperatorAttrs::TransposeAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TransposeAttrs>>("OperatorAttrs::TransposeAttrs", pos),
          OperatorAttrs::UnsqueezeAttrs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnsqueezeAttrs>>("OperatorAttrs::UnsqueezeAttrs", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>("inputs", Self::VT_INPUTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>("outputs", Self::VT_OUTPUTS, false)?
     .finish();
        Ok(())
    }
}
pub struct OperatorNodeArgs<'a> {
    pub type_: OperatorType,
    pub attrs_type: OperatorAttrs,
    pub attrs: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub inputs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub outputs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
}
impl<'a> Default for OperatorNodeArgs<'a> {
    #[inline]
    fn default() -> Self {
        OperatorNodeArgs {
            type_: OperatorType::Add,
            attrs_type: OperatorAttrs::NONE,
            attrs: None,
            inputs: None,
            outputs: None,
        }
    }
}

pub struct OperatorNodeBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> OperatorNodeBuilder<'a, 'b> {
    #[inline]
    pub fn add_type_(&mut self, type_: OperatorType) {
        self.fbb_
            .push_slot::<OperatorType>(OperatorNode::VT_TYPE_, type_, OperatorType::Add);
    }
    #[inline]
    pub fn add_attrs_type(&mut self, attrs_type: OperatorAttrs) {
        self.fbb_.push_slot::<OperatorAttrs>(
            OperatorNode::VT_ATTRS_TYPE,
            attrs_type,
            OperatorAttrs::NONE,
        );
    }
    #[inline]
    pub fn add_attrs(&mut self, attrs: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(OperatorNode::VT_ATTRS, attrs);
    }
    #[inline]
    pub fn add_inputs(&mut self, inputs: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(OperatorNode::VT_INPUTS, inputs);
    }
    #[inline]
    pub fn add_outputs(&mut self, outputs: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(OperatorNode::VT_OUTPUTS, outputs);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> OperatorNodeBuilder<'a, 'b> {
        let start = _fbb.start_table();
        OperatorNodeBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<OperatorNode<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for OperatorNode<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("OperatorNode");
        ds.field("type_", &self.type_());
        ds.field("attrs_type", &self.attrs_type());
        match self.attrs_type() {
            OperatorAttrs::AveragePool2dAttrs => {
                if let Some(x) = self.attrs_as_average_pool_2d_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::BatchNormalizationAttrs => {
                if let Some(x) = self.attrs_as_batch_normalization_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::CastAttrs => {
                if let Some(x) = self.attrs_as_cast_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::ClipAttrs => {
                if let Some(x) = self.attrs_as_clip_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::ConcatAttrs => {
                if let Some(x) = self.attrs_as_concat_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::ConstantOfShapeAttrs => {
                if let Some(x) = self.attrs_as_constant_of_shape_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::Conv2dAttrs => {
                if let Some(x) = self.attrs_as_conv_2d_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::ConvTranspose2dAttrs => {
                if let Some(x) = self.attrs_as_conv_transpose_2d_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::GatherAttrs => {
                if let Some(x) = self.attrs_as_gather_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::GemmAttrs => {
                if let Some(x) = self.attrs_as_gemm_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::LeakyReluAttrs => {
                if let Some(x) = self.attrs_as_leaky_relu_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::MaxPool2dAttrs => {
                if let Some(x) = self.attrs_as_max_pool_2d_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::PadAttrs => {
                if let Some(x) = self.attrs_as_pad_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::SplitAttrs => {
                if let Some(x) = self.attrs_as_split_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::SqueezeAttrs => {
                if let Some(x) = self.attrs_as_squeeze_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::SoftmaxAttrs => {
                if let Some(x) = self.attrs_as_softmax_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::TransposeAttrs => {
                if let Some(x) = self.attrs_as_transpose_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            OperatorAttrs::UnsqueezeAttrs => {
                if let Some(x) = self.attrs_as_unsqueeze_attrs() {
                    ds.field("attrs", &x)
                } else {
                    ds.field(
                        "attrs",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("attrs", &x)
            }
        };
        ds.field("inputs", &self.inputs());
        ds.field("outputs", &self.outputs());
        ds.finish()
    }
}
pub enum FloatDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct FloatData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FloatData<'a> {
    type Inner = FloatData<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> FloatData<'a> {
    pub const VT_DATA: flatbuffers::VOffsetT = 4;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FloatData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FloatDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<FloatData<'bldr>> {
        let mut builder = FloatDataBuilder::new(_fbb);
        if let Some(x) = args.data {
            builder.add_data(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn data(&self) -> flatbuffers::Vector<'a, f32> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(
                FloatData::VT_DATA,
                None,
            )
            .unwrap()
    }
}

impl flatbuffers::Verifiable for FloatData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>(
                "data",
                Self::VT_DATA,
                true,
            )?
            .finish();
        Ok(())
    }
}
pub struct FloatDataArgs<'a> {
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
}
impl<'a> Default for FloatDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        FloatDataArgs {
            data: None, // required field
        }
    }
}

pub struct FloatDataBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FloatDataBuilder<'a, 'b> {
    #[inline]
    pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b, f32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(FloatData::VT_DATA, data);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FloatDataBuilder<'a, 'b> {
        let start = _fbb.start_table();
        FloatDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<FloatData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, FloatData::VT_DATA, "data");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for FloatData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("FloatData");
        ds.field("data", &self.data());
        ds.finish()
    }
}
pub enum IntDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct IntData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IntData<'a> {
    type Inner = IntData<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> IntData<'a> {
    pub const VT_DATA: flatbuffers::VOffsetT = 4;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        IntData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args IntDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<IntData<'bldr>> {
        let mut builder = IntDataBuilder::new(_fbb);
        if let Some(x) = args.data {
            builder.add_data(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn data(&self) -> flatbuffers::Vector<'a, i32> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(
                IntData::VT_DATA,
                None,
            )
            .unwrap()
    }
}

impl flatbuffers::Verifiable for IntData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>(
                "data",
                Self::VT_DATA,
                true,
            )?
            .finish();
        Ok(())
    }
}
pub struct IntDataArgs<'a> {
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
}
impl<'a> Default for IntDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        IntDataArgs {
            data: None, // required field
        }
    }
}

pub struct IntDataBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> IntDataBuilder<'a, 'b> {
    #[inline]
    pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(IntData::VT_DATA, data);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> IntDataBuilder<'a, 'b> {
        let start = _fbb.start_table();
        IntDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<IntData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, IntData::VT_DATA, "data");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for IntData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("IntData");
        ds.field("data", &self.data());
        ds.finish()
    }
}
pub enum ConstantNodeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ConstantNode<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ConstantNode<'a> {
    type Inner = ConstantNode<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> ConstantNode<'a> {
    pub const VT_SHAPE: flatbuffers::VOffsetT = 4;
    pub const VT_DATA_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_DATA: flatbuffers::VOffsetT = 8;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ConstantNode { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ConstantNodeArgs<'args>,
    ) -> flatbuffers::WIPOffset<ConstantNode<'bldr>> {
        let mut builder = ConstantNodeBuilder::new(_fbb);
        if let Some(x) = args.data {
            builder.add_data(x);
        }
        if let Some(x) = args.shape {
            builder.add_shape(x);
        }
        builder.add_data_type(args.data_type);
        builder.finish()
    }

    #[inline]
    pub fn shape(&self) -> flatbuffers::Vector<'a, u32> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                ConstantNode::VT_SHAPE,
                None,
            )
            .unwrap()
    }
    #[inline]
    pub fn data_type(&self) -> ConstantData {
        self._tab
            .get::<ConstantData>(ConstantNode::VT_DATA_TYPE, Some(ConstantData::NONE))
            .unwrap()
    }
    #[inline]
    pub fn data(&self) -> flatbuffers::Table<'a> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                ConstantNode::VT_DATA,
                None,
            )
            .unwrap()
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn data_as_float_data(&self) -> Option<FloatData<'a>> {
        if self.data_type() == ConstantData::FloatData {
            let u = self.data();
            Some(FloatData::init_from_table(u))
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn data_as_int_data(&self) -> Option<IntData<'a>> {
        if self.data_type() == ConstantData::IntData {
            let u = self.data();
            Some(IntData::init_from_table(u))
        } else {
            None
        }
    }
}

impl flatbuffers::Verifiable for ConstantNode<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "shape",
                Self::VT_SHAPE,
                true,
            )?
            .visit_union::<ConstantData, _>(
                "data_type",
                Self::VT_DATA_TYPE,
                "data",
                Self::VT_DATA,
                true,
                |key, v, pos| match key {
                    ConstantData::FloatData => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<FloatData>>(
                            "ConstantData::FloatData",
                            pos,
                        ),
                    ConstantData::IntData => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<IntData>>(
                            "ConstantData::IntData",
                            pos,
                        ),
                    _ => Ok(()),
                },
            )?
            .finish();
        Ok(())
    }
}
pub struct ConstantNodeArgs<'a> {
    pub shape: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub data_type: ConstantData,
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for ConstantNodeArgs<'a> {
    #[inline]
    fn default() -> Self {
        ConstantNodeArgs {
            shape: None, // required field
            data_type: ConstantData::NONE,
            data: None, // required field
        }
    }
}

pub struct ConstantNodeBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ConstantNodeBuilder<'a, 'b> {
    #[inline]
    pub fn add_shape(&mut self, shape: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ConstantNode::VT_SHAPE, shape);
    }
    #[inline]
    pub fn add_data_type(&mut self, data_type: ConstantData) {
        self.fbb_.push_slot::<ConstantData>(
            ConstantNode::VT_DATA_TYPE,
            data_type,
            ConstantData::NONE,
        );
    }
    #[inline]
    pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ConstantNode::VT_DATA, data);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ConstantNodeBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ConstantNodeBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ConstantNode<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, ConstantNode::VT_SHAPE, "shape");
        self.fbb_.required(o, ConstantNode::VT_DATA, "data");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ConstantNode<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ConstantNode");
        ds.field("shape", &self.shape());
        ds.field("data_type", &self.data_type());
        match self.data_type() {
            ConstantData::FloatData => {
                if let Some(x) = self.data_as_float_data() {
                    ds.field("data", &x)
                } else {
                    ds.field(
                        "data",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            ConstantData::IntData => {
                if let Some(x) = self.data_as_int_data() {
                    ds.field("data", &x)
                } else {
                    ds.field(
                        "data",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("data", &x)
            }
        };
        ds.finish()
    }
}
pub enum ValueNodeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ValueNode<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ValueNode<'a> {
    type Inner = ValueNode<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> ValueNode<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ValueNode { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        _args: &'args ValueNodeArgs,
    ) -> flatbuffers::WIPOffset<ValueNode<'bldr>> {
        let mut builder = ValueNodeBuilder::new(_fbb);
        builder.finish()
    }
}

impl flatbuffers::Verifiable for ValueNode<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?.finish();
        Ok(())
    }
}
pub struct ValueNodeArgs {}
impl<'a> Default for ValueNodeArgs {
    #[inline]
    fn default() -> Self {
        ValueNodeArgs {}
    }
}

pub struct ValueNodeBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ValueNodeBuilder<'a, 'b> {
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ValueNodeBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ValueNodeBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ValueNode<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ValueNode<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ValueNode");
        ds.finish()
    }
}
pub enum NodeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Node<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Node<'a> {
    type Inner = Node<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> Node<'a> {
    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_DATA_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_DATA: flatbuffers::VOffsetT = 8;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Node { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args NodeArgs<'args>,
    ) -> flatbuffers::WIPOffset<Node<'bldr>> {
        let mut builder = NodeBuilder::new(_fbb);
        if let Some(x) = args.data {
            builder.add_data(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.add_data_type(args.data_type);
        builder.finish()
    }

    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(Node::VT_NAME, None)
    }
    #[inline]
    pub fn data_type(&self) -> NodeKind {
        self._tab
            .get::<NodeKind>(Node::VT_DATA_TYPE, Some(NodeKind::NONE))
            .unwrap()
    }
    #[inline]
    pub fn data(&self) -> Option<flatbuffers::Table<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Node::VT_DATA, None)
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn data_as_operator_node(&self) -> Option<OperatorNode<'a>> {
        if self.data_type() == NodeKind::OperatorNode {
            self.data().map(OperatorNode::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn data_as_constant_node(&self) -> Option<ConstantNode<'a>> {
        if self.data_type() == NodeKind::ConstantNode {
            self.data().map(ConstantNode::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn data_as_value_node(&self) -> Option<ValueNode<'a>> {
        if self.data_type() == NodeKind::ValueNode {
            self.data().map(ValueNode::init_from_table)
        } else {
            None
        }
    }
}

impl flatbuffers::Verifiable for Node<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_union::<NodeKind, _>(
                "data_type",
                Self::VT_DATA_TYPE,
                "data",
                Self::VT_DATA,
                false,
                |key, v, pos| match key {
                    NodeKind::OperatorNode => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<OperatorNode>>(
                            "NodeKind::OperatorNode",
                            pos,
                        ),
                    NodeKind::ConstantNode => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<ConstantNode>>(
                            "NodeKind::ConstantNode",
                            pos,
                        ),
                    NodeKind::ValueNode => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<ValueNode>>(
                            "NodeKind::ValueNode",
                            pos,
                        ),
                    _ => Ok(()),
                },
            )?
            .finish();
        Ok(())
    }
}
pub struct NodeArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub data_type: NodeKind,
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for NodeArgs<'a> {
    #[inline]
    fn default() -> Self {
        NodeArgs {
            name: None,
            data_type: NodeKind::NONE,
            data: None,
        }
    }
}

pub struct NodeBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> NodeBuilder<'a, 'b> {
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Node::VT_NAME, name);
    }
    #[inline]
    pub fn add_data_type(&mut self, data_type: NodeKind) {
        self.fbb_
            .push_slot::<NodeKind>(Node::VT_DATA_TYPE, data_type, NodeKind::NONE);
    }
    #[inline]
    pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Node::VT_DATA, data);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> NodeBuilder<'a, 'b> {
        let start = _fbb.start_table();
        NodeBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Node<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for Node<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("Node");
        ds.field("name", &self.name());
        ds.field("data_type", &self.data_type());
        match self.data_type() {
            NodeKind::OperatorNode => {
                if let Some(x) = self.data_as_operator_node() {
                    ds.field("data", &x)
                } else {
                    ds.field(
                        "data",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            NodeKind::ConstantNode => {
                if let Some(x) = self.data_as_constant_node() {
                    ds.field("data", &x)
                } else {
                    ds.field(
                        "data",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            NodeKind::ValueNode => {
                if let Some(x) = self.data_as_value_node() {
                    ds.field("data", &x)
                } else {
                    ds.field(
                        "data",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("data", &x)
            }
        };
        ds.finish()
    }
}
pub enum GraphOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Graph<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Graph<'a> {
    type Inner = Graph<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> Graph<'a> {
    pub const VT_NODES: flatbuffers::VOffsetT = 4;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Graph { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GraphArgs<'args>,
    ) -> flatbuffers::WIPOffset<Graph<'bldr>> {
        let mut builder = GraphBuilder::new(_fbb);
        if let Some(x) = args.nodes {
            builder.add_nodes(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn nodes(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Node<'a>>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Node>>,
        >>(Graph::VT_NODES, None)
    }
}

impl flatbuffers::Verifiable for Graph<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Node>>,
            >>("nodes", Self::VT_NODES, false)?
            .finish();
        Ok(())
    }
}
pub struct GraphArgs<'a> {
    pub nodes: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Node<'a>>>>,
    >,
}
impl<'a> Default for GraphArgs<'a> {
    #[inline]
    fn default() -> Self {
        GraphArgs { nodes: None }
    }
}

pub struct GraphBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GraphBuilder<'a, 'b> {
    #[inline]
    pub fn add_nodes(
        &mut self,
        nodes: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Node<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Graph::VT_NODES, nodes);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GraphBuilder<'a, 'b> {
        let start = _fbb.start_table();
        GraphBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Graph<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for Graph<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("Graph");
        ds.field("nodes", &self.nodes());
        ds.finish()
    }
}
pub enum ModelOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Model<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Model<'a> {
    type Inner = Model<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> Model<'a> {
    pub const VT_SCHEMA_VERSION: flatbuffers::VOffsetT = 4;
    pub const VT_GRAPH: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Model { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ModelArgs<'args>,
    ) -> flatbuffers::WIPOffset<Model<'bldr>> {
        let mut builder = ModelBuilder::new(_fbb);
        if let Some(x) = args.graph {
            builder.add_graph(x);
        }
        builder.add_schema_version(args.schema_version);
        builder.finish()
    }

    #[inline]
    pub fn schema_version(&self) -> i32 {
        self._tab
            .get::<i32>(Model::VT_SCHEMA_VERSION, Some(0))
            .unwrap()
    }
    #[inline]
    pub fn graph(&self) -> Graph<'a> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<Graph>>(Model::VT_GRAPH, None)
            .unwrap()
    }
}

impl flatbuffers::Verifiable for Model<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("schema_version", Self::VT_SCHEMA_VERSION, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<Graph>>("graph", Self::VT_GRAPH, true)?
            .finish();
        Ok(())
    }
}
pub struct ModelArgs<'a> {
    pub schema_version: i32,
    pub graph: Option<flatbuffers::WIPOffset<Graph<'a>>>,
}
impl<'a> Default for ModelArgs<'a> {
    #[inline]
    fn default() -> Self {
        ModelArgs {
            schema_version: 0,
            graph: None, // required field
        }
    }
}

pub struct ModelBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ModelBuilder<'a, 'b> {
    #[inline]
    pub fn add_schema_version(&mut self, schema_version: i32) {
        self.fbb_
            .push_slot::<i32>(Model::VT_SCHEMA_VERSION, schema_version, 0);
    }
    #[inline]
    pub fn add_graph(&mut self, graph: flatbuffers::WIPOffset<Graph<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<Graph>>(Model::VT_GRAPH, graph);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ModelBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ModelBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Model<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, Model::VT_GRAPH, "graph");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for Model<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("Model");
        ds.field("schema_version", &self.schema_version());
        ds.field("graph", &self.graph());
        ds.finish()
    }
}
#[inline]
#[deprecated(since = "2.0.0", note = "Deprecated in favor of `root_as...` methods.")]
pub fn get_root_as_model<'a>(buf: &'a [u8]) -> Model<'a> {
    unsafe { flatbuffers::root_unchecked::<Model<'a>>(buf) }
}

#[inline]
#[deprecated(since = "2.0.0", note = "Deprecated in favor of `root_as...` methods.")]
pub fn get_size_prefixed_root_as_model<'a>(buf: &'a [u8]) -> Model<'a> {
    unsafe { flatbuffers::size_prefixed_root_unchecked::<Model<'a>>(buf) }
}

#[inline]
/// Verifies that a buffer of bytes contains a `Model`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_model_unchecked`.
pub fn root_as_model(buf: &[u8]) -> Result<Model, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root::<Model>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Model` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_model_unchecked`.
pub fn size_prefixed_root_as_model(buf: &[u8]) -> Result<Model, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root::<Model>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Model` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_model_unchecked`.
pub fn root_as_model_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<Model<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root_with_opts::<Model<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Model` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_model_unchecked`.
pub fn size_prefixed_root_as_model_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<Model<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root_with_opts::<Model<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Model and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Model`.
pub unsafe fn root_as_model_unchecked(buf: &[u8]) -> Model {
    flatbuffers::root_unchecked::<Model>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Model and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Model`.
pub unsafe fn size_prefixed_root_as_model_unchecked(buf: &[u8]) -> Model {
    flatbuffers::size_prefixed_root_unchecked::<Model>(buf)
}
pub const MODEL_IDENTIFIER: &str = "MODL";

#[inline]
pub fn model_buffer_has_identifier(buf: &[u8]) -> bool {
    flatbuffers::buffer_has_identifier(buf, MODEL_IDENTIFIER, false)
}

#[inline]
pub fn model_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
    flatbuffers::buffer_has_identifier(buf, MODEL_IDENTIFIER, true)
}

pub const MODEL_EXTENSION: &str = "model";

#[inline]
pub fn finish_model_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<Model<'a>>,
) {
    fbb.finish(root, Some(MODEL_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_model_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<Model<'a>>,
) {
    fbb.finish_size_prefixed(root, Some(MODEL_IDENTIFIER));
}
