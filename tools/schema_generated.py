# automatically generated by the FlatBuffers compiler, do not modify

# namespace: 

import flatbuffers
from flatbuffers.compat import import_numpy
np = import_numpy()

class OperatorType(object):
    Add = 0
    AveragePool = 1
    BatchNormalization = 2
    Cast = 3
    Clip = 4
    Concat = 5
    ConstantOfShape = 6
    Conv = 7
    ConvTranspose = 8
    Cos = 9
    Div = 10
    Equal = 11
    Erf = 12
    Expand = 13
    Gather = 14
    Gemm = 15
    GlobalAveragePool = 16
    Identity = 17
    LeakyRelu = 18
    Less = 19
    MatMul = 20
    MaxPool = 21
    Mul = 22
    Pad = 23
    Pow = 24
    Range = 25
    ReduceMean = 26
    Relu = 27
    Reshape = 28
    Resize = 29
    Shape = 30
    Sigmoid = 31
    Sin = 32
    Slice = 33
    Split = 34
    Sqrt = 35
    Squeeze = 36
    Softmax = 37
    Sub = 38
    Tanh = 39
    Transpose = 40
    Unsqueeze = 41
    Where = 42


class PadMode(object):
    Same = 0
    Fixed = 1


class DataType(object):
    Int32 = 0
    Float = 1


class ResizeMode(object):
    Nearest = 0
    Linear = 1


class OperatorAttrs(object):
    NONE = 0
    AveragePoolAttrs = 1
    BatchNormalizationAttrs = 2
    CastAttrs = 3
    ClipAttrs = 4
    ConcatAttrs = 5
    ConstantOfShapeAttrs = 6
    ConvAttrs = 7
    ConvTransposeAttrs = 8
    GatherAttrs = 9
    GemmAttrs = 10
    LeakyReluAttrs = 11
    MaxPoolAttrs = 12
    PadAttrs = 13
    ReduceMeanAttrs = 14
    ResizeAttrs = 15
    SplitAttrs = 16
    SqueezeAttrs = 17
    SoftmaxAttrs = 18
    TransposeAttrs = 19
    UnsqueezeAttrs = 20

def OperatorAttrsCreator(unionType, table):
    from flatbuffers.table import Table
    if not isinstance(table, Table):
        return None
    if unionType == OperatorAttrs().AveragePoolAttrs:
        return AveragePoolAttrsT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == OperatorAttrs().BatchNormalizationAttrs:
        return BatchNormalizationAttrsT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == OperatorAttrs().CastAttrs:
        return CastAttrsT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == OperatorAttrs().ClipAttrs:
        return ClipAttrsT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == OperatorAttrs().ConcatAttrs:
        return ConcatAttrsT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == OperatorAttrs().ConstantOfShapeAttrs:
        return ConstantOfShapeAttrsT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == OperatorAttrs().ConvAttrs:
        return ConvAttrsT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == OperatorAttrs().ConvTransposeAttrs:
        return ConvTransposeAttrsT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == OperatorAttrs().GatherAttrs:
        return GatherAttrsT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == OperatorAttrs().GemmAttrs:
        return GemmAttrsT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == OperatorAttrs().LeakyReluAttrs:
        return LeakyReluAttrsT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == OperatorAttrs().MaxPoolAttrs:
        return MaxPoolAttrsT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == OperatorAttrs().PadAttrs:
        return PadAttrsT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == OperatorAttrs().ReduceMeanAttrs:
        return ReduceMeanAttrsT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == OperatorAttrs().ResizeAttrs:
        return ResizeAttrsT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == OperatorAttrs().SplitAttrs:
        return SplitAttrsT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == OperatorAttrs().SqueezeAttrs:
        return SqueezeAttrsT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == OperatorAttrs().SoftmaxAttrs:
        return SoftmaxAttrsT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == OperatorAttrs().TransposeAttrs:
        return TransposeAttrsT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == OperatorAttrs().UnsqueezeAttrs:
        return UnsqueezeAttrsT.InitFromBuf(table.Bytes, table.Pos)
    return None


class Scalar(object):
    NONE = 0
    IntScalar = 1
    FloatScalar = 2

def ScalarCreator(unionType, table):
    from flatbuffers.table import Table
    if not isinstance(table, Table):
        return None
    if unionType == Scalar().IntScalar:
        return IntScalarT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == Scalar().FloatScalar:
        return FloatScalarT.InitFromBuf(table.Bytes, table.Pos)
    return None


class NodeKind(object):
    NONE = 0
    OperatorNode = 1
    ConstantNode = 2
    ValueNode = 3

def NodeKindCreator(unionType, table):
    from flatbuffers.table import Table
    if not isinstance(table, Table):
        return None
    if unionType == NodeKind().OperatorNode:
        return OperatorNodeT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == NodeKind().ConstantNode:
        return ConstantNodeT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == NodeKind().ValueNode:
        return ValueNodeT.InitFromBuf(table.Bytes, table.Pos)
    return None


class ConstantData(object):
    NONE = 0
    FloatData = 1
    IntData = 2

def ConstantDataCreator(unionType, table):
    from flatbuffers.table import Table
    if not isinstance(table, Table):
        return None
    if unionType == ConstantData().FloatData:
        return FloatDataT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == ConstantData().IntData:
        return IntDataT.InitFromBuf(table.Bytes, table.Pos)
    return None


class AveragePoolAttrs(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = AveragePoolAttrs()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsAveragePoolAttrs(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def AveragePoolAttrsBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x4D\x4F\x44\x4C", size_prefixed=size_prefixed)

    # AveragePoolAttrs
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # AveragePoolAttrs
    def KernelSize(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # AveragePoolAttrs
    def KernelSizeAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint32Flags, o)
        return 0

    # AveragePoolAttrs
    def KernelSizeLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # AveragePoolAttrs
    def KernelSizeIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0

    # AveragePoolAttrs
    def PadMode(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int8Flags, o + self._tab.Pos)
        return 0

    # AveragePoolAttrs
    def Pads(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # AveragePoolAttrs
    def PadsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint32Flags, o)
        return 0

    # AveragePoolAttrs
    def PadsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # AveragePoolAttrs
    def PadsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        return o == 0

    # AveragePoolAttrs
    def Strides(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # AveragePoolAttrs
    def StridesAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint32Flags, o)
        return 0

    # AveragePoolAttrs
    def StridesLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # AveragePoolAttrs
    def StridesIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        return o == 0

def AveragePoolAttrsStart(builder): builder.StartObject(4)
def AveragePoolAttrsAddKernelSize(builder, kernelSize): builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(kernelSize), 0)
def AveragePoolAttrsStartKernelSizeVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def AveragePoolAttrsAddPadMode(builder, padMode): builder.PrependInt8Slot(1, padMode, 0)
def AveragePoolAttrsAddPads(builder, pads): builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(pads), 0)
def AveragePoolAttrsStartPadsVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def AveragePoolAttrsAddStrides(builder, strides): builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(strides), 0)
def AveragePoolAttrsStartStridesVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def AveragePoolAttrsEnd(builder): return builder.EndObject()

try:
    from typing import List
except:
    pass

class AveragePoolAttrsT(object):

    # AveragePoolAttrsT
    def __init__(self):
        self.kernelSize = None  # type: List[int]
        self.padMode = 0  # type: int
        self.pads = None  # type: List[int]
        self.strides = None  # type: List[int]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        averagePoolAttrs = AveragePoolAttrs()
        averagePoolAttrs.Init(buf, pos)
        return cls.InitFromObj(averagePoolAttrs)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, averagePoolAttrs):
        x = AveragePoolAttrsT()
        x._UnPack(averagePoolAttrs)
        return x

    # AveragePoolAttrsT
    def _UnPack(self, averagePoolAttrs):
        if averagePoolAttrs is None:
            return
        if not averagePoolAttrs.KernelSizeIsNone():
            if np is None:
                self.kernelSize = []
                for i in range(averagePoolAttrs.KernelSizeLength()):
                    self.kernelSize.append(averagePoolAttrs.KernelSize(i))
            else:
                self.kernelSize = averagePoolAttrs.KernelSizeAsNumpy()
        self.padMode = averagePoolAttrs.PadMode()
        if not averagePoolAttrs.PadsIsNone():
            if np is None:
                self.pads = []
                for i in range(averagePoolAttrs.PadsLength()):
                    self.pads.append(averagePoolAttrs.Pads(i))
            else:
                self.pads = averagePoolAttrs.PadsAsNumpy()
        if not averagePoolAttrs.StridesIsNone():
            if np is None:
                self.strides = []
                for i in range(averagePoolAttrs.StridesLength()):
                    self.strides.append(averagePoolAttrs.Strides(i))
            else:
                self.strides = averagePoolAttrs.StridesAsNumpy()

    # AveragePoolAttrsT
    def Pack(self, builder):
        if self.kernelSize is not None:
            if np is not None and type(self.kernelSize) is np.ndarray:
                kernelSize = builder.CreateNumpyVector(self.kernelSize)
            else:
                AveragePoolAttrsStartKernelSizeVector(builder, len(self.kernelSize))
                for i in reversed(range(len(self.kernelSize))):
                    builder.PrependUint32(self.kernelSize[i])
                kernelSize = builder.EndVector()
        if self.pads is not None:
            if np is not None and type(self.pads) is np.ndarray:
                pads = builder.CreateNumpyVector(self.pads)
            else:
                AveragePoolAttrsStartPadsVector(builder, len(self.pads))
                for i in reversed(range(len(self.pads))):
                    builder.PrependUint32(self.pads[i])
                pads = builder.EndVector()
        if self.strides is not None:
            if np is not None and type(self.strides) is np.ndarray:
                strides = builder.CreateNumpyVector(self.strides)
            else:
                AveragePoolAttrsStartStridesVector(builder, len(self.strides))
                for i in reversed(range(len(self.strides))):
                    builder.PrependUint32(self.strides[i])
                strides = builder.EndVector()
        AveragePoolAttrsStart(builder)
        if self.kernelSize is not None:
            AveragePoolAttrsAddKernelSize(builder, kernelSize)
        AveragePoolAttrsAddPadMode(builder, self.padMode)
        if self.pads is not None:
            AveragePoolAttrsAddPads(builder, pads)
        if self.strides is not None:
            AveragePoolAttrsAddStrides(builder, strides)
        averagePoolAttrs = AveragePoolAttrsEnd(builder)
        return averagePoolAttrs


class BatchNormalizationAttrs(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = BatchNormalizationAttrs()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsBatchNormalizationAttrs(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def BatchNormalizationAttrsBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x4D\x4F\x44\x4C", size_prefixed=size_prefixed)

    # BatchNormalizationAttrs
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # BatchNormalizationAttrs
    def Epsilon(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float32Flags, o + self._tab.Pos)
        return 0.0

def BatchNormalizationAttrsStart(builder): builder.StartObject(1)
def BatchNormalizationAttrsAddEpsilon(builder, epsilon): builder.PrependFloat32Slot(0, epsilon, 0.0)
def BatchNormalizationAttrsEnd(builder): return builder.EndObject()


class BatchNormalizationAttrsT(object):

    # BatchNormalizationAttrsT
    def __init__(self):
        self.epsilon = 0.0  # type: float

    @classmethod
    def InitFromBuf(cls, buf, pos):
        batchNormalizationAttrs = BatchNormalizationAttrs()
        batchNormalizationAttrs.Init(buf, pos)
        return cls.InitFromObj(batchNormalizationAttrs)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, batchNormalizationAttrs):
        x = BatchNormalizationAttrsT()
        x._UnPack(batchNormalizationAttrs)
        return x

    # BatchNormalizationAttrsT
    def _UnPack(self, batchNormalizationAttrs):
        if batchNormalizationAttrs is None:
            return
        self.epsilon = batchNormalizationAttrs.Epsilon()

    # BatchNormalizationAttrsT
    def Pack(self, builder):
        BatchNormalizationAttrsStart(builder)
        BatchNormalizationAttrsAddEpsilon(builder, self.epsilon)
        batchNormalizationAttrs = BatchNormalizationAttrsEnd(builder)
        return batchNormalizationAttrs


class CastAttrs(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = CastAttrs()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsCastAttrs(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def CastAttrsBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x4D\x4F\x44\x4C", size_prefixed=size_prefixed)

    # CastAttrs
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # CastAttrs
    def To(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int8Flags, o + self._tab.Pos)
        return 0

def CastAttrsStart(builder): builder.StartObject(1)
def CastAttrsAddTo(builder, to): builder.PrependInt8Slot(0, to, 0)
def CastAttrsEnd(builder): return builder.EndObject()


class CastAttrsT(object):

    # CastAttrsT
    def __init__(self):
        self.to = 0  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        castAttrs = CastAttrs()
        castAttrs.Init(buf, pos)
        return cls.InitFromObj(castAttrs)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, castAttrs):
        x = CastAttrsT()
        x._UnPack(castAttrs)
        return x

    # CastAttrsT
    def _UnPack(self, castAttrs):
        if castAttrs is None:
            return
        self.to = castAttrs.To()

    # CastAttrsT
    def Pack(self, builder):
        CastAttrsStart(builder)
        CastAttrsAddTo(builder, self.to)
        castAttrs = CastAttrsEnd(builder)
        return castAttrs


class ClipAttrs(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = ClipAttrs()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsClipAttrs(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def ClipAttrsBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x4D\x4F\x44\x4C", size_prefixed=size_prefixed)

    # ClipAttrs
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # ClipAttrs
    def Min(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float32Flags, o + self._tab.Pos)
        return 0.0

    # ClipAttrs
    def Max(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float32Flags, o + self._tab.Pos)
        return 0.0

def ClipAttrsStart(builder): builder.StartObject(2)
def ClipAttrsAddMin(builder, min): builder.PrependFloat32Slot(0, min, 0.0)
def ClipAttrsAddMax(builder, max): builder.PrependFloat32Slot(1, max, 0.0)
def ClipAttrsEnd(builder): return builder.EndObject()


class ClipAttrsT(object):

    # ClipAttrsT
    def __init__(self):
        self.min = 0.0  # type: float
        self.max = 0.0  # type: float

    @classmethod
    def InitFromBuf(cls, buf, pos):
        clipAttrs = ClipAttrs()
        clipAttrs.Init(buf, pos)
        return cls.InitFromObj(clipAttrs)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, clipAttrs):
        x = ClipAttrsT()
        x._UnPack(clipAttrs)
        return x

    # ClipAttrsT
    def _UnPack(self, clipAttrs):
        if clipAttrs is None:
            return
        self.min = clipAttrs.Min()
        self.max = clipAttrs.Max()

    # ClipAttrsT
    def Pack(self, builder):
        ClipAttrsStart(builder)
        ClipAttrsAddMin(builder, self.min)
        ClipAttrsAddMax(builder, self.max)
        clipAttrs = ClipAttrsEnd(builder)
        return clipAttrs


class ConcatAttrs(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = ConcatAttrs()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsConcatAttrs(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def ConcatAttrsBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x4D\x4F\x44\x4C", size_prefixed=size_prefixed)

    # ConcatAttrs
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # ConcatAttrs
    def Dim(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

def ConcatAttrsStart(builder): builder.StartObject(1)
def ConcatAttrsAddDim(builder, dim): builder.PrependUint32Slot(0, dim, 0)
def ConcatAttrsEnd(builder): return builder.EndObject()


class ConcatAttrsT(object):

    # ConcatAttrsT
    def __init__(self):
        self.dim = 0  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        concatAttrs = ConcatAttrs()
        concatAttrs.Init(buf, pos)
        return cls.InitFromObj(concatAttrs)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, concatAttrs):
        x = ConcatAttrsT()
        x._UnPack(concatAttrs)
        return x

    # ConcatAttrsT
    def _UnPack(self, concatAttrs):
        if concatAttrs is None:
            return
        self.dim = concatAttrs.Dim()

    # ConcatAttrsT
    def Pack(self, builder):
        ConcatAttrsStart(builder)
        ConcatAttrsAddDim(builder, self.dim)
        concatAttrs = ConcatAttrsEnd(builder)
        return concatAttrs


class IntScalar(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = IntScalar()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsIntScalar(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def IntScalarBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x4D\x4F\x44\x4C", size_prefixed=size_prefixed)

    # IntScalar
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # IntScalar
    def Value(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

def IntScalarStart(builder): builder.StartObject(1)
def IntScalarAddValue(builder, value): builder.PrependInt32Slot(0, value, 0)
def IntScalarEnd(builder): return builder.EndObject()


class IntScalarT(object):

    # IntScalarT
    def __init__(self):
        self.value = 0  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        intScalar = IntScalar()
        intScalar.Init(buf, pos)
        return cls.InitFromObj(intScalar)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, intScalar):
        x = IntScalarT()
        x._UnPack(intScalar)
        return x

    # IntScalarT
    def _UnPack(self, intScalar):
        if intScalar is None:
            return
        self.value = intScalar.Value()

    # IntScalarT
    def Pack(self, builder):
        IntScalarStart(builder)
        IntScalarAddValue(builder, self.value)
        intScalar = IntScalarEnd(builder)
        return intScalar


class FloatScalar(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = FloatScalar()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsFloatScalar(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def FloatScalarBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x4D\x4F\x44\x4C", size_prefixed=size_prefixed)

    # FloatScalar
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # FloatScalar
    def Value(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float32Flags, o + self._tab.Pos)
        return 0.0

def FloatScalarStart(builder): builder.StartObject(1)
def FloatScalarAddValue(builder, value): builder.PrependFloat32Slot(0, value, 0.0)
def FloatScalarEnd(builder): return builder.EndObject()


class FloatScalarT(object):

    # FloatScalarT
    def __init__(self):
        self.value = 0.0  # type: float

    @classmethod
    def InitFromBuf(cls, buf, pos):
        floatScalar = FloatScalar()
        floatScalar.Init(buf, pos)
        return cls.InitFromObj(floatScalar)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, floatScalar):
        x = FloatScalarT()
        x._UnPack(floatScalar)
        return x

    # FloatScalarT
    def _UnPack(self, floatScalar):
        if floatScalar is None:
            return
        self.value = floatScalar.Value()

    # FloatScalarT
    def Pack(self, builder):
        FloatScalarStart(builder)
        FloatScalarAddValue(builder, self.value)
        floatScalar = FloatScalarEnd(builder)
        return floatScalar


class ConstantOfShapeAttrs(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = ConstantOfShapeAttrs()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsConstantOfShapeAttrs(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def ConstantOfShapeAttrsBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x4D\x4F\x44\x4C", size_prefixed=size_prefixed)

    # ConstantOfShapeAttrs
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # ConstantOfShapeAttrs
    def ValueType(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, o + self._tab.Pos)
        return 0

    # ConstantOfShapeAttrs
    def Value(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            from flatbuffers.table import Table
            obj = Table(bytearray(), 0)
            self._tab.Union(obj, o)
            return obj
        return None

def ConstantOfShapeAttrsStart(builder): builder.StartObject(2)
def ConstantOfShapeAttrsAddValueType(builder, valueType): builder.PrependUint8Slot(0, valueType, 0)
def ConstantOfShapeAttrsAddValue(builder, value): builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(value), 0)
def ConstantOfShapeAttrsEnd(builder): return builder.EndObject()

try:
    from typing import Union
except:
    pass

class ConstantOfShapeAttrsT(object):

    # ConstantOfShapeAttrsT
    def __init__(self):
        self.valueType = 0  # type: int
        self.value = None  # type: Union[None, IntScalarT, FloatScalarT]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        constantOfShapeAttrs = ConstantOfShapeAttrs()
        constantOfShapeAttrs.Init(buf, pos)
        return cls.InitFromObj(constantOfShapeAttrs)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, constantOfShapeAttrs):
        x = ConstantOfShapeAttrsT()
        x._UnPack(constantOfShapeAttrs)
        return x

    # ConstantOfShapeAttrsT
    def _UnPack(self, constantOfShapeAttrs):
        if constantOfShapeAttrs is None:
            return
        self.valueType = constantOfShapeAttrs.ValueType()
        self.value = ScalarCreator(self.valueType, constantOfShapeAttrs.Value())

    # ConstantOfShapeAttrsT
    def Pack(self, builder):
        if self.value is not None:
            value = self.value.Pack(builder)
        ConstantOfShapeAttrsStart(builder)
        ConstantOfShapeAttrsAddValueType(builder, self.valueType)
        if self.value is not None:
            ConstantOfShapeAttrsAddValue(builder, value)
        constantOfShapeAttrs = ConstantOfShapeAttrsEnd(builder)
        return constantOfShapeAttrs


class ConvAttrs(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = ConvAttrs()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsConvAttrs(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def ConvAttrsBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x4D\x4F\x44\x4C", size_prefixed=size_prefixed)

    # ConvAttrs
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # ConvAttrs
    def PadMode(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int8Flags, o + self._tab.Pos)
        return 0

    # ConvAttrs
    def Pads(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # ConvAttrs
    def PadsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint32Flags, o)
        return 0

    # ConvAttrs
    def PadsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # ConvAttrs
    def PadsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return o == 0

    # ConvAttrs
    def Groups(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

    # ConvAttrs
    def Strides(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # ConvAttrs
    def StridesAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint32Flags, o)
        return 0

    # ConvAttrs
    def StridesLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # ConvAttrs
    def StridesIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        return o == 0

def ConvAttrsStart(builder): builder.StartObject(4)
def ConvAttrsAddPadMode(builder, padMode): builder.PrependInt8Slot(0, padMode, 0)
def ConvAttrsAddPads(builder, pads): builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(pads), 0)
def ConvAttrsStartPadsVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def ConvAttrsAddGroups(builder, groups): builder.PrependUint32Slot(2, groups, 0)
def ConvAttrsAddStrides(builder, strides): builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(strides), 0)
def ConvAttrsStartStridesVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def ConvAttrsEnd(builder): return builder.EndObject()

try:
    from typing import List
except:
    pass

class ConvAttrsT(object):

    # ConvAttrsT
    def __init__(self):
        self.padMode = 0  # type: int
        self.pads = None  # type: List[int]
        self.groups = 0  # type: int
        self.strides = None  # type: List[int]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        convAttrs = ConvAttrs()
        convAttrs.Init(buf, pos)
        return cls.InitFromObj(convAttrs)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, convAttrs):
        x = ConvAttrsT()
        x._UnPack(convAttrs)
        return x

    # ConvAttrsT
    def _UnPack(self, convAttrs):
        if convAttrs is None:
            return
        self.padMode = convAttrs.PadMode()
        if not convAttrs.PadsIsNone():
            if np is None:
                self.pads = []
                for i in range(convAttrs.PadsLength()):
                    self.pads.append(convAttrs.Pads(i))
            else:
                self.pads = convAttrs.PadsAsNumpy()
        self.groups = convAttrs.Groups()
        if not convAttrs.StridesIsNone():
            if np is None:
                self.strides = []
                for i in range(convAttrs.StridesLength()):
                    self.strides.append(convAttrs.Strides(i))
            else:
                self.strides = convAttrs.StridesAsNumpy()

    # ConvAttrsT
    def Pack(self, builder):
        if self.pads is not None:
            if np is not None and type(self.pads) is np.ndarray:
                pads = builder.CreateNumpyVector(self.pads)
            else:
                ConvAttrsStartPadsVector(builder, len(self.pads))
                for i in reversed(range(len(self.pads))):
                    builder.PrependUint32(self.pads[i])
                pads = builder.EndVector()
        if self.strides is not None:
            if np is not None and type(self.strides) is np.ndarray:
                strides = builder.CreateNumpyVector(self.strides)
            else:
                ConvAttrsStartStridesVector(builder, len(self.strides))
                for i in reversed(range(len(self.strides))):
                    builder.PrependUint32(self.strides[i])
                strides = builder.EndVector()
        ConvAttrsStart(builder)
        ConvAttrsAddPadMode(builder, self.padMode)
        if self.pads is not None:
            ConvAttrsAddPads(builder, pads)
        ConvAttrsAddGroups(builder, self.groups)
        if self.strides is not None:
            ConvAttrsAddStrides(builder, strides)
        convAttrs = ConvAttrsEnd(builder)
        return convAttrs


class ConvTransposeAttrs(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = ConvTransposeAttrs()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsConvTransposeAttrs(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def ConvTransposeAttrsBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x4D\x4F\x44\x4C", size_prefixed=size_prefixed)

    # ConvTransposeAttrs
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # ConvTransposeAttrs
    def Strides(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # ConvTransposeAttrs
    def StridesAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint32Flags, o)
        return 0

    # ConvTransposeAttrs
    def StridesLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # ConvTransposeAttrs
    def StridesIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0

def ConvTransposeAttrsStart(builder): builder.StartObject(1)
def ConvTransposeAttrsAddStrides(builder, strides): builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(strides), 0)
def ConvTransposeAttrsStartStridesVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def ConvTransposeAttrsEnd(builder): return builder.EndObject()

try:
    from typing import List
except:
    pass

class ConvTransposeAttrsT(object):

    # ConvTransposeAttrsT
    def __init__(self):
        self.strides = None  # type: List[int]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        convTransposeAttrs = ConvTransposeAttrs()
        convTransposeAttrs.Init(buf, pos)
        return cls.InitFromObj(convTransposeAttrs)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, convTransposeAttrs):
        x = ConvTransposeAttrsT()
        x._UnPack(convTransposeAttrs)
        return x

    # ConvTransposeAttrsT
    def _UnPack(self, convTransposeAttrs):
        if convTransposeAttrs is None:
            return
        if not convTransposeAttrs.StridesIsNone():
            if np is None:
                self.strides = []
                for i in range(convTransposeAttrs.StridesLength()):
                    self.strides.append(convTransposeAttrs.Strides(i))
            else:
                self.strides = convTransposeAttrs.StridesAsNumpy()

    # ConvTransposeAttrsT
    def Pack(self, builder):
        if self.strides is not None:
            if np is not None and type(self.strides) is np.ndarray:
                strides = builder.CreateNumpyVector(self.strides)
            else:
                ConvTransposeAttrsStartStridesVector(builder, len(self.strides))
                for i in reversed(range(len(self.strides))):
                    builder.PrependUint32(self.strides[i])
                strides = builder.EndVector()
        ConvTransposeAttrsStart(builder)
        if self.strides is not None:
            ConvTransposeAttrsAddStrides(builder, strides)
        convTransposeAttrs = ConvTransposeAttrsEnd(builder)
        return convTransposeAttrs


class GatherAttrs(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = GatherAttrs()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsGatherAttrs(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def GatherAttrsBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x4D\x4F\x44\x4C", size_prefixed=size_prefixed)

    # GatherAttrs
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # GatherAttrs
    def Axis(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

def GatherAttrsStart(builder): builder.StartObject(1)
def GatherAttrsAddAxis(builder, axis): builder.PrependUint32Slot(0, axis, 0)
def GatherAttrsEnd(builder): return builder.EndObject()


class GatherAttrsT(object):

    # GatherAttrsT
    def __init__(self):
        self.axis = 0  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        gatherAttrs = GatherAttrs()
        gatherAttrs.Init(buf, pos)
        return cls.InitFromObj(gatherAttrs)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, gatherAttrs):
        x = GatherAttrsT()
        x._UnPack(gatherAttrs)
        return x

    # GatherAttrsT
    def _UnPack(self, gatherAttrs):
        if gatherAttrs is None:
            return
        self.axis = gatherAttrs.Axis()

    # GatherAttrsT
    def Pack(self, builder):
        GatherAttrsStart(builder)
        GatherAttrsAddAxis(builder, self.axis)
        gatherAttrs = GatherAttrsEnd(builder)
        return gatherAttrs


class GemmAttrs(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = GemmAttrs()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsGemmAttrs(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def GemmAttrsBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x4D\x4F\x44\x4C", size_prefixed=size_prefixed)

    # GemmAttrs
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # GemmAttrs
    def Alpha(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float32Flags, o + self._tab.Pos)
        return 0.0

    # GemmAttrs
    def Beta(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float32Flags, o + self._tab.Pos)
        return 0.0

    # GemmAttrs
    def TransposeA(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
        return False

    # GemmAttrs
    def TransposeB(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
        return False

def GemmAttrsStart(builder): builder.StartObject(4)
def GemmAttrsAddAlpha(builder, alpha): builder.PrependFloat32Slot(0, alpha, 0.0)
def GemmAttrsAddBeta(builder, beta): builder.PrependFloat32Slot(1, beta, 0.0)
def GemmAttrsAddTransposeA(builder, transposeA): builder.PrependBoolSlot(2, transposeA, 0)
def GemmAttrsAddTransposeB(builder, transposeB): builder.PrependBoolSlot(3, transposeB, 0)
def GemmAttrsEnd(builder): return builder.EndObject()


class GemmAttrsT(object):

    # GemmAttrsT
    def __init__(self):
        self.alpha = 0.0  # type: float
        self.beta = 0.0  # type: float
        self.transposeA = False  # type: bool
        self.transposeB = False  # type: bool

    @classmethod
    def InitFromBuf(cls, buf, pos):
        gemmAttrs = GemmAttrs()
        gemmAttrs.Init(buf, pos)
        return cls.InitFromObj(gemmAttrs)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, gemmAttrs):
        x = GemmAttrsT()
        x._UnPack(gemmAttrs)
        return x

    # GemmAttrsT
    def _UnPack(self, gemmAttrs):
        if gemmAttrs is None:
            return
        self.alpha = gemmAttrs.Alpha()
        self.beta = gemmAttrs.Beta()
        self.transposeA = gemmAttrs.TransposeA()
        self.transposeB = gemmAttrs.TransposeB()

    # GemmAttrsT
    def Pack(self, builder):
        GemmAttrsStart(builder)
        GemmAttrsAddAlpha(builder, self.alpha)
        GemmAttrsAddBeta(builder, self.beta)
        GemmAttrsAddTransposeA(builder, self.transposeA)
        GemmAttrsAddTransposeB(builder, self.transposeB)
        gemmAttrs = GemmAttrsEnd(builder)
        return gemmAttrs


class LeakyReluAttrs(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = LeakyReluAttrs()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsLeakyReluAttrs(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def LeakyReluAttrsBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x4D\x4F\x44\x4C", size_prefixed=size_prefixed)

    # LeakyReluAttrs
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # LeakyReluAttrs
    def Alpha(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float32Flags, o + self._tab.Pos)
        return 0.0

def LeakyReluAttrsStart(builder): builder.StartObject(1)
def LeakyReluAttrsAddAlpha(builder, alpha): builder.PrependFloat32Slot(0, alpha, 0.0)
def LeakyReluAttrsEnd(builder): return builder.EndObject()


class LeakyReluAttrsT(object):

    # LeakyReluAttrsT
    def __init__(self):
        self.alpha = 0.0  # type: float

    @classmethod
    def InitFromBuf(cls, buf, pos):
        leakyReluAttrs = LeakyReluAttrs()
        leakyReluAttrs.Init(buf, pos)
        return cls.InitFromObj(leakyReluAttrs)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, leakyReluAttrs):
        x = LeakyReluAttrsT()
        x._UnPack(leakyReluAttrs)
        return x

    # LeakyReluAttrsT
    def _UnPack(self, leakyReluAttrs):
        if leakyReluAttrs is None:
            return
        self.alpha = leakyReluAttrs.Alpha()

    # LeakyReluAttrsT
    def Pack(self, builder):
        LeakyReluAttrsStart(builder)
        LeakyReluAttrsAddAlpha(builder, self.alpha)
        leakyReluAttrs = LeakyReluAttrsEnd(builder)
        return leakyReluAttrs


class MaxPoolAttrs(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = MaxPoolAttrs()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsMaxPoolAttrs(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def MaxPoolAttrsBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x4D\x4F\x44\x4C", size_prefixed=size_prefixed)

    # MaxPoolAttrs
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # MaxPoolAttrs
    def KernelSize(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # MaxPoolAttrs
    def KernelSizeAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint32Flags, o)
        return 0

    # MaxPoolAttrs
    def KernelSizeLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # MaxPoolAttrs
    def KernelSizeIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0

    # MaxPoolAttrs
    def PadMode(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int8Flags, o + self._tab.Pos)
        return 0

    # MaxPoolAttrs
    def Pads(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # MaxPoolAttrs
    def PadsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint32Flags, o)
        return 0

    # MaxPoolAttrs
    def PadsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # MaxPoolAttrs
    def PadsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        return o == 0

    # MaxPoolAttrs
    def Strides(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # MaxPoolAttrs
    def StridesAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint32Flags, o)
        return 0

    # MaxPoolAttrs
    def StridesLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # MaxPoolAttrs
    def StridesIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        return o == 0

def MaxPoolAttrsStart(builder): builder.StartObject(4)
def MaxPoolAttrsAddKernelSize(builder, kernelSize): builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(kernelSize), 0)
def MaxPoolAttrsStartKernelSizeVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def MaxPoolAttrsAddPadMode(builder, padMode): builder.PrependInt8Slot(1, padMode, 0)
def MaxPoolAttrsAddPads(builder, pads): builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(pads), 0)
def MaxPoolAttrsStartPadsVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def MaxPoolAttrsAddStrides(builder, strides): builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(strides), 0)
def MaxPoolAttrsStartStridesVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def MaxPoolAttrsEnd(builder): return builder.EndObject()

try:
    from typing import List
except:
    pass

class MaxPoolAttrsT(object):

    # MaxPoolAttrsT
    def __init__(self):
        self.kernelSize = None  # type: List[int]
        self.padMode = 0  # type: int
        self.pads = None  # type: List[int]
        self.strides = None  # type: List[int]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        maxPoolAttrs = MaxPoolAttrs()
        maxPoolAttrs.Init(buf, pos)
        return cls.InitFromObj(maxPoolAttrs)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, maxPoolAttrs):
        x = MaxPoolAttrsT()
        x._UnPack(maxPoolAttrs)
        return x

    # MaxPoolAttrsT
    def _UnPack(self, maxPoolAttrs):
        if maxPoolAttrs is None:
            return
        if not maxPoolAttrs.KernelSizeIsNone():
            if np is None:
                self.kernelSize = []
                for i in range(maxPoolAttrs.KernelSizeLength()):
                    self.kernelSize.append(maxPoolAttrs.KernelSize(i))
            else:
                self.kernelSize = maxPoolAttrs.KernelSizeAsNumpy()
        self.padMode = maxPoolAttrs.PadMode()
        if not maxPoolAttrs.PadsIsNone():
            if np is None:
                self.pads = []
                for i in range(maxPoolAttrs.PadsLength()):
                    self.pads.append(maxPoolAttrs.Pads(i))
            else:
                self.pads = maxPoolAttrs.PadsAsNumpy()
        if not maxPoolAttrs.StridesIsNone():
            if np is None:
                self.strides = []
                for i in range(maxPoolAttrs.StridesLength()):
                    self.strides.append(maxPoolAttrs.Strides(i))
            else:
                self.strides = maxPoolAttrs.StridesAsNumpy()

    # MaxPoolAttrsT
    def Pack(self, builder):
        if self.kernelSize is not None:
            if np is not None and type(self.kernelSize) is np.ndarray:
                kernelSize = builder.CreateNumpyVector(self.kernelSize)
            else:
                MaxPoolAttrsStartKernelSizeVector(builder, len(self.kernelSize))
                for i in reversed(range(len(self.kernelSize))):
                    builder.PrependUint32(self.kernelSize[i])
                kernelSize = builder.EndVector()
        if self.pads is not None:
            if np is not None and type(self.pads) is np.ndarray:
                pads = builder.CreateNumpyVector(self.pads)
            else:
                MaxPoolAttrsStartPadsVector(builder, len(self.pads))
                for i in reversed(range(len(self.pads))):
                    builder.PrependUint32(self.pads[i])
                pads = builder.EndVector()
        if self.strides is not None:
            if np is not None and type(self.strides) is np.ndarray:
                strides = builder.CreateNumpyVector(self.strides)
            else:
                MaxPoolAttrsStartStridesVector(builder, len(self.strides))
                for i in reversed(range(len(self.strides))):
                    builder.PrependUint32(self.strides[i])
                strides = builder.EndVector()
        MaxPoolAttrsStart(builder)
        if self.kernelSize is not None:
            MaxPoolAttrsAddKernelSize(builder, kernelSize)
        MaxPoolAttrsAddPadMode(builder, self.padMode)
        if self.pads is not None:
            MaxPoolAttrsAddPads(builder, pads)
        if self.strides is not None:
            MaxPoolAttrsAddStrides(builder, strides)
        maxPoolAttrs = MaxPoolAttrsEnd(builder)
        return maxPoolAttrs


class PadAttrs(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = PadAttrs()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsPadAttrs(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def PadAttrsBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x4D\x4F\x44\x4C", size_prefixed=size_prefixed)

    # PadAttrs
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

def PadAttrsStart(builder): builder.StartObject(0)
def PadAttrsEnd(builder): return builder.EndObject()


class PadAttrsT(object):

    # PadAttrsT
    def __init__(self):
        pass

    @classmethod
    def InitFromBuf(cls, buf, pos):
        padAttrs = PadAttrs()
        padAttrs.Init(buf, pos)
        return cls.InitFromObj(padAttrs)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, padAttrs):
        x = PadAttrsT()
        x._UnPack(padAttrs)
        return x

    # PadAttrsT
    def _UnPack(self, padAttrs):
        if padAttrs is None:
            return

    # PadAttrsT
    def Pack(self, builder):
        PadAttrsStart(builder)
        padAttrs = PadAttrsEnd(builder)
        return padAttrs


class ReduceMeanAttrs(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = ReduceMeanAttrs()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsReduceMeanAttrs(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def ReduceMeanAttrsBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x4D\x4F\x44\x4C", size_prefixed=size_prefixed)

    # ReduceMeanAttrs
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # ReduceMeanAttrs
    def Axes(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # ReduceMeanAttrs
    def AxesAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int32Flags, o)
        return 0

    # ReduceMeanAttrs
    def AxesLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # ReduceMeanAttrs
    def AxesIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0

    # ReduceMeanAttrs
    def KeepDims(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
        return False

def ReduceMeanAttrsStart(builder): builder.StartObject(2)
def ReduceMeanAttrsAddAxes(builder, axes): builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(axes), 0)
def ReduceMeanAttrsStartAxesVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def ReduceMeanAttrsAddKeepDims(builder, keepDims): builder.PrependBoolSlot(1, keepDims, 0)
def ReduceMeanAttrsEnd(builder): return builder.EndObject()

try:
    from typing import List
except:
    pass

class ReduceMeanAttrsT(object):

    # ReduceMeanAttrsT
    def __init__(self):
        self.axes = None  # type: List[int]
        self.keepDims = False  # type: bool

    @classmethod
    def InitFromBuf(cls, buf, pos):
        reduceMeanAttrs = ReduceMeanAttrs()
        reduceMeanAttrs.Init(buf, pos)
        return cls.InitFromObj(reduceMeanAttrs)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, reduceMeanAttrs):
        x = ReduceMeanAttrsT()
        x._UnPack(reduceMeanAttrs)
        return x

    # ReduceMeanAttrsT
    def _UnPack(self, reduceMeanAttrs):
        if reduceMeanAttrs is None:
            return
        if not reduceMeanAttrs.AxesIsNone():
            if np is None:
                self.axes = []
                for i in range(reduceMeanAttrs.AxesLength()):
                    self.axes.append(reduceMeanAttrs.Axes(i))
            else:
                self.axes = reduceMeanAttrs.AxesAsNumpy()
        self.keepDims = reduceMeanAttrs.KeepDims()

    # ReduceMeanAttrsT
    def Pack(self, builder):
        if self.axes is not None:
            if np is not None and type(self.axes) is np.ndarray:
                axes = builder.CreateNumpyVector(self.axes)
            else:
                ReduceMeanAttrsStartAxesVector(builder, len(self.axes))
                for i in reversed(range(len(self.axes))):
                    builder.PrependInt32(self.axes[i])
                axes = builder.EndVector()
        ReduceMeanAttrsStart(builder)
        if self.axes is not None:
            ReduceMeanAttrsAddAxes(builder, axes)
        ReduceMeanAttrsAddKeepDims(builder, self.keepDims)
        reduceMeanAttrs = ReduceMeanAttrsEnd(builder)
        return reduceMeanAttrs


class SoftmaxAttrs(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = SoftmaxAttrs()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsSoftmaxAttrs(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def SoftmaxAttrsBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x4D\x4F\x44\x4C", size_prefixed=size_prefixed)

    # SoftmaxAttrs
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # SoftmaxAttrs
    def Axis(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

def SoftmaxAttrsStart(builder): builder.StartObject(1)
def SoftmaxAttrsAddAxis(builder, axis): builder.PrependUint32Slot(0, axis, 0)
def SoftmaxAttrsEnd(builder): return builder.EndObject()


class SoftmaxAttrsT(object):

    # SoftmaxAttrsT
    def __init__(self):
        self.axis = 0  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        softmaxAttrs = SoftmaxAttrs()
        softmaxAttrs.Init(buf, pos)
        return cls.InitFromObj(softmaxAttrs)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, softmaxAttrs):
        x = SoftmaxAttrsT()
        x._UnPack(softmaxAttrs)
        return x

    # SoftmaxAttrsT
    def _UnPack(self, softmaxAttrs):
        if softmaxAttrs is None:
            return
        self.axis = softmaxAttrs.Axis()

    # SoftmaxAttrsT
    def Pack(self, builder):
        SoftmaxAttrsStart(builder)
        SoftmaxAttrsAddAxis(builder, self.axis)
        softmaxAttrs = SoftmaxAttrsEnd(builder)
        return softmaxAttrs


class SplitAttrs(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = SplitAttrs()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsSplitAttrs(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def SplitAttrsBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x4D\x4F\x44\x4C", size_prefixed=size_prefixed)

    # SplitAttrs
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # SplitAttrs
    def Axis(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

    # SplitAttrs
    def Split(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # SplitAttrs
    def SplitAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint32Flags, o)
        return 0

    # SplitAttrs
    def SplitLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # SplitAttrs
    def SplitIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return o == 0

def SplitAttrsStart(builder): builder.StartObject(2)
def SplitAttrsAddAxis(builder, axis): builder.PrependInt32Slot(0, axis, 0)
def SplitAttrsAddSplit(builder, split): builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(split), 0)
def SplitAttrsStartSplitVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def SplitAttrsEnd(builder): return builder.EndObject()

try:
    from typing import List
except:
    pass

class SplitAttrsT(object):

    # SplitAttrsT
    def __init__(self):
        self.axis = 0  # type: int
        self.split = None  # type: List[int]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        splitAttrs = SplitAttrs()
        splitAttrs.Init(buf, pos)
        return cls.InitFromObj(splitAttrs)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, splitAttrs):
        x = SplitAttrsT()
        x._UnPack(splitAttrs)
        return x

    # SplitAttrsT
    def _UnPack(self, splitAttrs):
        if splitAttrs is None:
            return
        self.axis = splitAttrs.Axis()
        if not splitAttrs.SplitIsNone():
            if np is None:
                self.split = []
                for i in range(splitAttrs.SplitLength()):
                    self.split.append(splitAttrs.Split(i))
            else:
                self.split = splitAttrs.SplitAsNumpy()

    # SplitAttrsT
    def Pack(self, builder):
        if self.split is not None:
            if np is not None and type(self.split) is np.ndarray:
                split = builder.CreateNumpyVector(self.split)
            else:
                SplitAttrsStartSplitVector(builder, len(self.split))
                for i in reversed(range(len(self.split))):
                    builder.PrependUint32(self.split[i])
                split = builder.EndVector()
        SplitAttrsStart(builder)
        SplitAttrsAddAxis(builder, self.axis)
        if self.split is not None:
            SplitAttrsAddSplit(builder, split)
        splitAttrs = SplitAttrsEnd(builder)
        return splitAttrs


class SqueezeAttrs(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = SqueezeAttrs()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsSqueezeAttrs(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def SqueezeAttrsBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x4D\x4F\x44\x4C", size_prefixed=size_prefixed)

    # SqueezeAttrs
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # SqueezeAttrs
    def Axes(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # SqueezeAttrs
    def AxesAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint32Flags, o)
        return 0

    # SqueezeAttrs
    def AxesLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # SqueezeAttrs
    def AxesIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0

def SqueezeAttrsStart(builder): builder.StartObject(1)
def SqueezeAttrsAddAxes(builder, axes): builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(axes), 0)
def SqueezeAttrsStartAxesVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def SqueezeAttrsEnd(builder): return builder.EndObject()

try:
    from typing import List
except:
    pass

class SqueezeAttrsT(object):

    # SqueezeAttrsT
    def __init__(self):
        self.axes = None  # type: List[int]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        squeezeAttrs = SqueezeAttrs()
        squeezeAttrs.Init(buf, pos)
        return cls.InitFromObj(squeezeAttrs)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, squeezeAttrs):
        x = SqueezeAttrsT()
        x._UnPack(squeezeAttrs)
        return x

    # SqueezeAttrsT
    def _UnPack(self, squeezeAttrs):
        if squeezeAttrs is None:
            return
        if not squeezeAttrs.AxesIsNone():
            if np is None:
                self.axes = []
                for i in range(squeezeAttrs.AxesLength()):
                    self.axes.append(squeezeAttrs.Axes(i))
            else:
                self.axes = squeezeAttrs.AxesAsNumpy()

    # SqueezeAttrsT
    def Pack(self, builder):
        if self.axes is not None:
            if np is not None and type(self.axes) is np.ndarray:
                axes = builder.CreateNumpyVector(self.axes)
            else:
                SqueezeAttrsStartAxesVector(builder, len(self.axes))
                for i in reversed(range(len(self.axes))):
                    builder.PrependUint32(self.axes[i])
                axes = builder.EndVector()
        SqueezeAttrsStart(builder)
        if self.axes is not None:
            SqueezeAttrsAddAxes(builder, axes)
        squeezeAttrs = SqueezeAttrsEnd(builder)
        return squeezeAttrs


class TransposeAttrs(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = TransposeAttrs()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsTransposeAttrs(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def TransposeAttrsBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x4D\x4F\x44\x4C", size_prefixed=size_prefixed)

    # TransposeAttrs
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # TransposeAttrs
    def Perm(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # TransposeAttrs
    def PermAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint32Flags, o)
        return 0

    # TransposeAttrs
    def PermLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # TransposeAttrs
    def PermIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0

def TransposeAttrsStart(builder): builder.StartObject(1)
def TransposeAttrsAddPerm(builder, perm): builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(perm), 0)
def TransposeAttrsStartPermVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def TransposeAttrsEnd(builder): return builder.EndObject()

try:
    from typing import List
except:
    pass

class TransposeAttrsT(object):

    # TransposeAttrsT
    def __init__(self):
        self.perm = None  # type: List[int]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        transposeAttrs = TransposeAttrs()
        transposeAttrs.Init(buf, pos)
        return cls.InitFromObj(transposeAttrs)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, transposeAttrs):
        x = TransposeAttrsT()
        x._UnPack(transposeAttrs)
        return x

    # TransposeAttrsT
    def _UnPack(self, transposeAttrs):
        if transposeAttrs is None:
            return
        if not transposeAttrs.PermIsNone():
            if np is None:
                self.perm = []
                for i in range(transposeAttrs.PermLength()):
                    self.perm.append(transposeAttrs.Perm(i))
            else:
                self.perm = transposeAttrs.PermAsNumpy()

    # TransposeAttrsT
    def Pack(self, builder):
        if self.perm is not None:
            if np is not None and type(self.perm) is np.ndarray:
                perm = builder.CreateNumpyVector(self.perm)
            else:
                TransposeAttrsStartPermVector(builder, len(self.perm))
                for i in reversed(range(len(self.perm))):
                    builder.PrependUint32(self.perm[i])
                perm = builder.EndVector()
        TransposeAttrsStart(builder)
        if self.perm is not None:
            TransposeAttrsAddPerm(builder, perm)
        transposeAttrs = TransposeAttrsEnd(builder)
        return transposeAttrs


class UnsqueezeAttrs(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = UnsqueezeAttrs()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsUnsqueezeAttrs(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def UnsqueezeAttrsBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x4D\x4F\x44\x4C", size_prefixed=size_prefixed)

    # UnsqueezeAttrs
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # UnsqueezeAttrs
    def Axes(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # UnsqueezeAttrs
    def AxesAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint32Flags, o)
        return 0

    # UnsqueezeAttrs
    def AxesLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # UnsqueezeAttrs
    def AxesIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0

def UnsqueezeAttrsStart(builder): builder.StartObject(1)
def UnsqueezeAttrsAddAxes(builder, axes): builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(axes), 0)
def UnsqueezeAttrsStartAxesVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def UnsqueezeAttrsEnd(builder): return builder.EndObject()

try:
    from typing import List
except:
    pass

class UnsqueezeAttrsT(object):

    # UnsqueezeAttrsT
    def __init__(self):
        self.axes = None  # type: List[int]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        unsqueezeAttrs = UnsqueezeAttrs()
        unsqueezeAttrs.Init(buf, pos)
        return cls.InitFromObj(unsqueezeAttrs)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, unsqueezeAttrs):
        x = UnsqueezeAttrsT()
        x._UnPack(unsqueezeAttrs)
        return x

    # UnsqueezeAttrsT
    def _UnPack(self, unsqueezeAttrs):
        if unsqueezeAttrs is None:
            return
        if not unsqueezeAttrs.AxesIsNone():
            if np is None:
                self.axes = []
                for i in range(unsqueezeAttrs.AxesLength()):
                    self.axes.append(unsqueezeAttrs.Axes(i))
            else:
                self.axes = unsqueezeAttrs.AxesAsNumpy()

    # UnsqueezeAttrsT
    def Pack(self, builder):
        if self.axes is not None:
            if np is not None and type(self.axes) is np.ndarray:
                axes = builder.CreateNumpyVector(self.axes)
            else:
                UnsqueezeAttrsStartAxesVector(builder, len(self.axes))
                for i in reversed(range(len(self.axes))):
                    builder.PrependUint32(self.axes[i])
                axes = builder.EndVector()
        UnsqueezeAttrsStart(builder)
        if self.axes is not None:
            UnsqueezeAttrsAddAxes(builder, axes)
        unsqueezeAttrs = UnsqueezeAttrsEnd(builder)
        return unsqueezeAttrs


class ResizeAttrs(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = ResizeAttrs()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsResizeAttrs(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def ResizeAttrsBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x4D\x4F\x44\x4C", size_prefixed=size_prefixed)

    # ResizeAttrs
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # ResizeAttrs
    def Mode(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int8Flags, o + self._tab.Pos)
        return 0

def ResizeAttrsStart(builder): builder.StartObject(1)
def ResizeAttrsAddMode(builder, mode): builder.PrependInt8Slot(0, mode, 0)
def ResizeAttrsEnd(builder): return builder.EndObject()


class ResizeAttrsT(object):

    # ResizeAttrsT
    def __init__(self):
        self.mode = 0  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        resizeAttrs = ResizeAttrs()
        resizeAttrs.Init(buf, pos)
        return cls.InitFromObj(resizeAttrs)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, resizeAttrs):
        x = ResizeAttrsT()
        x._UnPack(resizeAttrs)
        return x

    # ResizeAttrsT
    def _UnPack(self, resizeAttrs):
        if resizeAttrs is None:
            return
        self.mode = resizeAttrs.Mode()

    # ResizeAttrsT
    def Pack(self, builder):
        ResizeAttrsStart(builder)
        ResizeAttrsAddMode(builder, self.mode)
        resizeAttrs = ResizeAttrsEnd(builder)
        return resizeAttrs


class OperatorNode(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = OperatorNode()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsOperatorNode(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def OperatorNodeBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x4D\x4F\x44\x4C", size_prefixed=size_prefixed)

    # OperatorNode
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # OperatorNode
    def Type(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int8Flags, o + self._tab.Pos)
        return 0

    # OperatorNode
    def AttrsType(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, o + self._tab.Pos)
        return 0

    # OperatorNode
    def Attrs(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            from flatbuffers.table import Table
            obj = Table(bytearray(), 0)
            self._tab.Union(obj, o)
            return obj
        return None

    # OperatorNode
    def Inputs(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # OperatorNode
    def InputsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int32Flags, o)
        return 0

    # OperatorNode
    def InputsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # OperatorNode
    def InputsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        return o == 0

    # OperatorNode
    def Outputs(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # OperatorNode
    def OutputsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int32Flags, o)
        return 0

    # OperatorNode
    def OutputsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # OperatorNode
    def OutputsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        return o == 0

def OperatorNodeStart(builder): builder.StartObject(5)
def OperatorNodeAddType(builder, type): builder.PrependInt8Slot(0, type, 0)
def OperatorNodeAddAttrsType(builder, attrsType): builder.PrependUint8Slot(1, attrsType, 0)
def OperatorNodeAddAttrs(builder, attrs): builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(attrs), 0)
def OperatorNodeAddInputs(builder, inputs): builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(inputs), 0)
def OperatorNodeStartInputsVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def OperatorNodeAddOutputs(builder, outputs): builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(outputs), 0)
def OperatorNodeStartOutputsVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def OperatorNodeEnd(builder): return builder.EndObject()

try:
    from typing import List, Union
except:
    pass

class OperatorNodeT(object):

    # OperatorNodeT
    def __init__(self):
        self.type = 0  # type: int
        self.attrsType = 0  # type: int
        self.attrs = None  # type: Union[None, AveragePoolAttrsT, BatchNormalizationAttrsT, CastAttrsT, ClipAttrsT, ConcatAttrsT, ConstantOfShapeAttrsT, ConvAttrsT, ConvTransposeAttrsT, GatherAttrsT, GemmAttrsT, LeakyReluAttrsT, MaxPoolAttrsT, PadAttrsT, ReduceMeanAttrsT, ResizeAttrsT, SplitAttrsT, SqueezeAttrsT, SoftmaxAttrsT, TransposeAttrsT, UnsqueezeAttrsT]
        self.inputs = None  # type: List[int]
        self.outputs = None  # type: List[int]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        operatorNode = OperatorNode()
        operatorNode.Init(buf, pos)
        return cls.InitFromObj(operatorNode)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, operatorNode):
        x = OperatorNodeT()
        x._UnPack(operatorNode)
        return x

    # OperatorNodeT
    def _UnPack(self, operatorNode):
        if operatorNode is None:
            return
        self.type = operatorNode.Type()
        self.attrsType = operatorNode.AttrsType()
        self.attrs = OperatorAttrsCreator(self.attrsType, operatorNode.Attrs())
        if not operatorNode.InputsIsNone():
            if np is None:
                self.inputs = []
                for i in range(operatorNode.InputsLength()):
                    self.inputs.append(operatorNode.Inputs(i))
            else:
                self.inputs = operatorNode.InputsAsNumpy()
        if not operatorNode.OutputsIsNone():
            if np is None:
                self.outputs = []
                for i in range(operatorNode.OutputsLength()):
                    self.outputs.append(operatorNode.Outputs(i))
            else:
                self.outputs = operatorNode.OutputsAsNumpy()

    # OperatorNodeT
    def Pack(self, builder):
        if self.attrs is not None:
            attrs = self.attrs.Pack(builder)
        if self.inputs is not None:
            if np is not None and type(self.inputs) is np.ndarray:
                inputs = builder.CreateNumpyVector(self.inputs)
            else:
                OperatorNodeStartInputsVector(builder, len(self.inputs))
                for i in reversed(range(len(self.inputs))):
                    builder.PrependInt32(self.inputs[i])
                inputs = builder.EndVector()
        if self.outputs is not None:
            if np is not None and type(self.outputs) is np.ndarray:
                outputs = builder.CreateNumpyVector(self.outputs)
            else:
                OperatorNodeStartOutputsVector(builder, len(self.outputs))
                for i in reversed(range(len(self.outputs))):
                    builder.PrependInt32(self.outputs[i])
                outputs = builder.EndVector()
        OperatorNodeStart(builder)
        OperatorNodeAddType(builder, self.type)
        OperatorNodeAddAttrsType(builder, self.attrsType)
        if self.attrs is not None:
            OperatorNodeAddAttrs(builder, attrs)
        if self.inputs is not None:
            OperatorNodeAddInputs(builder, inputs)
        if self.outputs is not None:
            OperatorNodeAddOutputs(builder, outputs)
        operatorNode = OperatorNodeEnd(builder)
        return operatorNode


class FloatData(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = FloatData()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsFloatData(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def FloatDataBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x4D\x4F\x44\x4C", size_prefixed=size_prefixed)

    # FloatData
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # FloatData
    def Data(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Float32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # FloatData
    def DataAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Float32Flags, o)
        return 0

    # FloatData
    def DataLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # FloatData
    def DataIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0

def FloatDataStart(builder): builder.StartObject(1)
def FloatDataAddData(builder, data): builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(data), 0)
def FloatDataStartDataVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def FloatDataEnd(builder): return builder.EndObject()

try:
    from typing import List
except:
    pass

class FloatDataT(object):

    # FloatDataT
    def __init__(self):
        self.data = None  # type: List[float]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        floatData = FloatData()
        floatData.Init(buf, pos)
        return cls.InitFromObj(floatData)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, floatData):
        x = FloatDataT()
        x._UnPack(floatData)
        return x

    # FloatDataT
    def _UnPack(self, floatData):
        if floatData is None:
            return
        if not floatData.DataIsNone():
            if np is None:
                self.data = []
                for i in range(floatData.DataLength()):
                    self.data.append(floatData.Data(i))
            else:
                self.data = floatData.DataAsNumpy()

    # FloatDataT
    def Pack(self, builder):
        if self.data is not None:
            if np is not None and type(self.data) is np.ndarray:
                data = builder.CreateNumpyVector(self.data)
            else:
                FloatDataStartDataVector(builder, len(self.data))
                for i in reversed(range(len(self.data))):
                    builder.PrependFloat32(self.data[i])
                data = builder.EndVector()
        FloatDataStart(builder)
        if self.data is not None:
            FloatDataAddData(builder, data)
        floatData = FloatDataEnd(builder)
        return floatData


class IntData(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = IntData()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsIntData(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def IntDataBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x4D\x4F\x44\x4C", size_prefixed=size_prefixed)

    # IntData
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # IntData
    def Data(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # IntData
    def DataAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int32Flags, o)
        return 0

    # IntData
    def DataLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # IntData
    def DataIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0

def IntDataStart(builder): builder.StartObject(1)
def IntDataAddData(builder, data): builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(data), 0)
def IntDataStartDataVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def IntDataEnd(builder): return builder.EndObject()

try:
    from typing import List
except:
    pass

class IntDataT(object):

    # IntDataT
    def __init__(self):
        self.data = None  # type: List[int]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        intData = IntData()
        intData.Init(buf, pos)
        return cls.InitFromObj(intData)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, intData):
        x = IntDataT()
        x._UnPack(intData)
        return x

    # IntDataT
    def _UnPack(self, intData):
        if intData is None:
            return
        if not intData.DataIsNone():
            if np is None:
                self.data = []
                for i in range(intData.DataLength()):
                    self.data.append(intData.Data(i))
            else:
                self.data = intData.DataAsNumpy()

    # IntDataT
    def Pack(self, builder):
        if self.data is not None:
            if np is not None and type(self.data) is np.ndarray:
                data = builder.CreateNumpyVector(self.data)
            else:
                IntDataStartDataVector(builder, len(self.data))
                for i in reversed(range(len(self.data))):
                    builder.PrependInt32(self.data[i])
                data = builder.EndVector()
        IntDataStart(builder)
        if self.data is not None:
            IntDataAddData(builder, data)
        intData = IntDataEnd(builder)
        return intData


class ConstantNode(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = ConstantNode()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsConstantNode(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def ConstantNodeBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x4D\x4F\x44\x4C", size_prefixed=size_prefixed)

    # ConstantNode
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # ConstantNode
    def Shape(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # ConstantNode
    def ShapeAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint32Flags, o)
        return 0

    # ConstantNode
    def ShapeLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # ConstantNode
    def ShapeIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0

    # ConstantNode
    def DataType(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, o + self._tab.Pos)
        return 0

    # ConstantNode
    def Data(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            from flatbuffers.table import Table
            obj = Table(bytearray(), 0)
            self._tab.Union(obj, o)
            return obj
        return None

def ConstantNodeStart(builder): builder.StartObject(3)
def ConstantNodeAddShape(builder, shape): builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(shape), 0)
def ConstantNodeStartShapeVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def ConstantNodeAddDataType(builder, dataType): builder.PrependUint8Slot(1, dataType, 0)
def ConstantNodeAddData(builder, data): builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(data), 0)
def ConstantNodeEnd(builder): return builder.EndObject()

try:
    from typing import List, Union
except:
    pass

class ConstantNodeT(object):

    # ConstantNodeT
    def __init__(self):
        self.shape = None  # type: List[int]
        self.dataType = 0  # type: int
        self.data = None  # type: Union[None, FloatDataT, IntDataT]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        constantNode = ConstantNode()
        constantNode.Init(buf, pos)
        return cls.InitFromObj(constantNode)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, constantNode):
        x = ConstantNodeT()
        x._UnPack(constantNode)
        return x

    # ConstantNodeT
    def _UnPack(self, constantNode):
        if constantNode is None:
            return
        if not constantNode.ShapeIsNone():
            if np is None:
                self.shape = []
                for i in range(constantNode.ShapeLength()):
                    self.shape.append(constantNode.Shape(i))
            else:
                self.shape = constantNode.ShapeAsNumpy()
        self.dataType = constantNode.DataType()
        self.data = ConstantDataCreator(self.dataType, constantNode.Data())

    # ConstantNodeT
    def Pack(self, builder):
        if self.shape is not None:
            if np is not None and type(self.shape) is np.ndarray:
                shape = builder.CreateNumpyVector(self.shape)
            else:
                ConstantNodeStartShapeVector(builder, len(self.shape))
                for i in reversed(range(len(self.shape))):
                    builder.PrependUint32(self.shape[i])
                shape = builder.EndVector()
        if self.data is not None:
            data = self.data.Pack(builder)
        ConstantNodeStart(builder)
        if self.shape is not None:
            ConstantNodeAddShape(builder, shape)
        ConstantNodeAddDataType(builder, self.dataType)
        if self.data is not None:
            ConstantNodeAddData(builder, data)
        constantNode = ConstantNodeEnd(builder)
        return constantNode


class ValueNode(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = ValueNode()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsValueNode(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def ValueNodeBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x4D\x4F\x44\x4C", size_prefixed=size_prefixed)

    # ValueNode
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

def ValueNodeStart(builder): builder.StartObject(0)
def ValueNodeEnd(builder): return builder.EndObject()


class ValueNodeT(object):

    # ValueNodeT
    def __init__(self):
        pass

    @classmethod
    def InitFromBuf(cls, buf, pos):
        valueNode = ValueNode()
        valueNode.Init(buf, pos)
        return cls.InitFromObj(valueNode)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, valueNode):
        x = ValueNodeT()
        x._UnPack(valueNode)
        return x

    # ValueNodeT
    def _UnPack(self, valueNode):
        if valueNode is None:
            return

    # ValueNodeT
    def Pack(self, builder):
        ValueNodeStart(builder)
        valueNode = ValueNodeEnd(builder)
        return valueNode


class Node(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Node()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsNode(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def NodeBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x4D\x4F\x44\x4C", size_prefixed=size_prefixed)

    # Node
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Node
    def Name(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Node
    def DataType(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, o + self._tab.Pos)
        return 0

    # Node
    def Data(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            from flatbuffers.table import Table
            obj = Table(bytearray(), 0)
            self._tab.Union(obj, o)
            return obj
        return None

def NodeStart(builder): builder.StartObject(3)
def NodeAddName(builder, name): builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(name), 0)
def NodeAddDataType(builder, dataType): builder.PrependUint8Slot(1, dataType, 0)
def NodeAddData(builder, data): builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(data), 0)
def NodeEnd(builder): return builder.EndObject()

try:
    from typing import Union
except:
    pass

class NodeT(object):

    # NodeT
    def __init__(self):
        self.name = None  # type: str
        self.dataType = 0  # type: int
        self.data = None  # type: Union[None, OperatorNodeT, ConstantNodeT, ValueNodeT]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        node = Node()
        node.Init(buf, pos)
        return cls.InitFromObj(node)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, node):
        x = NodeT()
        x._UnPack(node)
        return x

    # NodeT
    def _UnPack(self, node):
        if node is None:
            return
        self.name = node.Name()
        self.dataType = node.DataType()
        self.data = NodeKindCreator(self.dataType, node.Data())

    # NodeT
    def Pack(self, builder):
        if self.name is not None:
            name = builder.CreateString(self.name)
        if self.data is not None:
            data = self.data.Pack(builder)
        NodeStart(builder)
        if self.name is not None:
            NodeAddName(builder, name)
        NodeAddDataType(builder, self.dataType)
        if self.data is not None:
            NodeAddData(builder, data)
        node = NodeEnd(builder)
        return node


class Graph(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Graph()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsGraph(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def GraphBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x4D\x4F\x44\x4C", size_prefixed=size_prefixed)

    # Graph
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Graph
    def Nodes(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = Node()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Graph
    def NodesLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Graph
    def NodesIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0

    # Graph
    def Inputs(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # Graph
    def InputsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint32Flags, o)
        return 0

    # Graph
    def InputsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Graph
    def InputsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return o == 0

    # Graph
    def Outputs(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # Graph
    def OutputsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint32Flags, o)
        return 0

    # Graph
    def OutputsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Graph
    def OutputsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        return o == 0

def GraphStart(builder): builder.StartObject(3)
def GraphAddNodes(builder, nodes): builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(nodes), 0)
def GraphStartNodesVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def GraphAddInputs(builder, inputs): builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(inputs), 0)
def GraphStartInputsVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def GraphAddOutputs(builder, outputs): builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(outputs), 0)
def GraphStartOutputsVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def GraphEnd(builder): return builder.EndObject()

try:
    from typing import List
except:
    pass

class GraphT(object):

    # GraphT
    def __init__(self):
        self.nodes = None  # type: List[NodeT]
        self.inputs = None  # type: List[int]
        self.outputs = None  # type: List[int]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        graph = Graph()
        graph.Init(buf, pos)
        return cls.InitFromObj(graph)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, graph):
        x = GraphT()
        x._UnPack(graph)
        return x

    # GraphT
    def _UnPack(self, graph):
        if graph is None:
            return
        if not graph.NodesIsNone():
            self.nodes = []
            for i in range(graph.NodesLength()):
                if graph.Nodes(i) is None:
                    self.nodes.append(None)
                else:
                    node_ = NodeT.InitFromObj(graph.Nodes(i))
                    self.nodes.append(node_)
        if not graph.InputsIsNone():
            if np is None:
                self.inputs = []
                for i in range(graph.InputsLength()):
                    self.inputs.append(graph.Inputs(i))
            else:
                self.inputs = graph.InputsAsNumpy()
        if not graph.OutputsIsNone():
            if np is None:
                self.outputs = []
                for i in range(graph.OutputsLength()):
                    self.outputs.append(graph.Outputs(i))
            else:
                self.outputs = graph.OutputsAsNumpy()

    # GraphT
    def Pack(self, builder):
        if self.nodes is not None:
            nodeslist = []
            for i in range(len(self.nodes)):
                nodeslist.append(self.nodes[i].Pack(builder))
            GraphStartNodesVector(builder, len(self.nodes))
            for i in reversed(range(len(self.nodes))):
                builder.PrependUOffsetTRelative(nodeslist[i])
            nodes = builder.EndVector()
        if self.inputs is not None:
            if np is not None and type(self.inputs) is np.ndarray:
                inputs = builder.CreateNumpyVector(self.inputs)
            else:
                GraphStartInputsVector(builder, len(self.inputs))
                for i in reversed(range(len(self.inputs))):
                    builder.PrependUint32(self.inputs[i])
                inputs = builder.EndVector()
        if self.outputs is not None:
            if np is not None and type(self.outputs) is np.ndarray:
                outputs = builder.CreateNumpyVector(self.outputs)
            else:
                GraphStartOutputsVector(builder, len(self.outputs))
                for i in reversed(range(len(self.outputs))):
                    builder.PrependUint32(self.outputs[i])
                outputs = builder.EndVector()
        GraphStart(builder)
        if self.nodes is not None:
            GraphAddNodes(builder, nodes)
        if self.inputs is not None:
            GraphAddInputs(builder, inputs)
        if self.outputs is not None:
            GraphAddOutputs(builder, outputs)
        graph = GraphEnd(builder)
        return graph


class Model(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Model()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsModel(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def ModelBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x4D\x4F\x44\x4C", size_prefixed=size_prefixed)

    # Model
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Model
    def SchemaVersion(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

    # Model
    def Graph(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = Graph()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

def ModelStart(builder): builder.StartObject(2)
def ModelAddSchemaVersion(builder, schemaVersion): builder.PrependInt32Slot(0, schemaVersion, 0)
def ModelAddGraph(builder, graph): builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(graph), 0)
def ModelEnd(builder): return builder.EndObject()

try:
    from typing import Optional
except:
    pass

class ModelT(object):

    # ModelT
    def __init__(self):
        self.schemaVersion = 0  # type: int
        self.graph = None  # type: Optional[GraphT]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        model = Model()
        model.Init(buf, pos)
        return cls.InitFromObj(model)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, model):
        x = ModelT()
        x._UnPack(model)
        return x

    # ModelT
    def _UnPack(self, model):
        if model is None:
            return
        self.schemaVersion = model.SchemaVersion()
        if model.Graph() is not None:
            self.graph = GraphT.InitFromObj(model.Graph())

    # ModelT
    def Pack(self, builder):
        if self.graph is not None:
            graph = self.graph.Pack(builder)
        ModelStart(builder)
        ModelAddSchemaVersion(builder, self.schemaVersion)
        if self.graph is not None:
            ModelAddGraph(builder, graph)
        model = ModelEnd(builder)
        return model


